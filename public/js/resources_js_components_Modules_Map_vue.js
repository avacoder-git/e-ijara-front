/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_components_Modules_Map_vue"],{

/***/ "./node_modules/@elfalem/leaflet-curve/dist/leaflet.curve.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elfalem/leaflet-curve/dist/leaflet.curve.js ***!
  \*******************************************************************/
/***/ (() => {

eval("!function(t){var n={};function e(i){if(n[i])return n[i].exports;var a=n[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,e),a.l=!0,a.exports}e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&\"object\"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,\"default\",{enumerable:!0,value:t}),2&n&&\"string\"!=typeof t)for(var a in t)e.d(i,a,function(n){return t[n]}.bind(null,a));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p=\"\",e(e.s=0)}([function(t,n){L.Curve=L.Path.extend({options:{},initialize:function(t,n){L.setOptions(this,n),this._setPath(t)},setLatLngs:function(t){return this.setPath(t)},getLatLngs:function(){return this.getPath()},_updateBounds:function(){var t=this._clickTolerance(),n=new L.Point(t,t);this._pxBounds=new L.Bounds([this._rawPxBounds.min.subtract(n),this._rawPxBounds.max.add(n)])},getPath:function(){return this._coords},setPath:function(t){return this._setPath(t),this.redraw()},getBounds:function(){return this._bounds},_setPath:function(t){this._coords=t,this._bounds=this._computeBounds()},_computeBounds:function(){for(var t,n,e,i=new L.LatLngBounds,a=0;a<this._coords.length;a++)if(\"string\"==typeof(e=this._coords[a])||e instanceof String)n=e;else if(\"H\"==n)i.extend([t.lat,e[0]]),t=new L.latLng(t.lat,e[0]);else if(\"V\"==n)i.extend([e[0],t.lng]),t=new L.latLng(e[0],t.lng);else if(\"C\"==n){var s=new L.latLng(e[0],e[1]);e=this._coords[++a];var o=new L.latLng(e[0],e[1]);e=this._coords[++a];var r=new L.latLng(e[0],e[1]);i.extend(s),i.extend(o),i.extend(r),r.controlPoint1=s,r.controlPoint2=o,t=r}else if(\"S\"==n){o=new L.latLng(e[0],e[1]);e=this._coords[++a];r=new L.latLng(e[0],e[1]),s=t;if(t.controlPoint2){var h=t.lat-t.controlPoint2.lat,c=t.lng-t.controlPoint2.lng;s=new L.latLng(t.lat+h,t.lng+c)}i.extend(s),i.extend(o),i.extend(r),r.controlPoint1=s,r.controlPoint2=o,t=r}else if(\"Q\"==n){var u=new L.latLng(e[0],e[1]);e=this._coords[++a];r=new L.latLng(e[0],e[1]);i.extend(u),i.extend(r),r.controlPoint=u,t=r}else if(\"T\"==n){r=new L.latLng(e[0],e[1]),u=t;if(t.controlPoint){h=t.lat-t.controlPoint.lat,c=t.lng-t.controlPoint.lng;u=new L.latLng(t.lat+h,t.lng+c)}i.extend(u),i.extend(r),r.controlPoint=u,t=r}else i.extend(e),t=new L.latLng(e[0],e[1]);return i},getCenter:function(){return this._bounds.getCenter()},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._usingCanvas?this._updateCurveCanvas():this._updateCurveSvg()},_project:function(){var t,n,e,i;this._points=[];for(var a=0;a<this._coords.length;a++)if(\"string\"==typeof(t=this._coords[a])||t instanceof String)this._points.push(t),e=t;else{switch(t.length){case 2:i=this._map.latLngToLayerPoint(t),n=t;break;case 1:\"H\"==e?(i=this._map.latLngToLayerPoint([n[0],t[0]]),n=[n[0],t[0]]):(i=this._map.latLngToLayerPoint([t[0],n[1]]),n=[t[0],n[1]])}this._points.push(i)}if(this._bounds.isValid()){var s=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),o=this._map.latLngToLayerPoint(this._bounds.getSouthEast());this._rawPxBounds=new L.Bounds(s,o),this._updateBounds()}},_curvePointsToPath:function(t){for(var n,e,i=\"\",a=0;a<t.length;a++)if(\"string\"==typeof(n=t[a])||n instanceof String)i+=e=n;else switch(e){case\"H\":i+=n.x+\" \";break;case\"V\":i+=n.y+\" \";break;default:i+=n.x+\",\"+n.y+\" \"}return i||\"M0 0\"},beforeAdd:function(t){L.Path.prototype.beforeAdd.call(this,t),this._usingCanvas=this._renderer instanceof L.Canvas,this._usingCanvas&&(this._pathSvgElement=document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\"))},onAdd:function(t){if(this._usingCanvas&&(this._canvasSetDashArray=!this.options.dashArray),L.Path.prototype.onAdd.call(this,t),this._usingCanvas)this.options.animate&&\"object\"==typeof TWEEN?(this._normalizeCanvasAnimationOptions(),this._tweenedObject={offset:this._pathSvgElement.getTotalLength()},this._tween=new TWEEN.Tween(this._tweenedObject).to({offset:0},this.options.animate.duration).delay(this.options.animate.delay).repeat(this.options.animate.iterations-1).onComplete(function(t){return function(){t._canvasAnimating=!1}}(this)).start(),this._canvasAnimating=!0,this._animateCanvas()):this._canvasAnimating=!1;else if(this.options.animate&&this._path.animate){var n=this._svgSetDashArray();this._path.animate([{strokeDashoffset:n},{strokeDashoffset:0}],this.options.animate)}},_updateCurveSvg:function(){this._renderer._setPath(this,this._curvePointsToPath(this._points)),this.options.animate&&this._svgSetDashArray()},_svgSetDashArray:function(){var t=this._path,n=t.getTotalLength();return this.options.dashArray||(t.style.strokeDasharray=n+\" \"+n),n},_containsPoint:function(t){return!!this._bounds.isValid()&&this._bounds.contains(this._map.layerPointToLatLng(t))},_normalizeCanvasAnimationOptions:function(){var t={delay:0,duration:0,iterations:1};\"number\"==typeof this.options.animate?t.duration=this.options.animate:(this.options.animate.duration&&(t.duration=this.options.animate.duration),this.options.animate.delay&&(t.delay=this.options.animate.delay),this.options.animate.iterations&&(t.iterations=this.options.animate.iterations)),this.options.animate=t},_updateCurveCanvas:function(){var t=this._curvePointsToPath(this._points);this._pathSvgElement.setAttribute(\"d\",t),this.options.animate&&\"object\"==typeof TWEEN&&this._canvasSetDashArray&&(this.options.dashArray=this._pathSvgElement.getTotalLength()+\"\",this._renderer._updateDashArray(this)),this._curveFillStroke(new Path2D(t),this._renderer._ctx)},_animateCanvas:function(){TWEEN.update(),this._renderer._updatePaths(),this._canvasAnimating&&(this._animationFrameId=L.Util.requestAnimFrame(this._animateCanvas,this))},_curveFillStroke:function(t,n){n.lineDashOffset=this._canvasAnimating?this._tweenedObject.offset:0;var e=this.options;e.fill&&(n.globalAlpha=e.fillOpacity,n.fillStyle=e.fillColor||e.color,n.fill(t,e.fillRule||\"evenodd\")),e.stroke&&0!==e.weight&&(n.setLineDash&&n.setLineDash(this.options&&this.options._dashArray||[]),n.globalAlpha=e.opacity,n.lineWidth=e.weight,n.strokeStyle=e.color,n.lineCap=e.lineCap,n.lineJoin=e.lineJoin,n.stroke(t))},trace:function(t){if(void 0===this._map||null===this._map)return[];var n,e,i,a,s,o,r;t=t.filter(function(t){return t>=0&&t<=1});for(var h=[],c=0;c<this._points.length;c++)if(\"string\"==typeof(n=this._points[c])||n instanceof String)\"Z\"==(e=n)&&(h=h.concat(this._linearTrace(t,a,i)));else switch(e){case\"M\":i=n,a=n;break;case\"L\":case\"H\":case\"V\":h=h.concat(this._linearTrace(t,a,n)),a=n;break;case\"C\":s=n,o=this._points[++c],r=this._points[++c],h=h.concat(this._cubicTrace(t,a,s,o,r)),a=r;break;case\"S\":s=this._reflectPoint(o,a),o=n,r=this._points[++c],h=h.concat(this._cubicTrace(t,a,s,o,r)),a=r;break;case\"Q\":s=n,o=this._points[++c],h=h.concat(this._quadraticTrace(t,a,s,o)),a=o;break;case\"T\":s=this._reflectPoint(s,a),o=n,h=h.concat(this._quadraticTrace(t,a,s,o)),a=o}return h},_linearTrace:function(t,n,e){return t.map(t=>{var i=this._singleLinearTrace(t,n.x,e.x),a=this._singleLinearTrace(t,n.y,e.y);return this._map.layerPointToLatLng([i,a])})},_quadraticTrace:function(t,n,e,i){return t.map(t=>{var a=this._singleQuadraticTrace(t,n.x,e.x,i.x),s=this._singleQuadraticTrace(t,n.y,e.y,i.y);return this._map.layerPointToLatLng([a,s])})},_cubicTrace:function(t,n,e,i,a){return t.map(t=>{var s=this._singleCubicTrace(t,n.x,e.x,i.x,a.x),o=this._singleCubicTrace(t,n.y,e.y,i.y,a.y);return this._map.layerPointToLatLng([s,o])})},_singleLinearTrace:function(t,n,e){return n+t*(e-n)},_singleQuadraticTrace:function(t,n,e,i){var a=1-t;return Math.pow(a,2)*n+2*a*t*e+Math.pow(t,2)*i},_singleCubicTrace:function(t,n,e,i,a){var s=1-t;return Math.pow(s,3)*n+3*Math.pow(s,2)*t*e+3*s*Math.pow(t,2)*i+Math.pow(t,3)*a},_reflectPoint:function(t,n){return x=n.x+(n.x-t.x),y=n.y+(n.y-t.y),L.point(x,y)}}),L.curve=function(t,n){return new L.Curve(t,n)}}]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVsZmFsZW0vbGVhZmxldC1jdXJ2ZS9kaXN0L2xlYWZsZXQuY3VydmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxTQUFTLGNBQWMsNEJBQTRCLFlBQVkscUJBQXFCLDJEQUEyRCxnQ0FBZ0MscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQiw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLG1CQUFtQiw4QkFBOEIscURBQXFELDBCQUEwQiw2Q0FBNkMsc0JBQXNCLDZEQUE2RCxZQUFZLGVBQWUsU0FBUyxpQkFBaUIsaUNBQWlDLGlCQUFpQixZQUFZLFVBQVUsc0JBQXNCLG1CQUFtQixpREFBaUQsaUJBQWlCLGdCQUFnQix1QkFBdUIsVUFBVSwwQkFBMEIsc0NBQXNDLHdCQUF3Qix1QkFBdUIsdUJBQXVCLHNCQUFzQiwwQkFBMEIsZ0RBQWdELDhGQUE4RixvQkFBb0Isb0JBQW9CLHFCQUFxQixzQ0FBc0Msc0JBQXNCLG9CQUFvQixzQkFBc0Isa0RBQWtELDJCQUEyQix1Q0FBdUMsc0JBQXNCLG9FQUFvRSxpRUFBaUUsaUVBQWlFLGdCQUFnQiw4QkFBOEIsb0JBQW9CLDhCQUE4QixvQkFBb0IsOEJBQThCLDRFQUE0RSxnQkFBZ0IsMEJBQTBCLG9CQUFvQiw4QkFBOEIsb0JBQW9CLDREQUE0RCxnQ0FBZ0MsNEVBQTRFLGdCQUFnQiw4QkFBOEIsb0JBQW9CLDBCQUEwQiw2Q0FBNkMsZ0JBQWdCLDhCQUE4QixtQkFBbUIsc0RBQXNELGdDQUFnQyw2Q0FBNkMsMkNBQTJDLFNBQVMsc0JBQXNCLGdDQUFnQyxvQkFBb0IsOEJBQThCLHdCQUF3QixtRUFBbUUscUJBQXFCLFlBQVksZ0JBQWdCLFlBQVksc0JBQXNCLHlGQUF5RixLQUFLLGlCQUFpQiw2Q0FBNkMsTUFBTSxzSUFBc0kscUJBQXFCLDJCQUEyQiw0SEFBNEgsMERBQTBELGdDQUFnQyxxQkFBcUIsV0FBVyw0REFBNEQsZUFBZSxtQkFBbUIsTUFBTSxtQkFBbUIsTUFBTSwyQkFBMkIsaUJBQWlCLHVCQUF1QixxTUFBcU0sbUJBQW1CLDBPQUEwTyw2Q0FBNkMsc0RBQXNELFNBQVMsbUlBQW1JLGtCQUFrQix1QkFBdUIseUZBQXlGLGtEQUFrRCw4QkFBOEIscUJBQXFCLG1CQUFtQixFQUFFLG1CQUFtQix5QkFBeUIsNEJBQTRCLGtIQUFrSCw2QkFBNkIsc0NBQXNDLG1FQUFtRSw0QkFBNEIsdUZBQXVGLDZDQUE2QyxPQUFPLGlDQUFpQywwVEFBMFQsK0JBQStCLDRDQUE0QyxrUkFBa1IsMkJBQTJCLCtJQUErSSxnQ0FBZ0Msb0VBQW9FLG1CQUFtQixrVUFBa1UsbUJBQW1CLGlEQUFpRCxrQkFBa0IsdUJBQXVCLGtCQUFrQixFQUFFLGlCQUFpQixzQkFBc0IsbUhBQW1ILGVBQWUsZ0JBQWdCLE1BQU0saUVBQWlFLE1BQU0sZ0dBQWdHLE1BQU0sc0dBQXNHLE1BQU0sOEVBQThFLE1BQU0sb0ZBQW9GLFNBQVMsOEJBQThCLGlCQUFpQiw4RUFBOEUsMkNBQTJDLEVBQUUsbUNBQW1DLGlCQUFpQiw0RkFBNEYsMkNBQTJDLEVBQUUsaUNBQWlDLGlCQUFpQiw0RkFBNEYsMkNBQTJDLEVBQUUsb0NBQW9DLGlCQUFpQix5Q0FBeUMsVUFBVSwrQ0FBK0MsdUNBQXVDLFVBQVUsK0VBQStFLDZCQUE2QixxREFBcUQsd0JBQXdCLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZWxmYWxlbS9sZWFmbGV0LWN1cnZlL2Rpc3QvbGVhZmxldC5jdXJ2ZS5qcz9iNzU5Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0KXt2YXIgbj17fTtmdW5jdGlvbiBlKGkpe2lmKG5baV0pcmV0dXJuIG5baV0uZXhwb3J0czt2YXIgYT1uW2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtpXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyxlKSxhLmw9ITAsYS5leHBvcnRzfWUubT10LGUuYz1uLGUuZD1mdW5jdGlvbih0LG4saSl7ZS5vKHQsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sZS5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGUudD1mdW5jdGlvbih0LG4pe2lmKDEmbiYmKHQ9ZSh0KSksOCZuKXJldHVybiB0O2lmKDQmbiYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGUucihpKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZuJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGEgaW4gdCllLmQoaSxhLGZ1bmN0aW9uKG4pe3JldHVybiB0W25dfS5iaW5kKG51bGwsYSkpO3JldHVybiBpfSxlLm49ZnVuY3Rpb24odCl7dmFyIG49dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIGUuZChuLFwiYVwiLG4pLG59LGUubz1mdW5jdGlvbih0LG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKX0sZS5wPVwiXCIsZShlLnM9MCl9KFtmdW5jdGlvbih0LG4pe0wuQ3VydmU9TC5QYXRoLmV4dGVuZCh7b3B0aW9uczp7fSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsbil7TC5zZXRPcHRpb25zKHRoaXMsbiksdGhpcy5fc2V0UGF0aCh0KX0sc2V0TGF0TG5nczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zZXRQYXRoKHQpfSxnZXRMYXRMbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UGF0aCgpfSxfdXBkYXRlQm91bmRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxuPW5ldyBMLlBvaW50KHQsdCk7dGhpcy5fcHhCb3VuZHM9bmV3IEwuQm91bmRzKFt0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QobiksdGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChuKV0pfSxnZXRQYXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Nvb3Jkc30sc2V0UGF0aDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc2V0UGF0aCh0KSx0aGlzLnJlZHJhdygpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRzfSxfc2V0UGF0aDpmdW5jdGlvbih0KXt0aGlzLl9jb29yZHM9dCx0aGlzLl9ib3VuZHM9dGhpcy5fY29tcHV0ZUJvdW5kcygpfSxfY29tcHV0ZUJvdW5kczpmdW5jdGlvbigpe2Zvcih2YXIgdCxuLGUsaT1uZXcgTC5MYXRMbmdCb3VuZHMsYT0wO2E8dGhpcy5fY29vcmRzLmxlbmd0aDthKyspaWYoXCJzdHJpbmdcIj09dHlwZW9mKGU9dGhpcy5fY29vcmRzW2FdKXx8ZSBpbnN0YW5jZW9mIFN0cmluZyluPWU7ZWxzZSBpZihcIkhcIj09bilpLmV4dGVuZChbdC5sYXQsZVswXV0pLHQ9bmV3IEwubGF0TG5nKHQubGF0LGVbMF0pO2Vsc2UgaWYoXCJWXCI9PW4paS5leHRlbmQoW2VbMF0sdC5sbmddKSx0PW5ldyBMLmxhdExuZyhlWzBdLHQubG5nKTtlbHNlIGlmKFwiQ1wiPT1uKXt2YXIgcz1uZXcgTC5sYXRMbmcoZVswXSxlWzFdKTtlPXRoaXMuX2Nvb3Jkc1srK2FdO3ZhciBvPW5ldyBMLmxhdExuZyhlWzBdLGVbMV0pO2U9dGhpcy5fY29vcmRzWysrYV07dmFyIHI9bmV3IEwubGF0TG5nKGVbMF0sZVsxXSk7aS5leHRlbmQocyksaS5leHRlbmQobyksaS5leHRlbmQociksci5jb250cm9sUG9pbnQxPXMsci5jb250cm9sUG9pbnQyPW8sdD1yfWVsc2UgaWYoXCJTXCI9PW4pe289bmV3IEwubGF0TG5nKGVbMF0sZVsxXSk7ZT10aGlzLl9jb29yZHNbKythXTtyPW5ldyBMLmxhdExuZyhlWzBdLGVbMV0pLHM9dDtpZih0LmNvbnRyb2xQb2ludDIpe3ZhciBoPXQubGF0LXQuY29udHJvbFBvaW50Mi5sYXQsYz10LmxuZy10LmNvbnRyb2xQb2ludDIubG5nO3M9bmV3IEwubGF0TG5nKHQubGF0K2gsdC5sbmcrYyl9aS5leHRlbmQocyksaS5leHRlbmQobyksaS5leHRlbmQociksci5jb250cm9sUG9pbnQxPXMsci5jb250cm9sUG9pbnQyPW8sdD1yfWVsc2UgaWYoXCJRXCI9PW4pe3ZhciB1PW5ldyBMLmxhdExuZyhlWzBdLGVbMV0pO2U9dGhpcy5fY29vcmRzWysrYV07cj1uZXcgTC5sYXRMbmcoZVswXSxlWzFdKTtpLmV4dGVuZCh1KSxpLmV4dGVuZChyKSxyLmNvbnRyb2xQb2ludD11LHQ9cn1lbHNlIGlmKFwiVFwiPT1uKXtyPW5ldyBMLmxhdExuZyhlWzBdLGVbMV0pLHU9dDtpZih0LmNvbnRyb2xQb2ludCl7aD10LmxhdC10LmNvbnRyb2xQb2ludC5sYXQsYz10LmxuZy10LmNvbnRyb2xQb2ludC5sbmc7dT1uZXcgTC5sYXRMbmcodC5sYXQraCx0LmxuZytjKX1pLmV4dGVuZCh1KSxpLmV4dGVuZChyKSxyLmNvbnRyb2xQb2ludD11LHQ9cn1lbHNlIGkuZXh0ZW5kKGUpLHQ9bmV3IEwubGF0TG5nKGVbMF0sZVsxXSk7cmV0dXJuIGl9LGdldENlbnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib3VuZHMuZ2V0Q2VudGVyKCl9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZVBhdGgoKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl91c2luZ0NhbnZhcz90aGlzLl91cGRhdGVDdXJ2ZUNhbnZhcygpOnRoaXMuX3VwZGF0ZUN1cnZlU3ZnKCl9LF9wcm9qZWN0OmZ1bmN0aW9uKCl7dmFyIHQsbixlLGk7dGhpcy5fcG9pbnRzPVtdO2Zvcih2YXIgYT0wO2E8dGhpcy5fY29vcmRzLmxlbmd0aDthKyspaWYoXCJzdHJpbmdcIj09dHlwZW9mKHQ9dGhpcy5fY29vcmRzW2FdKXx8dCBpbnN0YW5jZW9mIFN0cmluZyl0aGlzLl9wb2ludHMucHVzaCh0KSxlPXQ7ZWxzZXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMjppPXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodCksbj10O2JyZWFrO2Nhc2UgMTpcIkhcIj09ZT8oaT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFtuWzBdLHRbMF1dKSxuPVtuWzBdLHRbMF1dKTooaT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFt0WzBdLG5bMV1dKSxuPVt0WzBdLG5bMV1dKX10aGlzLl9wb2ludHMucHVzaChpKX1pZih0aGlzLl9ib3VuZHMuaXNWYWxpZCgpKXt2YXIgcz10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksbz10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSk7dGhpcy5fcmF3UHhCb3VuZHM9bmV3IEwuQm91bmRzKHMsbyksdGhpcy5fdXBkYXRlQm91bmRzKCl9fSxfY3VydmVQb2ludHNUb1BhdGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUsaT1cIlwiLGE9MDthPHQubGVuZ3RoO2ErKylpZihcInN0cmluZ1wiPT10eXBlb2Yobj10W2FdKXx8biBpbnN0YW5jZW9mIFN0cmluZylpKz1lPW47ZWxzZSBzd2l0Y2goZSl7Y2FzZVwiSFwiOmkrPW4ueCtcIiBcIjticmVhaztjYXNlXCJWXCI6aSs9bi55K1wiIFwiO2JyZWFrO2RlZmF1bHQ6aSs9bi54K1wiLFwiK24ueStcIiBcIn1yZXR1cm4gaXx8XCJNMCAwXCJ9LGJlZm9yZUFkZDpmdW5jdGlvbih0KXtMLlBhdGgucHJvdG90eXBlLmJlZm9yZUFkZC5jYWxsKHRoaXMsdCksdGhpcy5fdXNpbmdDYW52YXM9dGhpcy5fcmVuZGVyZXIgaW5zdGFuY2VvZiBMLkNhbnZhcyx0aGlzLl91c2luZ0NhbnZhcyYmKHRoaXMuX3BhdGhTdmdFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJwYXRoXCIpKX0sb25BZGQ6ZnVuY3Rpb24odCl7aWYodGhpcy5fdXNpbmdDYW52YXMmJih0aGlzLl9jYW52YXNTZXREYXNoQXJyYXk9IXRoaXMub3B0aW9ucy5kYXNoQXJyYXkpLEwuUGF0aC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLHQpLHRoaXMuX3VzaW5nQ2FudmFzKXRoaXMub3B0aW9ucy5hbmltYXRlJiZcIm9iamVjdFwiPT10eXBlb2YgVFdFRU4/KHRoaXMuX25vcm1hbGl6ZUNhbnZhc0FuaW1hdGlvbk9wdGlvbnMoKSx0aGlzLl90d2VlbmVkT2JqZWN0PXtvZmZzZXQ6dGhpcy5fcGF0aFN2Z0VsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKX0sdGhpcy5fdHdlZW49bmV3IFRXRUVOLlR3ZWVuKHRoaXMuX3R3ZWVuZWRPYmplY3QpLnRvKHtvZmZzZXQ6MH0sdGhpcy5vcHRpb25zLmFuaW1hdGUuZHVyYXRpb24pLmRlbGF5KHRoaXMub3B0aW9ucy5hbmltYXRlLmRlbGF5KS5yZXBlYXQodGhpcy5vcHRpb25zLmFuaW1hdGUuaXRlcmF0aW9ucy0xKS5vbkNvbXBsZXRlKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3QuX2NhbnZhc0FuaW1hdGluZz0hMX19KHRoaXMpKS5zdGFydCgpLHRoaXMuX2NhbnZhc0FuaW1hdGluZz0hMCx0aGlzLl9hbmltYXRlQ2FudmFzKCkpOnRoaXMuX2NhbnZhc0FuaW1hdGluZz0hMTtlbHNlIGlmKHRoaXMub3B0aW9ucy5hbmltYXRlJiZ0aGlzLl9wYXRoLmFuaW1hdGUpe3ZhciBuPXRoaXMuX3N2Z1NldERhc2hBcnJheSgpO3RoaXMuX3BhdGguYW5pbWF0ZShbe3N0cm9rZURhc2hvZmZzZXQ6bn0se3N0cm9rZURhc2hvZmZzZXQ6MH1dLHRoaXMub3B0aW9ucy5hbmltYXRlKX19LF91cGRhdGVDdXJ2ZVN2ZzpmdW5jdGlvbigpe3RoaXMuX3JlbmRlcmVyLl9zZXRQYXRoKHRoaXMsdGhpcy5fY3VydmVQb2ludHNUb1BhdGgodGhpcy5fcG9pbnRzKSksdGhpcy5vcHRpb25zLmFuaW1hdGUmJnRoaXMuX3N2Z1NldERhc2hBcnJheSgpfSxfc3ZnU2V0RGFzaEFycmF5OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcGF0aCxuPXQuZ2V0VG90YWxMZW5ndGgoKTtyZXR1cm4gdGhpcy5vcHRpb25zLmRhc2hBcnJheXx8KHQuc3R5bGUuc3Ryb2tlRGFzaGFycmF5PW4rXCIgXCIrbiksbn0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLl9ib3VuZHMuaXNWYWxpZCgpJiZ0aGlzLl9ib3VuZHMuY29udGFpbnModGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0KSl9LF9ub3JtYWxpemVDYW52YXNBbmltYXRpb25PcHRpb25zOmZ1bmN0aW9uKCl7dmFyIHQ9e2RlbGF5OjAsZHVyYXRpb246MCxpdGVyYXRpb25zOjF9O1wibnVtYmVyXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuYW5pbWF0ZT90LmR1cmF0aW9uPXRoaXMub3B0aW9ucy5hbmltYXRlOih0aGlzLm9wdGlvbnMuYW5pbWF0ZS5kdXJhdGlvbiYmKHQuZHVyYXRpb249dGhpcy5vcHRpb25zLmFuaW1hdGUuZHVyYXRpb24pLHRoaXMub3B0aW9ucy5hbmltYXRlLmRlbGF5JiYodC5kZWxheT10aGlzLm9wdGlvbnMuYW5pbWF0ZS5kZWxheSksdGhpcy5vcHRpb25zLmFuaW1hdGUuaXRlcmF0aW9ucyYmKHQuaXRlcmF0aW9ucz10aGlzLm9wdGlvbnMuYW5pbWF0ZS5pdGVyYXRpb25zKSksdGhpcy5vcHRpb25zLmFuaW1hdGU9dH0sX3VwZGF0ZUN1cnZlQ2FudmFzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY3VydmVQb2ludHNUb1BhdGgodGhpcy5fcG9pbnRzKTt0aGlzLl9wYXRoU3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkXCIsdCksdGhpcy5vcHRpb25zLmFuaW1hdGUmJlwib2JqZWN0XCI9PXR5cGVvZiBUV0VFTiYmdGhpcy5fY2FudmFzU2V0RGFzaEFycmF5JiYodGhpcy5vcHRpb25zLmRhc2hBcnJheT10aGlzLl9wYXRoU3ZnRWxlbWVudC5nZXRUb3RhbExlbmd0aCgpK1wiXCIsdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZURhc2hBcnJheSh0aGlzKSksdGhpcy5fY3VydmVGaWxsU3Ryb2tlKG5ldyBQYXRoMkQodCksdGhpcy5fcmVuZGVyZXIuX2N0eCl9LF9hbmltYXRlQ2FudmFzOmZ1bmN0aW9uKCl7VFdFRU4udXBkYXRlKCksdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGhzKCksdGhpcy5fY2FudmFzQW5pbWF0aW5nJiYodGhpcy5fYW5pbWF0aW9uRnJhbWVJZD1MLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlQ2FudmFzLHRoaXMpKX0sX2N1cnZlRmlsbFN0cm9rZTpmdW5jdGlvbih0LG4pe24ubGluZURhc2hPZmZzZXQ9dGhpcy5fY2FudmFzQW5pbWF0aW5nP3RoaXMuX3R3ZWVuZWRPYmplY3Qub2Zmc2V0OjA7dmFyIGU9dGhpcy5vcHRpb25zO2UuZmlsbCYmKG4uZ2xvYmFsQWxwaGE9ZS5maWxsT3BhY2l0eSxuLmZpbGxTdHlsZT1lLmZpbGxDb2xvcnx8ZS5jb2xvcixuLmZpbGwodCxlLmZpbGxSdWxlfHxcImV2ZW5vZGRcIikpLGUuc3Ryb2tlJiYwIT09ZS53ZWlnaHQmJihuLnNldExpbmVEYXNoJiZuLnNldExpbmVEYXNoKHRoaXMub3B0aW9ucyYmdGhpcy5vcHRpb25zLl9kYXNoQXJyYXl8fFtdKSxuLmdsb2JhbEFscGhhPWUub3BhY2l0eSxuLmxpbmVXaWR0aD1lLndlaWdodCxuLnN0cm9rZVN0eWxlPWUuY29sb3Isbi5saW5lQ2FwPWUubGluZUNhcCxuLmxpbmVKb2luPWUubGluZUpvaW4sbi5zdHJva2UodCkpfSx0cmFjZTpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10aGlzLl9tYXB8fG51bGw9PT10aGlzLl9tYXApcmV0dXJuW107dmFyIG4sZSxpLGEscyxvLHI7dD10LmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdD49MCYmdDw9MX0pO2Zvcih2YXIgaD1bXSxjPTA7Yzx0aGlzLl9wb2ludHMubGVuZ3RoO2MrKylpZihcInN0cmluZ1wiPT10eXBlb2Yobj10aGlzLl9wb2ludHNbY10pfHxuIGluc3RhbmNlb2YgU3RyaW5nKVwiWlwiPT0oZT1uKSYmKGg9aC5jb25jYXQodGhpcy5fbGluZWFyVHJhY2UodCxhLGkpKSk7ZWxzZSBzd2l0Y2goZSl7Y2FzZVwiTVwiOmk9bixhPW47YnJlYWs7Y2FzZVwiTFwiOmNhc2VcIkhcIjpjYXNlXCJWXCI6aD1oLmNvbmNhdCh0aGlzLl9saW5lYXJUcmFjZSh0LGEsbikpLGE9bjticmVhaztjYXNlXCJDXCI6cz1uLG89dGhpcy5fcG9pbnRzWysrY10scj10aGlzLl9wb2ludHNbKytjXSxoPWguY29uY2F0KHRoaXMuX2N1YmljVHJhY2UodCxhLHMsbyxyKSksYT1yO2JyZWFrO2Nhc2VcIlNcIjpzPXRoaXMuX3JlZmxlY3RQb2ludChvLGEpLG89bixyPXRoaXMuX3BvaW50c1srK2NdLGg9aC5jb25jYXQodGhpcy5fY3ViaWNUcmFjZSh0LGEscyxvLHIpKSxhPXI7YnJlYWs7Y2FzZVwiUVwiOnM9bixvPXRoaXMuX3BvaW50c1srK2NdLGg9aC5jb25jYXQodGhpcy5fcXVhZHJhdGljVHJhY2UodCxhLHMsbykpLGE9bzticmVhaztjYXNlXCJUXCI6cz10aGlzLl9yZWZsZWN0UG9pbnQocyxhKSxvPW4saD1oLmNvbmNhdCh0aGlzLl9xdWFkcmF0aWNUcmFjZSh0LGEscyxvKSksYT1vfXJldHVybiBofSxfbGluZWFyVHJhY2U6ZnVuY3Rpb24odCxuLGUpe3JldHVybiB0Lm1hcCh0PT57dmFyIGk9dGhpcy5fc2luZ2xlTGluZWFyVHJhY2UodCxuLngsZS54KSxhPXRoaXMuX3NpbmdsZUxpbmVhclRyYWNlKHQsbi55LGUueSk7cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW2ksYV0pfSl9LF9xdWFkcmF0aWNUcmFjZTpmdW5jdGlvbih0LG4sZSxpKXtyZXR1cm4gdC5tYXAodD0+e3ZhciBhPXRoaXMuX3NpbmdsZVF1YWRyYXRpY1RyYWNlKHQsbi54LGUueCxpLngpLHM9dGhpcy5fc2luZ2xlUXVhZHJhdGljVHJhY2UodCxuLnksZS55LGkueSk7cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW2Esc10pfSl9LF9jdWJpY1RyYWNlOmZ1bmN0aW9uKHQsbixlLGksYSl7cmV0dXJuIHQubWFwKHQ9Pnt2YXIgcz10aGlzLl9zaW5nbGVDdWJpY1RyYWNlKHQsbi54LGUueCxpLngsYS54KSxvPXRoaXMuX3NpbmdsZUN1YmljVHJhY2UodCxuLnksZS55LGkueSxhLnkpO3JldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtzLG9dKX0pfSxfc2luZ2xlTGluZWFyVHJhY2U6ZnVuY3Rpb24odCxuLGUpe3JldHVybiBuK3QqKGUtbil9LF9zaW5nbGVRdWFkcmF0aWNUcmFjZTpmdW5jdGlvbih0LG4sZSxpKXt2YXIgYT0xLXQ7cmV0dXJuIE1hdGgucG93KGEsMikqbisyKmEqdCplK01hdGgucG93KHQsMikqaX0sX3NpbmdsZUN1YmljVHJhY2U6ZnVuY3Rpb24odCxuLGUsaSxhKXt2YXIgcz0xLXQ7cmV0dXJuIE1hdGgucG93KHMsMykqbiszKk1hdGgucG93KHMsMikqdCplKzMqcypNYXRoLnBvdyh0LDIpKmkrTWF0aC5wb3codCwzKSphfSxfcmVmbGVjdFBvaW50OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHg9bi54KyhuLngtdC54KSx5PW4ueSsobi55LXQueSksTC5wb2ludCh4LHkpfX0pLEwuY3VydmU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IEwuQ3VydmUodCxuKX19XSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@elfalem/leaflet-curve/dist/leaflet.curve.js\n");

/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Easing\": () => (/* binding */ Easing),\n/* harmony export */   \"Group\": () => (/* binding */ Group),\n/* harmony export */   \"Interpolation\": () => (/* binding */ Interpolation),\n/* harmony export */   \"Sequence\": () => (/* binding */ Sequence),\n/* harmony export */   \"Tween\": () => (/* binding */ Tween),\n/* harmony export */   \"VERSION\": () => (/* binding */ VERSION),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"getAll\": () => (/* binding */ getAll),\n/* harmony export */   \"nextId\": () => (/* binding */ nextId),\n/* harmony export */   \"now\": () => (/* binding */ now$1),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"removeAll\": () => (/* binding */ removeAll),\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = {\n    Linear: {\n        None: function (amount) {\n            return amount;\n        },\n    },\n    Quadratic: {\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    },\n    Cubic: {\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    },\n    Quartic: {\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    },\n    Quintic: {\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    },\n    Sinusoidal: {\n        In: function (amount) {\n            return 1 - Math.cos((amount * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.cos(Math.PI * amount));\n        },\n    },\n    Exponential: {\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    },\n    Circular: {\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    },\n    Elastic: {\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    },\n    Back: {\n        In: function (amount) {\n            var s = 1.70158;\n            return amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    },\n    Bounce: {\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    },\n};\n\nvar now;\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n    now = function () {\n        // eslint-disable-next-line\n        // @ts-ignore\n        var time = process.hrtime();\n        // Convert [seconds, nanoseconds] to milliseconds.\n        return time[0] * 1000 + time[1] / 1000000;\n    };\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n    // This must be bound, because directly assigning this function\n    // leads to an invocation exception in Chrome.\n    now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n    now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n    now = function () {\n        return new Date().getTime();\n    };\n}\nvar now$1 = now;\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now$1(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.to = function (properties, duration) {\n        // TODO? restore this, then update the 07_dynamic_to example to set fox\n        // tween's to on each update. That way the behavior is opt-in (there's\n        // currently no opt-out).\n        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]\n        this._valuesEnd = Object.create(properties);\n        if (duration !== undefined) {\n            this._duration = duration;\n        }\n        return this;\n    };\n    Tween.prototype.duration = function (d) {\n        this._duration = d;\n        return this;\n    };\n    Tween.prototype.start = function (time) {\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();\n        this._startTime += this._delayTime;\n        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);\n        return this;\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // handle an array of relative values\n                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));\n                // Create a local copy of the Array with the start value at the front\n                _valuesEnd[property] = [startValue].concat(endValues);\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                // eslint-disable-next-line\n                for (var prop in startValue) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property][prop] = startValue[prop];\n                }\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);\n            }\n            else {\n                // Save the starting value, but only once.\n                if (typeof _valuesStart[property] === 'undefined') {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        if (time === void 0) { time = now$1(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var elapsed;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        elapsed = (time - this._startTime) / this._duration;\n        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat)) {\n                    this._repeat--;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                if (this._repeatDelayTime !== undefined) {\n                    this._startTime = time + this._repeatDelayTime;\n                }\n                else {\n                    this._startTime = time + this._delayTime;\n                }\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        else {\n            return parseFloat(end);\n        }\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '18.6.4';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now$1,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxvQkFBb0IsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8sRUFBQztBQUN5RyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHdlZW5qcy90d2Vlbi5qcy9kaXN0L3R3ZWVuLmVzbS5qcz9iNjA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIEVhc2UgY2xhc3MgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIHR3ZWVuLmpzLlxuICovXG52YXIgRWFzaW5nID0ge1xuICAgIExpbmVhcjoge1xuICAgICAgICBOb25lOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVhZHJhdGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiAoMiAtIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1hbW91bnQgKiAoYW1vdW50IC0gMikgLSAxKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEN1YmljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICsgMik7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBRdWFydGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAtIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVpbnRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgU2ludXNvaWRhbDoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oKGFtb3VudCAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogYW1vdW50KSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBFeHBvbmVudGlhbDoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGFtb3VudCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgQ2lyY3VsYXI6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBhbW91bnQgKiBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChhbW91bnQgLT0gMikgKiBhbW91bnQpICsgMSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBFbGFzdGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLU1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBhbW91bnQpICogTWF0aC5zaW4oKGFtb3VudCAtIDAuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW1vdW50ICo9IDI7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogTWF0aC5wb3coMiwgMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEJhY2s6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgKyBzKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgQm91bmNlOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2UuT3V0KDEgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDEuNSAvIDIuNzUpICogYW1vdW50ICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFtb3VudCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjYyNSAvIDIuNzUpICogYW1vdW50ICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuSW4oYW1vdW50ICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRWFzaW5nLkJvdW5jZS5PdXQoYW1vdW50ICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG52YXIgbm93O1xuLy8gSW5jbHVkZSBhIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbC5cbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgLy8gQ29udmVydCBbc2Vjb25kcywgbmFub3NlY29uZHNdIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgcmV0dXJuIHRpbWVbMF0gKiAxMDAwICsgdGltZVsxXSAvIDEwMDAwMDA7XG4gICAgfTtcbn1cbi8vIEluIGEgYnJvd3NlciwgdXNlIHNlbGYucGVyZm9ybWFuY2Uubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRoaXMgbXVzdCBiZSBib3VuZCwgYmVjYXVzZSBkaXJlY3RseSBhc3NpZ25pbmcgdGhpcyBmdW5jdGlvblxuICAgIC8vIGxlYWRzIHRvIGFuIGludm9jYXRpb24gZXhjZXB0aW9uIGluIENocm9tZS5cbiAgICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufVxuLy8gVXNlIERhdGUubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKERhdGUubm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBub3cgPSBEYXRlLm5vdztcbn1cbi8vIE90aGVyd2lzZSwgdXNlICduZXcgRGF0ZSgpLmdldFRpbWUoKScuXG5lbHNlIHtcbiAgICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufVxudmFyIG5vdyQxID0gbm93O1xuXG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlblxuICovXG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSA9IHt9O1xuICAgIH1cbiAgICBHcm91cC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKS5tYXAoZnVuY3Rpb24gKHR3ZWVuSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdHdlZW5zW3R3ZWVuSWRdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbi5nZXRJZCgpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZSA9PT0gdm9pZCAwKSB7IHByZXNlcnZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3ZWVucyBhcmUgdXBkYXRlZCBpbiBcImJhdGNoZXNcIi4gSWYgeW91IGFkZCBhIG5ldyB0d2VlbiBkdXJpbmcgYW5cbiAgICAgICAgLy8gdXBkYXRlLCB0aGVuIHRoZSBuZXcgdHdlZW4gd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IGJhdGNoLlxuICAgICAgICAvLyBJZiB5b3UgcmVtb3ZlIGEgdHdlZW4gZHVyaW5nIGFuIHVwZGF0ZSwgaXQgbWF5IG9yIG1heSBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlIHJlbW92ZWQgdHdlZW4gd2FzIGFkZGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCxcbiAgICAgICAgLy8gdGhlbiBpdCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgICAgICB3aGlsZSAodHdlZW5JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIHZhciBhdXRvU3RhcnQgPSAhcHJlc2VydmU7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuICYmIHR3ZWVuLnVwZGF0ZSh0aW1lLCBhdXRvU3RhcnQpID09PSBmYWxzZSAmJiAhcHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHdlZW5JZHMgPSBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXA7XG59KCkpO1xuXG4vKipcbiAqXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uID0ge1xuICAgIExpbmVhcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5MaW5lYXI7XG4gICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xuICAgIH0sXG4gICAgQmV6aWVyOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcHcgPSBNYXRoLnBvdztcbiAgICAgICAgdmFyIGJuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgYiArPSBwdygxIC0gaywgbiAtIGkpICogcHcoaywgaSkgKiB2W2ldICogYm4obiwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGYgPSBtICogaztcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG4gICAgICAgIGlmICh2WzBdID09PSB2W21dKSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoZiA9IG0gKiAoMSArIGspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2WzBdIC0gKGZuKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoZm4odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbih2W2kgPyBpIC0gMSA6IDBdLCB2W2ldLCB2W20gPCBpICsgMSA/IG0gOiBpICsgMV0sIHZbbSA8IGkgKyAyID8gbSA6IGkgKyAyXSwgZiAtIGkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBVdGlsczoge1xuICAgICAgICBMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIH0sXG4gICAgICAgIEJlcm5zdGVpbjogZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBmYyA9IEludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuICAgICAgICAgICAgcmV0dXJuIGZjKG4pIC8gZmMoaSkgLyBmYyhuIC0gaSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZhY3RvcmlhbDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChhW25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDE7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBzICo9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFbbl0gPSBzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIHZhciB0MyA9IHQgKiB0MjtcbiAgICAgICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgU2VxdWVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2UoKSB7XG4gICAgfVxuICAgIFNlcXVlbmNlLm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNlcXVlbmNlLl9uZXh0SWQrKztcbiAgICB9O1xuICAgIFNlcXVlbmNlLl9uZXh0SWQgPSAwO1xuICAgIHJldHVybiBTZXF1ZW5jZTtcbn0oKSk7XG5cbnZhciBtYWluR3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xudmFyIFR3ZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR3ZWVuKF9vYmplY3QsIF9ncm91cCkge1xuICAgICAgICBpZiAoX2dyb3VwID09PSB2b2lkIDApIHsgX2dyb3VwID0gbWFpbkdyb3VwOyB9XG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gX2dyb3VwO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0ID0ge307XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgdGhpcy5faW5pdGlhbFJlcGVhdCA9IDA7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IDA7XG4gICAgICAgIHRoaXMuX3lveW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gRWFzaW5nLkxpbmVhci5Ob25lO1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBJbnRlcnBvbGF0aW9uLkxpbmVhcjtcbiAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IFNlcXVlbmNlLm5leHRJZCgpO1xuICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIFR3ZWVuLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE8/IHJlc3RvcmUgdGhpcywgdGhlbiB1cGRhdGUgdGhlIDA3X2R5bmFtaWNfdG8gZXhhbXBsZSB0byBzZXQgZm94XG4gICAgICAgIC8vIHR3ZWVuJ3MgdG8gb24gZWFjaCB1cGRhdGUuIFRoYXQgd2F5IHRoZSBiZWhhdmlvciBpcyBvcHQtaW4gKHRoZXJlJ3NcbiAgICAgICAgLy8gY3VycmVudGx5IG5vIG9wdC1vdXQpLlxuICAgICAgICAvLyBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykgdGhpcy5fdmFsdWVzRW5kW3Byb3BdID0gcHJvcGVydGllc1twcm9wXVxuICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMpO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9pbml0aWFsUmVwZWF0O1xuICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgcmV2ZXJzZWQgKGYuZS4gdXNpbmcgdGhlIHlveW8gZmVhdHVyZSkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSB0d2VlbiBkaXJlY3Rpb24gYmFjayB0byBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJyA/IG5vdyQxKCkgKyBwYXJzZUZsb2F0KHRpbWUpIDogdGltZSkgOiBub3ckMSgpO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9zZXR1cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCBfdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBfb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgcHJvcFR5cGUgPSBzdGFydFZhbHVlSXNBcnJheSA/ICdhcnJheScgOiB0eXBlb2Ygc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0VmFsdWVJc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgLy8gSWYgYHRvKClgIHNwZWNpZmllcyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3Qgc2V0IHRoYXQgcHJvcGVydHkgaW4gdGhlIG9iamVjdFxuICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRWYWx1ZXMgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGFuIGFycmF5IG9mIHJlbGF0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGVuZFZhbHVlcyA9IGVuZFZhbHVlcy5tYXAodGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZS5iaW5kKHRoaXMsIHN0YXJ0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcbiAgICAgICAgICAgICAgICBfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IFtzdGFydFZhbHVlXS5jb25jYXQoZW5kVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgZGVlcG5lc3Mgb2YgdGhlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKChwcm9wVHlwZSA9PT0gJ29iamVjdCcgfHwgc3RhcnRWYWx1ZUlzQXJyYXkpICYmIHN0YXJ0VmFsdWUgJiYgIWlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XVtwcm9wXSA9IHN0YXJ0VmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307IC8vIFRPRE8/IHJlcGVhdCBuZXN0ZWQgdmFsdWVzPyBBbmQgeW95bz8gQW5kIGFycmF5IHZhbHVlcz9cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwUHJvcGVydGllcyhzdGFydFZhbHVlLCBfdmFsdWVzU3RhcnRbcHJvcGVydHldLCBfdmFsdWVzRW5kW3Byb3BlcnR5XSwgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBzdGFydGluZyB2YWx1ZSwgYnV0IG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNFbmRbcHJvcGVydHldLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhaW5TdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fb25TdG9wQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoSW5maW5pdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IHRpbWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGltZSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IGFtb3VudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSB0aW1lcztcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGltZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9yZXBlYXREZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnlveW8gPSBmdW5jdGlvbiAoeW95bykge1xuICAgICAgICB0aGlzLl95b3lvID0geW95bztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZWFzaW5nID0gZnVuY3Rpb24gKGVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSB0d2VlbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25SZXBlYXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25SZXBlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0d2VlbiBpcyBzdGlsbCBwbGF5aW5nIGFmdGVyIHRoZSB1cGRhdGUsIGZhbHNlXG4gICAgICogb3RoZXJ3aXNlIChjYWxsaW5nIHVwZGF0ZSBvbiBhIHBhdXNlZCB0d2VlbiBzdGlsbCByZXR1cm5zIHRydWUgYmVjYXVzZVxuICAgICAqIGl0IGlzIHN0aWxsIHBsYXlpbmcsIGp1c3QgcGF1c2VkKS5cbiAgICAgKi9cbiAgICBUd2Vlbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRpbWUsIGF1dG9TdGFydCkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmIChhdXRvU3RhcnQgPT09IHZvaWQgMCkgeyBhdXRvU3RhcnQgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgcHJvcGVydHk7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuX2dvVG9FbmQgJiYgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBlbmRUaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRvU3RhcnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBlbGFwc2VkID0gdGhpcy5fZHVyYXRpb24gPT09IDAgfHwgZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZWFzaW5nRnVuY3Rpb24oZWxhcHNlZCk7XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCwgZWxhcHNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsYXBzZWQgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHRoaXMuX3JlcGVhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHN0YXJ0aW5nIHZhbHVlcywgcmVzdGFydCBieSBtYWtpbmcgc3RhcnRUaW1lID0gbm93XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3lveW8gJiYgdHlwZW9mIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gIXRoaXMuX3JldmVyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSArIHRoaXMuX3JlcGVhdERlbGF5VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9kZWxheVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoYWluZWQgdHdlZW5zIHN0YXJ0IGV4YWN0bHkgYXQgdGhlIHRpbWUgdGhleSBzaG91bGQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIGB1cGRhdGUoKWAgbWV0aG9kIHdhcyBjYWxsZWQgd2F5IHBhc3QgdGhlIGR1cmF0aW9uIG9mIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0YXJ0KHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl91cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgdmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByb3BlcnRpZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgIHZhciBlbmQgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydElzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9vYmplY3RbcHJvcGVydHldKTtcbiAgICAgICAgICAgIHZhciBlbmRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xuICAgICAgICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvbkxpc3QgPSAhc3RhcnRJc0FycmF5ICYmIGVuZElzQXJyYXk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGVuZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ29iamVjdCcgJiYgZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKF9vYmplY3RbcHJvcGVydHldLCBzdGFydCwgZW5kLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX2hhbmRsZVJlbGF0aXZlVmFsdWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIHBhcnNlRmxvYXQoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgIGlmICh0eXBlb2YgZW5kVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gKyBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRtcDtcbiAgICB9O1xuICAgIHJldHVybiBUd2Vlbjtcbn0oKSk7XG5cbnZhciBWRVJTSU9OID0gJzE4LjYuNCc7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBuZXh0SWQgPSBTZXF1ZW5jZS5uZXh0SWQ7XG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlbnMuXG4gKi9cbnZhciBUV0VFTiA9IG1haW5Hcm91cDtcbi8vIFRoaXMgaXMgdGhlIGJlc3Qgd2F5IHRvIGV4cG9ydCB0aGluZ3MgaW4gYSB3YXkgdGhhdCdzIGNvbXBhdGlibGUgd2l0aCBib3RoIEVTXG4vLyBNb2R1bGVzIGFuZCBDb21tb25KUywgd2l0aG91dCBidWlsZCBoYWNrcywgYW5kIHNvIGFzIG5vdCB0byBicmVhayB0aGVcbi8vIGV4aXN0aW5nIEFQSS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xOTYxI2lzc3VlY29tbWVudC00MjMwMzc4ODFcbnZhciBnZXRBbGwgPSBUV0VFTi5nZXRBbGwuYmluZChUV0VFTik7XG52YXIgcmVtb3ZlQWxsID0gVFdFRU4ucmVtb3ZlQWxsLmJpbmQoVFdFRU4pO1xudmFyIGFkZCA9IFRXRUVOLmFkZC5iaW5kKFRXRUVOKTtcbnZhciByZW1vdmUgPSBUV0VFTi5yZW1vdmUuYmluZChUV0VFTik7XG52YXIgdXBkYXRlID0gVFdFRU4udXBkYXRlLmJpbmQoVFdFRU4pO1xudmFyIGV4cG9ydHMgPSB7XG4gICAgRWFzaW5nOiBFYXNpbmcsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEludGVycG9sYXRpb246IEludGVycG9sYXRpb24sXG4gICAgbm93OiBub3ckMSxcbiAgICBTZXF1ZW5jZTogU2VxdWVuY2UsXG4gICAgbmV4dElkOiBuZXh0SWQsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgZ2V0QWxsOiBnZXRBbGwsXG4gICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXG4gICAgYWRkOiBhZGQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHBvcnRzO1xuZXhwb3J0IHsgRWFzaW5nLCBHcm91cCwgSW50ZXJwb2xhdGlvbiwgU2VxdWVuY2UsIFR3ZWVuLCBWRVJTSU9OLCBhZGQsIGdldEFsbCwgbmV4dElkLCBub3ckMSBhcyBub3csIHJlbW92ZSwgcmVtb3ZlQWxsLCB1cGRhdGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tweenjs/tween.js/dist/tween.esm.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=script&lang=js":
/*!*****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var _elfalem_leaflet_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @elfalem/leaflet-curve */ \"./node_modules/@elfalem/leaflet-curve/dist/leaflet.curve.js\");\n/* harmony import */ var _elfalem_leaflet_curve__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_elfalem_leaflet_curve__WEBPACK_IMPORTED_MODULE_3__);\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'vue-select-3/dist/vue-select.css'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: \"Map\",\n  data: function data() {\n    return {\n      map: null\n    };\n  },\n  mounted: function mounted() {\n    this.map = leaflet__WEBPACK_IMPORTED_MODULE_1___default().map(\"mapContainer\").setView([39.449269626, 67.237035371], 7);\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default().tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n      attribution: '<a target=\"_blank\" href=\"http://www.agro.uz\"> www.agro.uz &copy; AgroDigital</a>'\n    }).addTo(this.map); //use a mix of renderers\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvTW9kdWxlcy9NYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxpRUFBZTtBQUNYQyxNQUFJLEVBQUUsS0FESztBQUVYQyxNQUZXLGtCQUVKO0FBQ0gsV0FBTztBQUNIQyxTQUFHLEVBQUU7QUFERixLQUFQO0FBR0gsR0FOVTtBQVFYQyxTQVJXLHFCQVFEO0FBQ04sU0FBS0QsR0FBTCxHQUFXSCxrREFBQSxDQUFNLGNBQU4sRUFBc0JLLE9BQXRCLENBQStCLENBQUMsWUFBRCxFQUFlLFlBQWYsQ0FBL0IsRUFBNkQsQ0FBN0QsQ0FBWDtBQUNBTCxJQUFBQSx3REFBQSxDQUFZLG9EQUFaLEVBQWtFO0FBQzlETyxpQkFBVyxFQUNQO0FBRjBELEtBQWxFLEVBR0dDLEtBSEgsQ0FHUyxLQUFLTCxHQUhkLEVBRk0sQ0FNTjtBQUNKO0FBZlcsQ0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL01vZHVsZXMvTWFwLnZ1ZT84YTAyIl0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmctd2hpdGVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWQgc2VjdGlvbi0yXCI+XG4gICAgICAgICAgICAgICAgPGgxPk9jaGlxIHhhcml0YTwvaDE+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLW1lbnVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInRhYi1idG4gYWN0aXZlXCI+VW11bWl5IHhhcml0YTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwidGFiLWJ0blwiPlllciB1Y2hhc3RrYWxhcmk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgPHYtc2VsZWN0IDpvcHRpb25zPVwiWydDYW5hZGEnLCAnVW5pdGVkIFN0YXRlcyddXCI+PC92LXNlbGVjdD5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkIG10LTQgc2VjdGlvbi0yXCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwibWFwQ29udGFpbmVyXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFwibGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzXCI7XG5pbXBvcnQgTCBmcm9tIFwibGVhZmxldFwiO1xuaW1wb3J0IFwiQHR3ZWVuanMvdHdlZW4uanNcIjtcbmltcG9ydCBcIkBlbGZhbGVtL2xlYWZsZXQtY3VydmVcIjtcbmltcG9ydCBcInZ1ZS1zZWxlY3QtMy9kaXN0L3Z1ZS1zZWxlY3QuY3NzXCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbmFtZTogXCJNYXBcIixcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLm1hcCA9IEwubWFwKFwibWFwQ29udGFpbmVyXCIpLnNldFZpZXcoIFszOS40NDkyNjk2MjYsIDY3LjIzNzAzNTM3MV0sIDcpO1xuICAgICAgICBMLnRpbGVMYXllcihcImh0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nXCIsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOlxuICAgICAgICAgICAgICAgICc8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cDovL3d3dy5hZ3JvLnV6XCI+IHd3dy5hZ3JvLnV6ICZjb3B5OyBBZ3JvRGlnaXRhbDwvYT4nLFxuICAgICAgICB9KS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgIC8vdXNlIGEgbWl4IG9mIHJlbmRlcmVyc1xuICAgIH1cblxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblxuXG5cbjwvc3R5bGU+XG4iXSwibmFtZXMiOlsiTCIsIm5hbWUiLCJkYXRhIiwibWFwIiwibW91bnRlZCIsInNldFZpZXciLCJ0aWxlTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsImFkZFRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799":
/*!*********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799 ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n\nvar _hoisted_1 = {\n  \"class\": \"bg-white\"\n};\nvar _hoisted_2 = {\n  \"class\": \"container-fluid section-2\"\n};\n\nvar _hoisted_3 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"h1\", null, \"Ochiq xarita\", -1\n/* HOISTED */\n);\n\nvar _hoisted_4 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  \"class\": \"tab-menu\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\", {\n  \"class\": \"tab-btn active\"\n}, \"Umumiy xarita\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\", {\n  \"class\": \"tab-btn\"\n}, \"Yer uchastkalari\")], -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = {\n  \"class\": \"d-flex\"\n};\n\nvar _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  \"class\": \"container-fluid mt-4 section-2\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  id: \"mapContainer\"\n})], -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_select = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"v-select\");\n\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_2, [_hoisted_3, _hoisted_4, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_v_select, {\n    options: ['Canada', 'United States']\n  })])])]), _hoisted_6]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL01vZHVsZXMvTWFwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zZjMzMTc5OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRWEsV0FBTTs7O0FBQ0YsV0FBTTs7OzhCQUNQQSx1REFBQUEsQ0FBcUIsSUFBckIsRUFBcUIsSUFBckIsRUFBSSxjQUFKLEVBQWdCO0FBQUE7QUFBaEI7OzhCQUVBQSx1REFBQUEsQ0FHTSxLQUhOLEVBR007QUFIRCxXQUFNO0FBR0wsQ0FITixFQUFxQixjQUNqQkEsdURBQUFBLENBQXFELFFBQXJELEVBQXFEO0FBQTdDLFdBQU07QUFBdUMsQ0FBckQsRUFBK0IsZUFBL0IsQ0FEaUIsZUFFakJBLHVEQUFBQSxDQUFpRCxRQUFqRCxFQUFpRDtBQUF6QyxXQUFNO0FBQW1DLENBQWpELEVBQXdCLGtCQUF4QixDQUZpQixDQUFyQjs7QUFBQTs7O0FBS0ssV0FBTTs7OzhCQVNuQkEsdURBQUFBLENBRU0sS0FGTixFQUVNO0FBRkQsV0FBTTtBQUVMLENBRk4sRUFBMkMsY0FDdkNBLHVEQUFBQSxDQUE2QixLQUE3QixFQUE2QjtBQUF4QkMsSUFBRSxFQUFDO0FBQXFCLENBQTdCLENBRHVDLENBQTNDOztBQUFBOzs7OzsyREFuQkpDLHVEQUFBQSxDQXVCTSxLQXZCTixFQXVCTSxJQXZCTixFQXVCTSxDQXRCRkYsdURBQUFBLENBZ0JNLEtBaEJOLGNBZ0JNLENBZkZBLHVEQUFBQSxDQWNNLEtBZE4sY0FjTSxDQWJGRyxVQWFFLEVBWEZDLFVBV0UsRUFORkosdURBQUFBLENBR00sS0FITixjQUdNLENBRkZLLGdEQUFBQSxDQUE0REMsbUJBQTVELEVBQTREO0FBQWpEQyxXQUFPLEVBQUU7QUFBd0MsR0FBNUQsQ0FFRSxDQUhOLENBTUUsQ0FkTixDQWVFLENBaEJOLENBc0JFLEVBSkZDLFVBSUUsQ0F2Qk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Nb2R1bGVzL01hcC52dWU/OGEwMiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJnLXdoaXRlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkIHNlY3Rpb24tMlwiPlxuICAgICAgICAgICAgICAgIDxoMT5PY2hpcSB4YXJpdGE8L2gxPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1tZW51XCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJ0YWItYnRuIGFjdGl2ZVwiPlVtdW1peSB4YXJpdGE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInRhYi1idG5cIj5ZZXIgdWNoYXN0a2FsYXJpPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgIDx2LXNlbGVjdCA6b3B0aW9ucz1cIlsnQ2FuYWRhJywgJ1VuaXRlZCBTdGF0ZXMnXVwiPjwvdi1zZWxlY3Q+XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZCBtdC00IHNlY3Rpb24tMlwiPlxuICAgICAgICAgICAgPGRpdiBpZD1cIm1hcENvbnRhaW5lclwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBcImxlYWZsZXQvZGlzdC9sZWFmbGV0LmNzc1wiO1xuaW1wb3J0IEwgZnJvbSBcImxlYWZsZXRcIjtcbmltcG9ydCBcIkB0d2VlbmpzL3R3ZWVuLmpzXCI7XG5pbXBvcnQgXCJAZWxmYWxlbS9sZWFmbGV0LWN1cnZlXCI7XG5pbXBvcnQgXCJ2dWUtc2VsZWN0LTMvZGlzdC92dWUtc2VsZWN0LmNzc1wiO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiTWFwXCIsXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBMLm1hcChcIm1hcENvbnRhaW5lclwiKS5zZXRWaWV3KCBbMzkuNDQ5MjY5NjI2LCA2Ny4yMzcwMzUzNzFdLCA3KTtcbiAgICAgICAgTC50aWxlTGF5ZXIoXCJodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZ1wiLCB7XG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjpcbiAgICAgICAgICAgICAgICAnPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHA6Ly93d3cuYWdyby51elwiPiB3d3cuYWdyby51eiAmY29weTsgQWdyb0RpZ2l0YWw8L2E+JyxcbiAgICAgICAgfSkuYWRkVG8odGhpcy5tYXApO1xuICAgICAgICAvL3VzZSBhIG1peCBvZiByZW5kZXJlcnNcbiAgICB9XG5cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5cblxuXG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJpZCIsIl9jcmVhdGVFbGVtZW50QmxvY2siLCJfaG9pc3RlZF8zIiwiX2hvaXN0ZWRfNCIsIl9jcmVhdGVWTm9kZSIsIl9jb21wb25lbnRfdl9zZWxlY3QiLCJvcHRpb25zIiwiX2hvaXN0ZWRfNiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/leaflet/dist/leaflet.css":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/leaflet/dist/leaflet.css ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _images_layers_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./images/layers.png */ \"./node_modules/leaflet/dist/images/layers.png\");\n/* harmony import */ var _images_layers_2x_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./images/layers-2x.png */ \"./node_modules/leaflet/dist/images/layers-2x.png\");\n/* harmony import */ var _images_marker_icon_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./images/marker-icon.png */ \"./node_modules/leaflet/dist/images/marker-icon.png\");\n// Imports\n\n\n\n\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_images_layers_png__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_images_layers_2x_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        -ms-user-select: none;\\r\\n\\t    user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::-moz-selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\\"stretching\\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\twidth: auto;\\r\\n\\tpadding: 0;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t/* Fallback for FF which doesn't support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\tbox-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\ttransition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\ttransform-origin: 0 0;\\r\\n\\t}\\r\\nsvg.leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\ttransition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\ttransition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline-offset: 1px;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont-family: \\\"Helvetica Neue\\\", Arial, Helvetica, sans-serif;\\r\\n\\tfont-size: 12px;\\r\\n\\tfont-size: 0.75rem;\\r\\n\\tline-height: 1.5;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover,\\r\\n.leaflet-bar a:focus {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px 'Lucida Console', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\tfont-size: 13px;\\r\\n\\tfont-size: 1.08333em;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */\\r\\n\\tbackground-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.8);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover,\\r\\n.leaflet-control-attribution a:focus {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-control-attribution svg {\\r\\n\\tdisplay: inline !important;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\tbox-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 24px 13px 20px;\\r\\n\\tline-height: 1.3;\\r\\n\\tfont-size: 13px;\\r\\n\\tfont-size: 1.08333em;\\r\\n\\tmin-height: 1px;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 17px 0;\\r\\n\\tmargin: 1.3em 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-top: -1px;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\tpointer-events: auto;\\r\\n\\ttransform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 24px;\\r\\n\\theight: 24px;\\r\\n\\tfont: 16px/24px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #757575;\\r\\n\\ttext-decoration: none;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover,\\r\\n.leaflet-container a.leaflet-popup-close-button:focus {\\r\\n\\tcolor: #585858;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\t-ms-zoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\\"\\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n\\r\\n/* Printing */\\r\\n\\t\\r\\n@media print {\\r\\n\\t/* Prevent printers from removing background-images of controls. */\\r\\n\\t.leaflet-control {\\r\\n\\t\\t-webkit-print-color-adjust: exact;\\r\\n\\t\\tcolor-adjust: exact;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/leaflet/dist/leaflet.css\"],\"names\":[],\"mappings\":\"AAAA,oBAAoB;;AAEpB;;;;;;;;;;CAUC,kBAAkB;CAClB,OAAO;CACP,MAAM;CACN;AACD;CACC,gBAAgB;CAChB;AACD;;;CAGC,yBAAyB;IACtB,sBAAsB;SACjB,qBAAiB;KAAjB,iBAAiB;GACvB,uBAAuB;CACzB;AACD,kDAAkD;AAClD;CACC,uBAAuB;AACxB;AAFA;CACC,uBAAuB;AACxB;AACA,mFAAmF;AACnF;CACC,0CAA0C;CAC1C;AACD,qEAAqE;AACrE;CACC,aAAa;CACb,cAAc;CACd,6BAA6B;CAC7B;AACD;;CAEC,cAAc;CACd;AACD,gGAAgG;AAChG,qFAAqF;AACrF;CACC,0BAA0B;CAC1B,2BAA2B;CAC3B;AACD;;;;;CAKC,0BAA0B;CAC1B,2BAA2B;CAC3B,WAAW;CACX,UAAU;CACV;;AAED;CAEC,yBAAyB;CACzB;AACD;CAEC,qDAAqD;CACrD,kBAAkB;CAClB,wBAAwB;AACzB;AACA;CAEC,kBAAkB;AACnB;AACA;CACC,wCAAwC;AACzC;AACA;CACC,oDAAoD;AACrD;AACA;CACC,eAAe;CACf,kBAAkB;CAClB;AACD;CACC,mBAAmB;CACnB;AACD;CACC,QAAQ;CACR,SAAS;CAEJ,sBAAsB;CAC3B,YAAY;CACZ;AACD,uEAAuE;AACvE;CACC,sBAAsB;CACtB;;AAED,wBAAwB,YAAY,EAAE;;AAEtC,wBAAwB,YAAY,EAAE;AACtC,wBAAwB,YAAY,EAAE;AACtC,wBAAwB,YAAY,EAAE;AACtC,wBAAwB,YAAY,EAAE;AACtC,0BAA0B,YAAY,EAAE;AACxC,wBAAwB,YAAY,EAAE;;AAEtC,2BAA2B,YAAY,EAAE;AACzC,2BAA2B,YAAY,EAAE;;AAEzC;CACC,UAAU;CACV,WAAW;CACX;AACD;CACC,2BAA2B;CAC3B,qBAAqB;CACrB,kBAAkB;CAClB;;;AAGD,wBAAwB;;AAExB;CACC,kBAAkB;CAClB,YAAY;CACZ,8BAA8B,EAAE,8BAA8B;CAC9D,oBAAoB;CACpB;AACD;;CAEC,kBAAkB;CAClB,aAAa;CACb,oBAAoB;CACpB;AACD;CACC,MAAM;CACN;AACD;CACC,QAAQ;CACR;AACD;CACC,SAAS;CACT;AACD;CACC,OAAO;CACP;AACD;CACC,WAAW;CACX,WAAW;CACX;AACD;CACC,YAAY;CACZ;AACD;CACC,gBAAgB;CAChB;AACD;CACC,mBAAmB;CACnB;AACD;CACC,iBAAiB;CACjB;AACD;CACC,kBAAkB;CAClB;;;AAGD,6BAA6B;;AAE7B;CACC,UAAU;CAGF,+BAA+B;CACvC;AACD;CACC,UAAU;CACV;AACD;CAGS,qBAAqB;CAC7B;AACD;CACC,sBAAsB;AACvB;;AAEA;CAGS,4DAA4D;CACpE;AACD;;CAIS,gBAAgB;CACxB;;AAED;CACC,kBAAkB;CAClB;;;AAGD,YAAY;;AAEZ;CACC,eAAe;CACf;AACD;CACC,oBAAoB;CAEpB,oBAAoB;CACpB;AACD;;CAEC,iBAAiB;CACjB;AACD;;CAEC,YAAY;CACZ;AACD;;;CAGC,YAAY;CACZ,wBAAwB;CAExB,wBAAwB;CACxB;;AAED,oCAAoC;AACpC;;;;;CAKC,oBAAoB;CACpB;;AAED;;;;CAIC,8BAA8B,EAAE,8BAA8B;CAC9D,oBAAoB;CACpB;;AAED,kBAAkB;;AAElB;CACC,gBAAgB;CAChB,mBAAmB;CACnB;AACD;CACC,cAAc;CACd;AACD;CACC,uBAAuB;CACvB,iCAAiC;CACjC;;;AAGD,uBAAuB;AACvB;CACC,2DAA2D;CAC3D,eAAe;CACf,kBAAkB;CAClB,gBAAgB;CAChB;;;AAGD,2BAA2B;;AAE3B;CACC,sCAAsC;CACtC,kBAAkB;CAClB;AACD;CACC,sBAAsB;CACtB,6BAA6B;CAC7B,WAAW;CACX,YAAY;CACZ,iBAAiB;CACjB,cAAc;CACd,kBAAkB;CAClB,qBAAqB;CACrB,YAAY;CACZ;AACD;;CAEC,4BAA4B;CAC5B,4BAA4B;CAC5B,cAAc;CACd;AACD;;CAEC,yBAAyB;CACzB;AACD;CACC,2BAA2B;CAC3B,4BAA4B;CAC5B;AACD;CACC,8BAA8B;CAC9B,+BAA+B;CAC/B,mBAAmB;CACnB;AACD;CACC,eAAe;CACf,yBAAyB;CACzB,WAAW;CACX;;AAED;CACC,WAAW;CACX,YAAY;CACZ,iBAAiB;CACjB;AACD;CACC,2BAA2B;CAC3B,4BAA4B;CAC5B;AACD;CACC,8BAA8B;CAC9B,+BAA+B;CAC/B;;AAED,iBAAiB;;AAEjB;;CAEC,mDAAmD;CACnD,gBAAgB;CAChB;;AAED;CACC,eAAe;CACf;;;AAGD,mBAAmB;;AAEnB;CACC,qCAAqC;CACrC,gBAAgB;CAChB,kBAAkB;CAClB;AACD;CACC,yDAAwC;CACxC,WAAW;CACX,YAAY;CACZ;AACD;CACC,yDAA2C;CAC3C,0BAA0B;CAC1B;AACD;CACC,WAAW;CACX,YAAY;CACZ;AACD;;CAEC,aAAa;CACb;AACD;CACC,cAAc;CACd,kBAAkB;CAClB;AACD;CACC,yBAAyB;CACzB,WAAW;CACX,gBAAgB;CAChB;AACD;CACC,kBAAkB;CAClB,kBAAkB;CAClB,kBAAkB;CAClB;AACD;CACC,eAAe;CACf,kBAAkB;CAClB,QAAQ;CACR;AACD;CACC,cAAc;CACd,eAAe;CACf,oBAAoB;CACpB;AACD;CACC,SAAS;CACT,0BAA0B;CAC1B,0BAA0B;CAC1B;;AAED,sBAAsB;AACtB,6BAA6B,6DAA6D;CACzF,yDAA6C;CAC7C;;;AAGD,mCAAmC;;AAEnC;CACC,gBAAgB;CAChB,oCAAoC;CACpC,SAAS;CACT;AACD;;CAEC,cAAc;CACd,WAAW;CACX,gBAAgB;CAChB;AACD;CACC,qBAAqB;CACrB;AACD;;CAEC,0BAA0B;CAC1B;AACD;CACC,0BAA0B;CAC1B;AACD;CACC,gBAAgB;CAChB;AACD;CACC,kBAAkB;CAClB;AACD;CACC,sBAAsB;CACtB,gBAAgB;CAChB,gBAAgB;CAChB,oBAAoB;CACpB,mBAAmB;CACnB,gBAAgB;CAEX,sBAAsB;;CAE3B,gBAAgB;CAChB,oCAAoC;CACpC;AACD;CACC,0BAA0B;CAC1B,mBAAmB;CACnB,gBAAgB;CAChB;AACD;CACC,6BAA6B;CAC7B;;AAED;;;CAGC,gBAAgB;CAChB;AACD;;CAEC,iCAAiC;CACjC,4BAA4B;CAC5B;;;AAGD,UAAU;;AAEV;CACC,kBAAkB;CAClB,kBAAkB;CAClB,mBAAmB;CACnB;AACD;CACC,YAAY;CACZ,gBAAgB;CAChB,mBAAmB;CACnB;AACD;CACC,2BAA2B;CAC3B,gBAAgB;CAChB,eAAe;CACf,oBAAoB;CACpB,eAAe;CACf;AACD;CACC,cAAc;CACd,eAAe;CACf;AACD;CACC,WAAW;CACX,YAAY;CACZ,kBAAkB;CAClB,SAAS;CACT,gBAAgB;CAChB,kBAAkB;CAClB,gBAAgB;CAChB,oBAAoB;CACpB;AACD;CACC,WAAW;CACX,YAAY;CACZ,YAAY;;CAEZ,oBAAoB;CACpB,oBAAoB;CAKZ,wBAAwB;CAChC;AACD;;CAEC,iBAAiB;CACjB,WAAW;CACX,sCAAsC;CACtC;AACD;CACC,kBAAkB;CAClB,MAAM;CACN,QAAQ;CACR,YAAY;CACZ,kBAAkB;CAClB,WAAW;CACX,YAAY;CACZ,2CAA2C;CAC3C,cAAc;CACd,qBAAqB;CACrB,uBAAuB;CACvB;AACD;;CAEC,cAAc;CACd;AACD;CACC,cAAc;CACd,6BAA6B;CAC7B,0BAA0B;CAC1B;;AAED;CACC,WAAW;CACX;AACD;CACC,WAAW;CACX,cAAc;;CAEd,uHAAuH;CACvH,iHAAiH;CACjH;;AAED;;;;CAIC,sBAAsB;CACtB;;;AAGD,aAAa;;AAEb;CACC,gBAAgB;CAChB,sBAAsB;CACtB;;;AAGD,YAAY;AACZ,mDAAmD;AACnD;CACC,kBAAkB;CAClB,YAAY;CACZ,sBAAsB;CACtB,sBAAsB;CACtB,kBAAkB;CAClB,WAAW;CACX,mBAAmB;CACnB,yBAAyB;CACzB,sBAAsB;CACtB,qBAAqB;CACrB,iBAAiB;CACjB,oBAAoB;CACpB,qCAAqC;CACrC;AACD;CACC,eAAe;CACf,oBAAoB;CACpB;AACD;;;;CAIC,kBAAkB;CAClB,oBAAoB;CACpB,6BAA6B;CAC7B,uBAAuB;CACvB,WAAW;CACX;;AAED,eAAe;;AAEf;CACC,eAAe;AAChB;AACA;CACC,gBAAgB;AACjB;AACA;;CAEC,SAAS;CACT,iBAAiB;CACjB;AACD;CACC,SAAS;CACT,oBAAoB;CACpB,sBAAsB;CACtB;AACD;CACC,MAAM;CACN,iBAAiB;CACjB,iBAAiB;CACjB,yBAAyB;CACzB;AACD;CACC,iBAAiB;AAClB;AACA;CACC,gBAAgB;AACjB;AACA;;CAEC,QAAQ;CACR,gBAAgB;CAChB;AACD;CACC,QAAQ;CACR,mBAAmB;CACnB,uBAAuB;CACvB;AACD;CACC,OAAO;CACP,kBAAkB;CAClB,wBAAwB;CACxB;;AAED,aAAa;;AAEb;CACC,kEAAkE;CAClE;EACC,iCAAiC;EACjC,mBAAmB;EACnB;CACD\",\"sourcesContent\":[\"/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\\"stretching\\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\twidth: auto;\\r\\n\\tpadding: 0;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn't support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\nsvg.leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline-offset: 1px;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont-family: \\\"Helvetica Neue\\\", Arial, Helvetica, sans-serif;\\r\\n\\tfont-size: 12px;\\r\\n\\tfont-size: 0.75rem;\\r\\n\\tline-height: 1.5;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover,\\r\\n.leaflet-bar a:focus {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px 'Lucida Console', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(images/layers.png);\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(images/layers-2x.png);\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\tfont-size: 13px;\\r\\n\\tfont-size: 1.08333em;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */\\r\\n\\tbackground-image: url(images/marker-icon.png);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.8);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover,\\r\\n.leaflet-control-attribution a:focus {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-control-attribution svg {\\r\\n\\tdisplay: inline !important;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 24px 13px 20px;\\r\\n\\tline-height: 1.3;\\r\\n\\tfont-size: 13px;\\r\\n\\tfont-size: 1.08333em;\\r\\n\\tmin-height: 1px;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 17px 0;\\r\\n\\tmargin: 1.3em 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-top: -1px;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\tpointer-events: auto;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 24px;\\r\\n\\theight: 24px;\\r\\n\\tfont: 16px/24px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #757575;\\r\\n\\ttext-decoration: none;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover,\\r\\n.leaflet-container a.leaflet-popup-close-button:focus {\\r\\n\\tcolor: #585858;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\t-ms-zoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\\"\\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n\\r\\n/* Printing */\\r\\n\\t\\r\\n@media print {\\r\\n\\t/* Prevent printers from removing background-images of controls. */\\r\\n\\t.leaflet-control {\\r\\n\\t\\t-webkit-print-color-adjust: exact;\\r\\n\\t\\tcolor-adjust: exact;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzRHO0FBQzdCO0FBQ087QUFDdEI7QUFDRztBQUNFO0FBQ3JFLDhCQUE4QixzRUFBMkIsQ0FBQywyRkFBcUM7QUFDL0YseUNBQXlDLHlFQUErQixDQUFDLDBEQUE2QjtBQUN0Ryx5Q0FBeUMseUVBQStCLENBQUMsNkRBQTZCO0FBQ3RHLHlDQUF5Qyx5RUFBK0IsQ0FBQywrREFBNkI7QUFDdEc7QUFDQSw2U0FBNlMseUJBQXlCLGNBQWMsYUFBYSxPQUFPLHdCQUF3Qix1QkFBdUIsT0FBTyx1RUFBdUUsZ0NBQWdDLGdDQUFnQyxvQ0FBb0MsNEJBQTRCLGdDQUFnQyxPQUFPLDBGQUEwRiw4QkFBOEIsS0FBSyw4QkFBOEIsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxpUEFBaVAsaUNBQWlDLGtDQUFrQyxPQUFPLG1PQUFtTyxpQ0FBaUMsa0NBQWtDLGtCQUFrQixpQkFBaUIsT0FBTywrQ0FBK0MsZ0NBQWdDLE9BQU8sMkNBQTJDLHFGQUFxRiwrQkFBK0IsS0FBSyw4REFBOEQseUJBQXlCLEtBQUssd0JBQXdCLCtDQUErQyxLQUFLLDBCQUEwQiwyREFBMkQsS0FBSyxtQkFBbUIsc0JBQXNCLHlCQUF5QixPQUFPLDBCQUEwQiwwQkFBMEIsT0FBTyx1QkFBdUIsZUFBZSxnQkFBZ0IsNkJBQTZCLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTyxnQ0FBZ0MsZUFBZSxnQ0FBZ0MsZUFBZSw0QkFBNEIsZUFBZSw0QkFBNEIsZUFBZSw0QkFBNEIsZUFBZSw4QkFBOEIsZUFBZSw0QkFBNEIsZUFBZSxtQ0FBbUMsZUFBZSwrQkFBK0IsZUFBZSw0QkFBNEIsaUJBQWlCLGtCQUFrQixPQUFPLFdBQVcsa0NBQWtDLDRCQUE0Qix5QkFBeUIsT0FBTywrREFBK0QseUJBQXlCLG1CQUFtQixzQ0FBc0MsMERBQTBELE9BQU8sc0NBQXNDLHlCQUF5QixvQkFBb0IsMkJBQTJCLE9BQU8sa0JBQWtCLGFBQWEsT0FBTyxvQkFBb0IsZUFBZSxPQUFPLHFCQUFxQixnQkFBZ0IsT0FBTyxtQkFBbUIsY0FBYyxPQUFPLHNCQUFzQixrQkFBa0Isa0JBQWtCLE9BQU8scUNBQXFDLG1CQUFtQixPQUFPLG1DQUFtQyx1QkFBdUIsT0FBTyxzQ0FBc0MsMEJBQTBCLE9BQU8sb0NBQW9DLHdCQUF3QixPQUFPLHFDQUFxQyx5QkFBeUIsT0FBTyxxRkFBcUYsaUJBQWlCLHNDQUFzQyxPQUFPLHlEQUF5RCxpQkFBaUIsT0FBTyw0QkFBNEIsNEJBQTRCLE9BQU8sK0JBQStCLDZCQUE2QixLQUFLLG1EQUFtRCxtRUFBbUUsT0FBTywwRUFBMEUsdUJBQXVCLE9BQU8sK0NBQStDLHlCQUF5QixPQUFPLHVEQUF1RCxzQkFBc0IsT0FBTyxtQkFBbUIsMkJBQTJCLDJCQUEyQixPQUFPLG9FQUFvRSx3QkFBd0IsT0FBTyw4Q0FBOEMsbUJBQW1CLE9BQU8sOElBQThJLG1CQUFtQiwrQkFBK0IsK0JBQStCLE9BQU8sb0xBQW9MLDJCQUEyQixPQUFPLHFNQUFxTSxzQ0FBc0MsMERBQTBELE9BQU8sdURBQXVELHVCQUF1QiwwQkFBMEIsT0FBTywwQkFBMEIscUJBQXFCLE9BQU8sdUJBQXVCLDhCQUE4Qix3Q0FBd0MsT0FBTyw0REFBNEQsb0VBQW9FLHNCQUFzQix5QkFBeUIsdUJBQXVCLE9BQU8sOERBQThELDZDQUE2Qyx5QkFBeUIsT0FBTyxvQkFBb0IsNkJBQTZCLG9DQUFvQyxrQkFBa0IsbUJBQW1CLHdCQUF3QixxQkFBcUIseUJBQXlCLDRCQUE0QixtQkFBbUIsT0FBTyx1REFBdUQsbUNBQW1DLG1DQUFtQyxxQkFBcUIsT0FBTyxtREFBbUQsZ0NBQWdDLE9BQU8sZ0NBQWdDLGtDQUFrQyxtQ0FBbUMsT0FBTywrQkFBK0IscUNBQXFDLHNDQUFzQywwQkFBMEIsT0FBTyxxQ0FBcUMsc0JBQXNCLGdDQUFnQyxrQkFBa0IsT0FBTyx1Q0FBdUMsa0JBQWtCLG1CQUFtQix3QkFBd0IsT0FBTywrQ0FBK0Msa0NBQWtDLG1DQUFtQyxPQUFPLDhDQUE4QyxxQ0FBcUMsc0NBQXNDLE9BQU8sMEZBQTBGLDBEQUEwRCx1QkFBdUIsT0FBTyw0RkFBNEYsc0JBQXNCLE9BQU8saUVBQWlFLDRDQUE0Qyx1QkFBdUIseUJBQXlCLE9BQU8sb0NBQW9DLHdFQUF3RSxrQkFBa0IsbUJBQW1CLE9BQU8sb0RBQW9ELHdFQUF3RSxpQ0FBaUMsT0FBTyxtREFBbUQsa0JBQWtCLG1CQUFtQixPQUFPLDhIQUE4SCxvQkFBb0IsT0FBTyxtRUFBbUUscUJBQXFCLHlCQUF5QixPQUFPLHNDQUFzQyxnQ0FBZ0Msa0JBQWtCLHVCQUF1QixPQUFPLHVDQUF1Qyx5QkFBeUIseUJBQXlCLHlCQUF5QixPQUFPLHNDQUFzQyxzQkFBc0IseUJBQXlCLGVBQWUsT0FBTyxtQ0FBbUMscUJBQXFCLHNCQUFzQiwyQkFBMkIsT0FBTyx1Q0FBdUMsZ0JBQWdCLGlDQUFpQyxpQ0FBaUMsT0FBTyxnRUFBZ0Usc0lBQXNJLE9BQU8seUdBQXlHLHVCQUF1QiwyQ0FBMkMsZ0JBQWdCLE9BQU8sa0VBQWtFLHFCQUFxQixrQkFBa0IsdUJBQXVCLE9BQU8sb0NBQW9DLDRCQUE0QixPQUFPLG1GQUFtRixpQ0FBaUMsT0FBTyxzQ0FBc0MsaUNBQWlDLE9BQU8sMENBQTBDLHVCQUF1QixPQUFPLDRDQUE0Qyx5QkFBeUIsT0FBTyxpQ0FBaUMsNkJBQTZCLHVCQUF1Qix1QkFBdUIsMkJBQTJCLDBCQUEwQix1QkFBdUIsNkJBQTZCLDJCQUEyQiwyQ0FBMkMsT0FBTyxtREFBbUQsaUNBQWlDLDBCQUEwQix1QkFBdUIsT0FBTyxvRUFBb0Usb0NBQW9DLE9BQU8sZ0lBQWdJLHVCQUF1QixPQUFPLDRFQUE0RSx3Q0FBd0MsbUNBQW1DLE9BQU8sK0NBQStDLHlCQUF5Qix5QkFBeUIsMEJBQTBCLE9BQU8sb0NBQW9DLG1CQUFtQix1QkFBdUIsMEJBQTBCLE9BQU8sNEJBQTRCLGtDQUFrQyx1QkFBdUIsc0JBQXNCLDJCQUEyQixzQkFBc0IsT0FBTyw4QkFBOEIscUJBQXFCLHNCQUFzQixPQUFPLGtDQUFrQyxrQkFBa0IsbUJBQW1CLHlCQUF5QixnQkFBZ0IsdUJBQXVCLHlCQUF5Qix1QkFBdUIsMkJBQTJCLE9BQU8sd0JBQXdCLGtCQUFrQixtQkFBbUIsbUJBQW1CLCtCQUErQiwyQkFBMkIsK0JBQStCLE9BQU8sMkRBQTJELHdCQUF3QixrQkFBa0IsNkNBQTZDLE9BQU8scURBQXFELHlCQUF5QixhQUFhLGVBQWUsbUJBQW1CLHlCQUF5QixrQkFBa0IsbUJBQW1CLGtEQUFrRCxxQkFBcUIsNEJBQTRCLDhCQUE4QixPQUFPLHFIQUFxSCxxQkFBcUIsT0FBTyw2QkFBNkIscUJBQXFCLG9DQUFvQyxpQ0FBaUMsT0FBTyx1REFBdUQsa0JBQWtCLE9BQU8sdUNBQXVDLGtCQUFrQixxQkFBcUIsb0lBQW9JLHdIQUF3SCxPQUFPLGlMQUFpTCw2QkFBNkIsT0FBTyxxREFBcUQsdUJBQXVCLDZCQUE2QixPQUFPLHVHQUF1Ryx5QkFBeUIsbUJBQW1CLDZCQUE2Qiw2QkFBNkIseUJBQXlCLGtCQUFrQiwwQkFBMEIsZ0NBQWdDLDZCQUE2Qiw0QkFBNEIsd0JBQXdCLDJCQUEyQiw0Q0FBNEMsT0FBTywwQ0FBMEMsc0JBQXNCLDJCQUEyQixPQUFPLHVJQUF1SSx5QkFBeUIsMkJBQTJCLG9DQUFvQyw4QkFBOEIsb0JBQW9CLE9BQU8seURBQXlELHNCQUFzQixLQUFLLDBCQUEwQix1QkFBdUIsS0FBSyxvRUFBb0UsZ0JBQWdCLHdCQUF3QixPQUFPLGlDQUFpQyxnQkFBZ0IsMkJBQTJCLDZCQUE2QixPQUFPLG9DQUFvQyxhQUFhLHdCQUF3Qix3QkFBd0IsZ0NBQWdDLE9BQU8sMkJBQTJCLHdCQUF3QixLQUFLLDRCQUE0Qix1QkFBdUIsS0FBSyxvRUFBb0UsZUFBZSx1QkFBdUIsT0FBTyxrQ0FBa0MsZUFBZSwwQkFBMEIsOEJBQThCLE9BQU8sbUNBQW1DLGNBQWMseUJBQXlCLCtCQUErQixPQUFPLDhDQUE4QyxpR0FBaUcsMENBQTBDLDRCQUE0QixTQUFTLE9BQU8sV0FBVyxnSEFBZ0gsZUFBZSxZQUFZLFdBQVcsVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLE9BQU8sWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sWUFBWSxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxZQUFZLE1BQU0sWUFBWSxNQUFNLFlBQVksTUFBTSxVQUFVLFVBQVUsWUFBWSxNQUFNLE1BQU0sVUFBVSxLQUFLLFlBQVksYUFBYSxNQUFNLFlBQVksYUFBYSxNQUFNLFNBQVMsWUFBWSxhQUFhLFdBQVcsVUFBVSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxLQUFLLFlBQVksTUFBTSxZQUFZLE9BQU8sdUJBQXVCLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsd0JBQXdCLHVCQUF1Qix3QkFBd0IsTUFBTSxVQUFVLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxhQUFhLFFBQVEsYUFBYSxNQUFNLFlBQVksV0FBVyx3QkFBd0IsYUFBYSxNQUFNLE1BQU0sWUFBWSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxRQUFRLGFBQWEsTUFBTSxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksTUFBTSxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksUUFBUSxXQUFXLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBWSxhQUFhLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxVQUFVLEtBQUssT0FBTyxVQUFVLFlBQVksYUFBYSxPQUFPLFlBQVksVUFBVSxZQUFZLE9BQU8sUUFBUSx3QkFBd0IsYUFBYSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxRQUFRLFlBQVksTUFBTSxZQUFZLFdBQVcsWUFBWSxhQUFhLFFBQVEsYUFBYSxNQUFNLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFlBQVksYUFBYSxXQUFXLEtBQUssTUFBTSxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE9BQU8sYUFBYSxPQUFPLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLFlBQVksb0JBQW9CLGFBQWEsUUFBUSxhQUFhLE1BQU0sWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFVBQVUsVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksT0FBTyxPQUFPLFlBQVksTUFBTSxNQUFNLFlBQVksYUFBYSxRQUFRLFdBQVcsS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxXQUFXLFlBQVksV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsVUFBVSxXQUFXLFlBQVksYUFBYSxZQUFZLE1BQU0sTUFBTSxZQUFZLFdBQVcsWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE1BQU0sTUFBTSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxXQUFXLFlBQVksYUFBYSxPQUFPLFFBQVEsWUFBWSxRQUFRLFdBQVcsS0FBSyxZQUFZLGFBQWEsUUFBUSxVQUFVLFlBQVksTUFBTSxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxRQUFRLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxNQUFNLFdBQVcsS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLFdBQVcsS0FBSyxZQUFZLE1BQU0sWUFBWSxhQUFhLE1BQU0sNFJBQTRSLHlCQUF5QixjQUFjLGFBQWEsT0FBTyx3QkFBd0IsdUJBQXVCLE9BQU8sdUVBQXVFLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxPQUFPLHFGQUFxRiw4QkFBOEIsS0FBSywySEFBMkgsaURBQWlELE9BQU8seUhBQXlILG9CQUFvQixxQkFBcUIsb0NBQW9DLE9BQU8scURBQXFELHFCQUFxQixPQUFPLGlQQUFpUCxpQ0FBaUMsa0NBQWtDLE9BQU8sbU9BQW1PLGlDQUFpQyxrQ0FBa0Msa0JBQWtCLGlCQUFpQixPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTyxnQ0FBZ0MsZUFBZSxnQ0FBZ0MsZUFBZSw0QkFBNEIsZUFBZSw0QkFBNEIsZUFBZSw0QkFBNEIsZUFBZSw4QkFBOEIsZUFBZSw0QkFBNEIsZUFBZSxtQ0FBbUMsZUFBZSwrQkFBK0IsZUFBZSw0QkFBNEIsaUJBQWlCLGtCQUFrQixPQUFPLFdBQVcsa0NBQWtDLDRCQUE0Qix5QkFBeUIsT0FBTywrREFBK0QseUJBQXlCLG1CQUFtQixzQ0FBc0MsMERBQTBELE9BQU8sc0NBQXNDLHlCQUF5QixvQkFBb0IsMkJBQTJCLE9BQU8sa0JBQWtCLGFBQWEsT0FBTyxvQkFBb0IsZUFBZSxPQUFPLHFCQUFxQixnQkFBZ0IsT0FBTyxtQkFBbUIsY0FBYyxPQUFPLHNCQUFzQixrQkFBa0Isa0JBQWtCLE9BQU8scUNBQXFDLG1CQUFtQixPQUFPLG1DQUFtQyx1QkFBdUIsT0FBTyxzQ0FBc0MsMEJBQTBCLE9BQU8sb0NBQW9DLHdCQUF3QixPQUFPLHFDQUFxQyx5QkFBeUIsT0FBTyxxRkFBcUYsaUJBQWlCLDhDQUE4Qyw4Q0FBOEMsOENBQThDLE9BQU8seURBQXlELGlCQUFpQixPQUFPLDRCQUE0QixvQ0FBb0Msb0NBQW9DLG9DQUFvQyxPQUFPLCtCQUErQiw2QkFBNkIsS0FBSyxtREFBbUQsMkVBQTJFLDJFQUEyRSwyRUFBMkUsT0FBTywwRUFBMEUsK0JBQStCLCtCQUErQiwrQkFBK0IsT0FBTywrQ0FBK0MseUJBQXlCLE9BQU8sdURBQXVELHNCQUFzQixPQUFPLG1CQUFtQiwyQkFBMkIsMkJBQTJCLDJCQUEyQixPQUFPLG9FQUFvRSx3QkFBd0IsT0FBTyw4Q0FBOEMsbUJBQW1CLE9BQU8sOElBQThJLG1CQUFtQiwrQkFBK0IsK0JBQStCLCtCQUErQixPQUFPLG9MQUFvTCwyQkFBMkIsT0FBTyxxTUFBcU0sc0NBQXNDLDBEQUEwRCxPQUFPLHVEQUF1RCx1QkFBdUIsMEJBQTBCLE9BQU8sMEJBQTBCLHFCQUFxQixPQUFPLHVCQUF1Qiw4QkFBOEIsd0NBQXdDLE9BQU8sNERBQTRELG9FQUFvRSxzQkFBc0IseUJBQXlCLHVCQUF1QixPQUFPLDhEQUE4RCw2Q0FBNkMseUJBQXlCLE9BQU8sb0JBQW9CLDZCQUE2QixvQ0FBb0Msa0JBQWtCLG1CQUFtQix3QkFBd0IscUJBQXFCLHlCQUF5Qiw0QkFBNEIsbUJBQW1CLE9BQU8sdURBQXVELG1DQUFtQyxtQ0FBbUMscUJBQXFCLE9BQU8sbURBQW1ELGdDQUFnQyxPQUFPLGdDQUFnQyxrQ0FBa0MsbUNBQW1DLE9BQU8sK0JBQStCLHFDQUFxQyxzQ0FBc0MsMEJBQTBCLE9BQU8scUNBQXFDLHNCQUFzQixnQ0FBZ0Msa0JBQWtCLE9BQU8sdUNBQXVDLGtCQUFrQixtQkFBbUIsd0JBQXdCLE9BQU8sK0NBQStDLGtDQUFrQyxtQ0FBbUMsT0FBTyw4Q0FBOEMscUNBQXFDLHNDQUFzQyxPQUFPLDBGQUEwRiwwREFBMEQsdUJBQXVCLE9BQU8sNEZBQTRGLHNCQUFzQixPQUFPLGlFQUFpRSw0Q0FBNEMsdUJBQXVCLHlCQUF5QixPQUFPLG9DQUFvQywrQ0FBK0Msa0JBQWtCLG1CQUFtQixPQUFPLG9EQUFvRCxrREFBa0QsaUNBQWlDLE9BQU8sbURBQW1ELGtCQUFrQixtQkFBbUIsT0FBTyw4SEFBOEgsb0JBQW9CLE9BQU8sbUVBQW1FLHFCQUFxQix5QkFBeUIsT0FBTyxzQ0FBc0MsZ0NBQWdDLGtCQUFrQix1QkFBdUIsT0FBTyx1Q0FBdUMseUJBQXlCLHlCQUF5Qix5QkFBeUIsT0FBTyxzQ0FBc0Msc0JBQXNCLHlCQUF5QixlQUFlLE9BQU8sbUNBQW1DLHFCQUFxQixzQkFBc0IsMkJBQTJCLE9BQU8sdUNBQXVDLGdCQUFnQixpQ0FBaUMsaUNBQWlDLE9BQU8sZ0VBQWdFLGtIQUFrSCxPQUFPLHlHQUF5Ryx1QkFBdUIsMkNBQTJDLGdCQUFnQixPQUFPLGtFQUFrRSxxQkFBcUIsa0JBQWtCLHVCQUF1QixPQUFPLG9DQUFvQyw0QkFBNEIsT0FBTyxtRkFBbUYsaUNBQWlDLE9BQU8sc0NBQXNDLGlDQUFpQyxPQUFPLDBDQUEwQyx1QkFBdUIsT0FBTyw0Q0FBNEMseUJBQXlCLE9BQU8saUNBQWlDLDZCQUE2Qix1QkFBdUIsdUJBQXVCLDJCQUEyQiwwQkFBMEIsdUJBQXVCLGtDQUFrQyxrQ0FBa0MsMkJBQTJCLDJDQUEyQyxPQUFPLG1EQUFtRCxpQ0FBaUMsMEJBQTBCLHVCQUF1QixPQUFPLG9FQUFvRSxvQ0FBb0MsT0FBTyxnSUFBZ0ksdUJBQXVCLE9BQU8sNEVBQTRFLHdDQUF3QyxtQ0FBbUMsT0FBTywrQ0FBK0MseUJBQXlCLHlCQUF5QiwwQkFBMEIsT0FBTyxvQ0FBb0MsbUJBQW1CLHVCQUF1QiwwQkFBMEIsT0FBTyw0QkFBNEIsa0NBQWtDLHVCQUF1QixzQkFBc0IsMkJBQTJCLHNCQUFzQixPQUFPLDhCQUE4QixxQkFBcUIsc0JBQXNCLE9BQU8sa0NBQWtDLGtCQUFrQixtQkFBbUIseUJBQXlCLGdCQUFnQix1QkFBdUIseUJBQXlCLHVCQUF1QiwyQkFBMkIsT0FBTyx3QkFBd0Isa0JBQWtCLG1CQUFtQixtQkFBbUIsK0JBQStCLDJCQUEyQiwyQ0FBMkMsdUNBQXVDLHVDQUF1Qyx1Q0FBdUMsT0FBTywyREFBMkQsd0JBQXdCLGtCQUFrQiw2Q0FBNkMsT0FBTyxxREFBcUQseUJBQXlCLGFBQWEsZUFBZSxtQkFBbUIseUJBQXlCLGtCQUFrQixtQkFBbUIsa0RBQWtELHFCQUFxQiw0QkFBNEIsOEJBQThCLE9BQU8scUhBQXFILHFCQUFxQixPQUFPLDZCQUE2QixxQkFBcUIsb0NBQW9DLGlDQUFpQyxPQUFPLHVEQUF1RCxrQkFBa0IsT0FBTyx1Q0FBdUMsa0JBQWtCLHFCQUFxQixvSUFBb0ksd0hBQXdILE9BQU8saUxBQWlMLDZCQUE2QixPQUFPLHFEQUFxRCx1QkFBdUIsNkJBQTZCLE9BQU8sdUdBQXVHLHlCQUF5QixtQkFBbUIsNkJBQTZCLDZCQUE2Qix5QkFBeUIsa0JBQWtCLDBCQUEwQixnQ0FBZ0MsNkJBQTZCLDRCQUE0Qix3QkFBd0IsMkJBQTJCLDRDQUE0QyxPQUFPLDBDQUEwQyxzQkFBc0IsMkJBQTJCLE9BQU8sdUlBQXVJLHlCQUF5QiwyQkFBMkIsb0NBQW9DLDhCQUE4QixvQkFBb0IsT0FBTyx5REFBeUQsc0JBQXNCLEtBQUssMEJBQTBCLHVCQUF1QixLQUFLLG9FQUFvRSxnQkFBZ0Isd0JBQXdCLE9BQU8saUNBQWlDLGdCQUFnQiwyQkFBMkIsNkJBQTZCLE9BQU8sb0NBQW9DLGFBQWEsd0JBQXdCLHdCQUF3QixnQ0FBZ0MsT0FBTywyQkFBMkIsd0JBQXdCLEtBQUssNEJBQTRCLHVCQUF1QixLQUFLLG9FQUFvRSxlQUFlLHVCQUF1QixPQUFPLGtDQUFrQyxlQUFlLDBCQUEwQiw4QkFBOEIsT0FBTyxtQ0FBbUMsY0FBYyx5QkFBeUIsK0JBQStCLE9BQU8sOENBQThDLGlHQUFpRywwQ0FBMEMsNEJBQTRCLFNBQVMsT0FBTyx1QkFBdUI7QUFDemtwQztBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzcz82ZmM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyBmcm9tIFwiLi9pbWFnZXMvbGF5ZXJzLnBuZ1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fIGZyb20gXCIuL2ltYWdlcy9sYXllcnMtMngucG5nXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18gZnJvbSBcIi4vaW1hZ2VzL21hcmtlci1pY29uLnBuZ1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi8qIFByZXZlbnRzIElFMTEgZnJvbSBoaWdobGlnaHRpbmcgdGlsZXMgaW4gYmx1ZSAqL1xcclxcbi5sZWFmbGV0LXRpbGU6Oi1tb3otc2VsZWN0aW9uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdGlsZTo6c2VsZWN0aW9uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLyogU2FmYXJpIHJlbmRlcnMgbm9uLXJldGluYSB0aWxlIG9uIHJldGluYSBiZXR0ZXIgd2l0aCB0aGlzLCBidXQgQ2hyb21lIGlzIHdvcnNlICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdGltYWdlLXJlbmRlcmluZzogLXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdDtcXHJcXG5cXHR9XFxyXFxuLyogaGFjayB0aGF0IHByZXZlbnRzIGh3IGxheWVycyBcXFwic3RyZXRjaGluZ1xcXCIgd2hlbiBsb2FkaW5nIG5ldyB0aWxlcyAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0d2lkdGg6IDE2MDBweDtcXHJcXG5cXHRoZWlnaHQ6IDE2MDBweDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBzdmc6IHJlc2V0IHN2ZyBtYXgtd2lkdGggZGVjbGVyYXRpb24gc2hpcHBlZCBpbiBKb29tbGEhIChqb29tbGEub3JnKSAzLnggKi9cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgaW1nOiBtYXAgaXMgYnJva2VuIGluIEZGIGlmIHlvdSBoYXZlIG1heC13aWR0aDogMTAwJSBvbiB0aWxlcyAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1vdmVybGF5LXBhbmUgc3ZnIHtcXHJcXG5cXHRtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHRtYXgtaGVpZ2h0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1tYXJrZXItcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXNoYWRvdy1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZS1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgaW1nLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdG1heC13aWR0aDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdG1heC1oZWlnaHQ6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHR3aWR0aDogYXV0bztcXHJcXG5cXHRwYWRkaW5nOiAwO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnIHtcXHJcXG5cXHQvKiBGYWxsYmFjayBmb3IgRkYgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBpbmNoLXpvb20gKi9cXHJcXG5cXHR0b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnLmxlYWZsZXQtdG91Y2gtem9vbSB7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHR0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuc3ZnLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG59XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHRyYW5zaXRpb246ICAgICAgICAgdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtcGFuLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0dHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWJiaW5nO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBtYXJrZXIgJiBvdmVybGF5cyBpbnRlcmFjdGl2aXR5ICovXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgsXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbi5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuc3ZnLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSBwYXRoIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogdmlzaWJsZVBhaW50ZWQ7IC8qIElFIDktMTAgZG9lc24ndCBoYXZlIGF1dG8gKi9cXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogdmlzdWFsIHR3ZWFrcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2RkZDtcXHJcXG5cXHRvdXRsaW5lLW9mZnNldDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0Y29sb3I6ICMwMDc4QTg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHRib3JkZXI6IDJweCBkb3R0ZWQgIzM4ZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdHlwb2dyYXBoeSAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0Zm9udC1mYW1pbHk6IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuXFx0Zm9udC1zaXplOiAxMnB4O1xcclxcblxcdGZvbnQtc2l6ZTogMC43NXJlbTtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS41O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHRvb2xiYXIgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjY1KTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcclxcblxcdHdpZHRoOiAyNnB4O1xcclxcblxcdGhlaWdodDogMjZweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMjZweDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGNvbG9yOiBibGFjaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCUgNTAlO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyLFxcclxcbi5sZWFmbGV0LWJhciBhOmZvY3VzIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLmxlYWZsZXQtZGlzYWJsZWQge1xcclxcblxcdGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdGNvbG9yOiAjYmJiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0d2lkdGg6IDMwcHg7XFxyXFxuXFx0aGVpZ2h0OiAzMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAzMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB6b29tIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20taW4sXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLW91dCB7XFxyXFxuXFx0Zm9udDogYm9sZCAxOHB4ICdMdWNpZGEgQ29uc29sZScsIE1vbmFjbywgbW9ub3NwYWNlO1xcclxcblxcdHRleHQtaW5kZW50OiAxcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbiwgLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLW91dCAge1xcclxcblxcdGZvbnQtc2l6ZTogMjJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogbGF5ZXJzIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcclxcblxcdHdpZHRoOiAzNnB4O1xcclxcblxcdGhlaWdodDogMzZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDI2cHggMjZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHR3aWR0aDogNDRweDtcXHJcXG5cXHRoZWlnaHQ6IDQ0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3QsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIHtcXHJcXG5cXHRwYWRkaW5nOiA2cHggMTBweCA2cHggNnB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhciB7XFxyXFxuXFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcblxcdG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG5cXHRwYWRkaW5nLXJpZ2h0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAycHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHRvcDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyBsYWJlbCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0Zm9udC1zaXplOiAxM3B4O1xcclxcblxcdGZvbnQtc2l6ZTogMS4wODMzM2VtO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3Ige1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRtYXJnaW46IDVweCAtMTBweCA1cHggLTZweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGVmYXVsdCBpY29uIFVSTHMgKi9cXHJcXG4ubGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCB7IC8qIHVzZWQgb25seSBpbiBwYXRoLWd1ZXNzaW5nIGhldXJpc3RpYywgc2VlIEwuSWNvbi5EZWZhdWx0ICovXFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyArIFwiKTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogYXR0cmlidXRpb24gYW5kIHNjYWxlIGNvbnRyb2xzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcclxcblxcdG1hcmdpbjogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdHBhZGRpbmc6IDAgNXB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmZvY3VzIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBzdmcge1xcclxcblxcdGRpc3BsYXk6IGlubGluZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwwLDAsMC4yKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBwb3B1cCAqL1xcclxcblxcclxcbi5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcdHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogMTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCB7XFxyXFxuXFx0bWFyZ2luOiAxM3B4IDI0cHggMTNweCAyMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjM7XFxyXFxuXFx0Zm9udC1zaXplOiAxM3B4O1xcclxcblxcdGZvbnQtc2l6ZTogMS4wODMzM2VtO1xcclxcblxcdG1pbi1oZWlnaHQ6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCBwIHtcXHJcXG5cXHRtYXJnaW46IDE3cHggMDtcXHJcXG5cXHRtYXJnaW46IDEuM2VtIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0yMHB4O1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDE3cHg7XFxyXFxuXFx0aGVpZ2h0OiAxN3B4O1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHJcXG5cXHRtYXJnaW46IC0xMHB4IGF1dG8gMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJhY2tncm91bmQ6IHdoaXRlO1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJveC1zaGFkb3c6IDAgM3B4IDE0cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRib3JkZXI6IG5vbmU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHdpZHRoOiAyNHB4O1xcclxcblxcdGhlaWdodDogMjRweDtcXHJcXG5cXHRmb250OiAxNnB4LzI0cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcblxcdGNvbG9yOiAjNzU3NTc1O1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXIsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246Zm9jdXMge1xcclxcblxcdGNvbG9yOiAjNTg1ODU4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCB7XFxyXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0LW1zLXpvb206IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0bWFyZ2luOiAwIGF1dG87XFxyXFxuXFxyXFxuXFx0LW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KVxcXCI7XFxyXFxuXFx0ZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OCk7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtem9vbSxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBkaXYgaWNvbiAqL1xcclxcblxcclxcbi5sZWFmbGV0LWRpdi1pY29uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIFRvb2x0aXAgKi9cXHJcXG4vKiBCYXNlIHN0eWxlcyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYSB0b29sdGlwICovXFxyXFxuLmxlYWZsZXQtdG9vbHRpcCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBhZGRpbmc6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcclxcblxcdGNvbG9yOiAjMjIyO1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym9yZGVyOiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXCI7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERpcmVjdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbSB7XFxyXFxuXFx0bWFyZ2luLXRvcDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcCB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAtMTJweDtcXHJcXG5cXHRib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMTJweDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDUwJTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlIHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1sZWZ0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBQcmludGluZyAqL1xcclxcblxcdFxcclxcbkBtZWRpYSBwcmludCB7XFxyXFxuXFx0LyogUHJldmVudCBwcmludGVycyBmcm9tIHJlbW92aW5nIGJhY2tncm91bmQtaW1hZ2VzIG9mIGNvbnRyb2xzLiAqL1xcclxcblxcdC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdFxcdC13ZWJraXQtcHJpbnQtY29sb3ItYWRqdXN0OiBleGFjdDtcXHJcXG5cXHRcXHRjb2xvci1hZGp1c3Q6IGV4YWN0O1xcclxcblxcdFxcdH1cXHJcXG5cXHR9XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvQkFBb0I7O0FBRXBCOzs7Ozs7Ozs7O0NBVUMsa0JBQWtCO0NBQ2xCLE9BQU87Q0FDUCxNQUFNO0NBQ047QUFDRDtDQUNDLGdCQUFnQjtDQUNoQjtBQUNEOzs7Q0FHQyx5QkFBeUI7SUFDdEIsc0JBQXNCO1NBQ2pCLHFCQUFpQjtLQUFqQixpQkFBaUI7R0FDdkIsdUJBQXVCO0NBQ3pCO0FBQ0Qsa0RBQWtEO0FBQ2xEO0NBQ0MsdUJBQXVCO0FBQ3hCO0FBRkE7Q0FDQyx1QkFBdUI7QUFDeEI7QUFDQSxtRkFBbUY7QUFDbkY7Q0FDQywwQ0FBMEM7Q0FDMUM7QUFDRCxxRUFBcUU7QUFDckU7Q0FDQyxhQUFhO0NBQ2IsY0FBYztDQUNkLDZCQUE2QjtDQUM3QjtBQUNEOztDQUVDLGNBQWM7Q0FDZDtBQUNELGdHQUFnRztBQUNoRyxxRkFBcUY7QUFDckY7Q0FDQywwQkFBMEI7Q0FDMUIsMkJBQTJCO0NBQzNCO0FBQ0Q7Ozs7O0NBS0MsMEJBQTBCO0NBQzFCLDJCQUEyQjtDQUMzQixXQUFXO0NBQ1gsVUFBVTtDQUNWOztBQUVEO0NBRUMseUJBQXlCO0NBQ3pCO0FBQ0Q7Q0FFQyxxREFBcUQ7Q0FDckQsa0JBQWtCO0NBQ2xCLHdCQUF3QjtBQUN6QjtBQUNBO0NBRUMsa0JBQWtCO0FBQ25CO0FBQ0E7Q0FDQyx3Q0FBd0M7QUFDekM7QUFDQTtDQUNDLG9EQUFvRDtBQUNyRDtBQUNBO0NBQ0MsZUFBZTtDQUNmLGtCQUFrQjtDQUNsQjtBQUNEO0NBQ0MsbUJBQW1CO0NBQ25CO0FBQ0Q7Q0FDQyxRQUFRO0NBQ1IsU0FBUztDQUVKLHNCQUFzQjtDQUMzQixZQUFZO0NBQ1o7QUFDRCx1RUFBdUU7QUFDdkU7Q0FDQyxzQkFBc0I7Q0FDdEI7O0FBRUQsd0JBQXdCLFlBQVksRUFBRTs7QUFFdEMsd0JBQXdCLFlBQVksRUFBRTtBQUN0Qyx3QkFBd0IsWUFBWSxFQUFFO0FBQ3RDLHdCQUF3QixZQUFZLEVBQUU7QUFDdEMsd0JBQXdCLFlBQVksRUFBRTtBQUN0QywwQkFBMEIsWUFBWSxFQUFFO0FBQ3hDLHdCQUF3QixZQUFZLEVBQUU7O0FBRXRDLDJCQUEyQixZQUFZLEVBQUU7QUFDekMsMkJBQTJCLFlBQVksRUFBRTs7QUFFekM7Q0FDQyxVQUFVO0NBQ1YsV0FBVztDQUNYO0FBQ0Q7Q0FDQywyQkFBMkI7Q0FDM0IscUJBQXFCO0NBQ3JCLGtCQUFrQjtDQUNsQjs7O0FBR0Qsd0JBQXdCOztBQUV4QjtDQUNDLGtCQUFrQjtDQUNsQixZQUFZO0NBQ1osOEJBQThCLEVBQUUsOEJBQThCO0NBQzlELG9CQUFvQjtDQUNwQjtBQUNEOztDQUVDLGtCQUFrQjtDQUNsQixhQUFhO0NBQ2Isb0JBQW9CO0NBQ3BCO0FBQ0Q7Q0FDQyxNQUFNO0NBQ047QUFDRDtDQUNDLFFBQVE7Q0FDUjtBQUNEO0NBQ0MsU0FBUztDQUNUO0FBQ0Q7Q0FDQyxPQUFPO0NBQ1A7QUFDRDtDQUNDLFdBQVc7Q0FDWCxXQUFXO0NBQ1g7QUFDRDtDQUNDLFlBQVk7Q0FDWjtBQUNEO0NBQ0MsZ0JBQWdCO0NBQ2hCO0FBQ0Q7Q0FDQyxtQkFBbUI7Q0FDbkI7QUFDRDtDQUNDLGlCQUFpQjtDQUNqQjtBQUNEO0NBQ0Msa0JBQWtCO0NBQ2xCOzs7QUFHRCw2QkFBNkI7O0FBRTdCO0NBQ0MsVUFBVTtDQUdGLCtCQUErQjtDQUN2QztBQUNEO0NBQ0MsVUFBVTtDQUNWO0FBQ0Q7Q0FHUyxxQkFBcUI7Q0FDN0I7QUFDRDtDQUNDLHNCQUFzQjtBQUN2Qjs7QUFFQTtDQUdTLDREQUE0RDtDQUNwRTtBQUNEOztDQUlTLGdCQUFnQjtDQUN4Qjs7QUFFRDtDQUNDLGtCQUFrQjtDQUNsQjs7O0FBR0QsWUFBWTs7QUFFWjtDQUNDLGVBQWU7Q0FDZjtBQUNEO0NBQ0Msb0JBQW9CO0NBRXBCLG9CQUFvQjtDQUNwQjtBQUNEOztDQUVDLGlCQUFpQjtDQUNqQjtBQUNEOztDQUVDLFlBQVk7Q0FDWjtBQUNEOzs7Q0FHQyxZQUFZO0NBQ1osd0JBQXdCO0NBRXhCLHdCQUF3QjtDQUN4Qjs7QUFFRCxvQ0FBb0M7QUFDcEM7Ozs7O0NBS0Msb0JBQW9CO0NBQ3BCOztBQUVEOzs7O0NBSUMsOEJBQThCLEVBQUUsOEJBQThCO0NBQzlELG9CQUFvQjtDQUNwQjs7QUFFRCxrQkFBa0I7O0FBRWxCO0NBQ0MsZ0JBQWdCO0NBQ2hCLG1CQUFtQjtDQUNuQjtBQUNEO0NBQ0MsY0FBYztDQUNkO0FBQ0Q7Q0FDQyx1QkFBdUI7Q0FDdkIsaUNBQWlDO0NBQ2pDOzs7QUFHRCx1QkFBdUI7QUFDdkI7Q0FDQywyREFBMkQ7Q0FDM0QsZUFBZTtDQUNmLGtCQUFrQjtDQUNsQixnQkFBZ0I7Q0FDaEI7OztBQUdELDJCQUEyQjs7QUFFM0I7Q0FDQyxzQ0FBc0M7Q0FDdEMsa0JBQWtCO0NBQ2xCO0FBQ0Q7Q0FDQyxzQkFBc0I7Q0FDdEIsNkJBQTZCO0NBQzdCLFdBQVc7Q0FDWCxZQUFZO0NBQ1osaUJBQWlCO0NBQ2pCLGNBQWM7Q0FDZCxrQkFBa0I7Q0FDbEIscUJBQXFCO0NBQ3JCLFlBQVk7Q0FDWjtBQUNEOztDQUVDLDRCQUE0QjtDQUM1Qiw0QkFBNEI7Q0FDNUIsY0FBYztDQUNkO0FBQ0Q7O0NBRUMseUJBQXlCO0NBQ3pCO0FBQ0Q7Q0FDQywyQkFBMkI7Q0FDM0IsNEJBQTRCO0NBQzVCO0FBQ0Q7Q0FDQyw4QkFBOEI7Q0FDOUIsK0JBQStCO0NBQy9CLG1CQUFtQjtDQUNuQjtBQUNEO0NBQ0MsZUFBZTtDQUNmLHlCQUF5QjtDQUN6QixXQUFXO0NBQ1g7O0FBRUQ7Q0FDQyxXQUFXO0NBQ1gsWUFBWTtDQUNaLGlCQUFpQjtDQUNqQjtBQUNEO0NBQ0MsMkJBQTJCO0NBQzNCLDRCQUE0QjtDQUM1QjtBQUNEO0NBQ0MsOEJBQThCO0NBQzlCLCtCQUErQjtDQUMvQjs7QUFFRCxpQkFBaUI7O0FBRWpCOztDQUVDLG1EQUFtRDtDQUNuRCxnQkFBZ0I7Q0FDaEI7O0FBRUQ7Q0FDQyxlQUFlO0NBQ2Y7OztBQUdELG1CQUFtQjs7QUFFbkI7Q0FDQyxxQ0FBcUM7Q0FDckMsZ0JBQWdCO0NBQ2hCLGtCQUFrQjtDQUNsQjtBQUNEO0NBQ0MseURBQXdDO0NBQ3hDLFdBQVc7Q0FDWCxZQUFZO0NBQ1o7QUFDRDtDQUNDLHlEQUEyQztDQUMzQywwQkFBMEI7Q0FDMUI7QUFDRDtDQUNDLFdBQVc7Q0FDWCxZQUFZO0NBQ1o7QUFDRDs7Q0FFQyxhQUFhO0NBQ2I7QUFDRDtDQUNDLGNBQWM7Q0FDZCxrQkFBa0I7Q0FDbEI7QUFDRDtDQUNDLHlCQUF5QjtDQUN6QixXQUFXO0NBQ1gsZ0JBQWdCO0NBQ2hCO0FBQ0Q7Q0FDQyxrQkFBa0I7Q0FDbEIsa0JBQWtCO0NBQ2xCLGtCQUFrQjtDQUNsQjtBQUNEO0NBQ0MsZUFBZTtDQUNmLGtCQUFrQjtDQUNsQixRQUFRO0NBQ1I7QUFDRDtDQUNDLGNBQWM7Q0FDZCxlQUFlO0NBQ2Ysb0JBQW9CO0NBQ3BCO0FBQ0Q7Q0FDQyxTQUFTO0NBQ1QsMEJBQTBCO0NBQzFCLDBCQUEwQjtDQUMxQjs7QUFFRCxzQkFBc0I7QUFDdEIsNkJBQTZCLDZEQUE2RDtDQUN6Rix5REFBNkM7Q0FDN0M7OztBQUdELG1DQUFtQzs7QUFFbkM7Q0FDQyxnQkFBZ0I7Q0FDaEIsb0NBQW9DO0NBQ3BDLFNBQVM7Q0FDVDtBQUNEOztDQUVDLGNBQWM7Q0FDZCxXQUFXO0NBQ1gsZ0JBQWdCO0NBQ2hCO0FBQ0Q7Q0FDQyxxQkFBcUI7Q0FDckI7QUFDRDs7Q0FFQywwQkFBMEI7Q0FDMUI7QUFDRDtDQUNDLDBCQUEwQjtDQUMxQjtBQUNEO0NBQ0MsZ0JBQWdCO0NBQ2hCO0FBQ0Q7Q0FDQyxrQkFBa0I7Q0FDbEI7QUFDRDtDQUNDLHNCQUFzQjtDQUN0QixnQkFBZ0I7Q0FDaEIsZ0JBQWdCO0NBQ2hCLG9CQUFvQjtDQUNwQixtQkFBbUI7Q0FDbkIsZ0JBQWdCO0NBRVgsc0JBQXNCOztDQUUzQixnQkFBZ0I7Q0FDaEIsb0NBQW9DO0NBQ3BDO0FBQ0Q7Q0FDQywwQkFBMEI7Q0FDMUIsbUJBQW1CO0NBQ25CLGdCQUFnQjtDQUNoQjtBQUNEO0NBQ0MsNkJBQTZCO0NBQzdCOztBQUVEOzs7Q0FHQyxnQkFBZ0I7Q0FDaEI7QUFDRDs7Q0FFQyxpQ0FBaUM7Q0FDakMsNEJBQTRCO0NBQzVCOzs7QUFHRCxVQUFVOztBQUVWO0NBQ0Msa0JBQWtCO0NBQ2xCLGtCQUFrQjtDQUNsQixtQkFBbUI7Q0FDbkI7QUFDRDtDQUNDLFlBQVk7Q0FDWixnQkFBZ0I7Q0FDaEIsbUJBQW1CO0NBQ25CO0FBQ0Q7Q0FDQywyQkFBMkI7Q0FDM0IsZ0JBQWdCO0NBQ2hCLGVBQWU7Q0FDZixvQkFBb0I7Q0FDcEIsZUFBZTtDQUNmO0FBQ0Q7Q0FDQyxjQUFjO0NBQ2QsZUFBZTtDQUNmO0FBQ0Q7Q0FDQyxXQUFXO0NBQ1gsWUFBWTtDQUNaLGtCQUFrQjtDQUNsQixTQUFTO0NBQ1QsZ0JBQWdCO0NBQ2hCLGtCQUFrQjtDQUNsQixnQkFBZ0I7Q0FDaEIsb0JBQW9CO0NBQ3BCO0FBQ0Q7Q0FDQyxXQUFXO0NBQ1gsWUFBWTtDQUNaLFlBQVk7O0NBRVosb0JBQW9CO0NBQ3BCLG9CQUFvQjtDQUtaLHdCQUF3QjtDQUNoQztBQUNEOztDQUVDLGlCQUFpQjtDQUNqQixXQUFXO0NBQ1gsc0NBQXNDO0NBQ3RDO0FBQ0Q7Q0FDQyxrQkFBa0I7Q0FDbEIsTUFBTTtDQUNOLFFBQVE7Q0FDUixZQUFZO0NBQ1osa0JBQWtCO0NBQ2xCLFdBQVc7Q0FDWCxZQUFZO0NBQ1osMkNBQTJDO0NBQzNDLGNBQWM7Q0FDZCxxQkFBcUI7Q0FDckIsdUJBQXVCO0NBQ3ZCO0FBQ0Q7O0NBRUMsY0FBYztDQUNkO0FBQ0Q7Q0FDQyxjQUFjO0NBQ2QsNkJBQTZCO0NBQzdCLDBCQUEwQjtDQUMxQjs7QUFFRDtDQUNDLFdBQVc7Q0FDWDtBQUNEO0NBQ0MsV0FBVztDQUNYLGNBQWM7O0NBRWQsdUhBQXVIO0NBQ3ZILGlIQUFpSDtDQUNqSDs7QUFFRDs7OztDQUlDLHNCQUFzQjtDQUN0Qjs7O0FBR0QsYUFBYTs7QUFFYjtDQUNDLGdCQUFnQjtDQUNoQixzQkFBc0I7Q0FDdEI7OztBQUdELFlBQVk7QUFDWixtREFBbUQ7QUFDbkQ7Q0FDQyxrQkFBa0I7Q0FDbEIsWUFBWTtDQUNaLHNCQUFzQjtDQUN0QixzQkFBc0I7Q0FDdEIsa0JBQWtCO0NBQ2xCLFdBQVc7Q0FDWCxtQkFBbUI7Q0FDbkIseUJBQXlCO0NBQ3pCLHNCQUFzQjtDQUN0QixxQkFBcUI7Q0FDckIsaUJBQWlCO0NBQ2pCLG9CQUFvQjtDQUNwQixxQ0FBcUM7Q0FDckM7QUFDRDtDQUNDLGVBQWU7Q0FDZixvQkFBb0I7Q0FDcEI7QUFDRDs7OztDQUlDLGtCQUFrQjtDQUNsQixvQkFBb0I7Q0FDcEIsNkJBQTZCO0NBQzdCLHVCQUF1QjtDQUN2QixXQUFXO0NBQ1g7O0FBRUQsZUFBZTs7QUFFZjtDQUNDLGVBQWU7QUFDaEI7QUFDQTtDQUNDLGdCQUFnQjtBQUNqQjtBQUNBOztDQUVDLFNBQVM7Q0FDVCxpQkFBaUI7Q0FDakI7QUFDRDtDQUNDLFNBQVM7Q0FDVCxvQkFBb0I7Q0FDcEIsc0JBQXNCO0NBQ3RCO0FBQ0Q7Q0FDQyxNQUFNO0NBQ04saUJBQWlCO0NBQ2pCLGlCQUFpQjtDQUNqQix5QkFBeUI7Q0FDekI7QUFDRDtDQUNDLGlCQUFpQjtBQUNsQjtBQUNBO0NBQ0MsZ0JBQWdCO0FBQ2pCO0FBQ0E7O0NBRUMsUUFBUTtDQUNSLGdCQUFnQjtDQUNoQjtBQUNEO0NBQ0MsUUFBUTtDQUNSLG1CQUFtQjtDQUNuQix1QkFBdUI7Q0FDdkI7QUFDRDtDQUNDLE9BQU87Q0FDUCxrQkFBa0I7Q0FDbEIsd0JBQXdCO0NBQ3hCOztBQUVELGFBQWE7O0FBRWI7Q0FDQyxrRUFBa0U7Q0FDbEU7RUFDQyxpQ0FBaUM7RUFDakMsbUJBQW1CO0VBQ25CO0NBQ0RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xcclxcblxcdH1cXHJcXG4vKiBQcmV2ZW50cyBJRTExIGZyb20gaGlnaGxpZ2h0aW5nIHRpbGVzIGluIGJsdWUgKi9cXHJcXG4ubGVhZmxldC10aWxlOjpzZWxlY3Rpb24ge1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4vKiBTYWZhcmkgcmVuZGVycyBub24tcmV0aW5hIHRpbGUgb24gcmV0aW5hIGJldHRlciB3aXRoIHRoaXMsIGJ1dCBDaHJvbWUgaXMgd29yc2UgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0aW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcclxcblxcdH1cXHJcXG4vKiBoYWNrIHRoYXQgcHJldmVudHMgaHcgbGF5ZXJzIFxcXCJzdHJldGNoaW5nXFxcIiB3aGVuIGxvYWRpbmcgbmV3IHRpbGVzICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogMTYwMHB4O1xcclxcblxcdGhlaWdodDogMTYwMHB4O1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIHN2ZzogcmVzZXQgc3ZnIG1heC13aWR0aCBkZWNsZXJhdGlvbiBzaGlwcGVkIGluIEpvb21sYSEgKGpvb21sYS5vcmcpIDMueCAqL1xcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBpbWc6IG1hcCBpcyBicm9rZW4gaW4gRkYgaWYgeW91IGhhdmUgbWF4LXdpZHRoOiAxMDAlIG9uIHRpbGVzICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcge1xcclxcblxcdG1heC13aWR0aDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdG1heC1oZWlnaHQ6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtc2hhZG93LXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBpbWcubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0bWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0bWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdHdpZHRoOiBhdXRvO1xcclxcblxcdHBhZGRpbmc6IDA7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxuXFx0LyogRmFsbGJhY2sgZm9yIEZGIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwaW5jaC16b29tICovXFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LW1hcC1wYW5lIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuc3ZnLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG59XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogICAgLW1vei10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogICAgICAgICB0cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiYmluZztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogbWFya2VyICYgb3ZlcmxheXMgaW50ZXJhY3Rpdml0eSAqL1xcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24ubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbnN2Zy5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUgcGF0aCB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHZpc3VhbCB0d2Vha3MgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGJhY2tncm91bmQ6ICNkZGQ7XFxyXFxuXFx0b3V0bGluZS1vZmZzZXQ6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdGNvbG9yOiAjMDA3OEE4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWJveCB7XFxyXFxuXFx0Ym9yZGVyOiAycHggZG90dGVkICMzOGY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjUpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHR5cG9ncmFwaHkgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGZvbnQtZmFtaWx5OiBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcblxcdGZvbnQtc2l6ZTogMTJweDtcXHJcXG5cXHRmb250LXNpemU6IDAuNzVyZW07XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDEuNTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0b29sYmFyIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC42NSk7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYztcXHJcXG5cXHR3aWR0aDogMjZweDtcXHJcXG5cXHRoZWlnaHQ6IDI2cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDI2cHg7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRjb2xvcjogYmxhY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlcixcXHJcXG4ubGVhZmxldC1iYXIgYTpmb2N1cyB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYS5sZWFmbGV0LWRpc2FibGVkIHtcXHJcXG5cXHRjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHRjb2xvcjogI2JiYjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGEge1xcclxcblxcdHdpZHRoOiAzMHB4O1xcclxcblxcdGhlaWdodDogMzBweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMzBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogem9vbSBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLWluLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQge1xcclxcblxcdGZvbnQ6IGJvbGQgMThweCAnTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZTtcXHJcXG5cXHR0ZXh0LWluZGVudDogMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20taW4sIC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQgIHtcXHJcXG5cXHRmb250LXNpemU6IDIycHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGxheWVycyBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKGltYWdlcy9sYXllcnMucG5nKTtcXHJcXG5cXHR3aWR0aDogMzZweDtcXHJcXG5cXHRoZWlnaHQ6IDM2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChpbWFnZXMvbGF5ZXJzLTJ4LnBuZyk7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiAyNnB4IDI2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0d2lkdGg6IDQ0cHg7XFxyXFxuXFx0aGVpZ2h0OiA0NHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0LFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0ZGlzcGxheTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCB7XFxyXFxuXFx0cGFkZGluZzogNnB4IDEwcHggNnB4IDZweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXIge1xcclxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXHJcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxyXFxuXFx0cGFkZGluZy1yaWdodDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMnB4O1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdGZvbnQtc2l6ZTogMTNweDtcXHJcXG5cXHRmb250LXNpemU6IDEuMDgzMzNlbTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VwYXJhdG9yIHtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0bWFyZ2luOiA1cHggLTEwcHggNXB4IC02cHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERlZmF1bHQgaWNvbiBVUkxzICovXFxyXFxuLmxlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGggeyAvKiB1c2VkIG9ubHkgaW4gcGF0aC1ndWVzc2luZyBoZXVyaXN0aWMsIHNlZSBMLkljb24uRGVmYXVsdCAqL1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChpbWFnZXMvbWFya2VyLWljb24ucG5nKTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogYXR0cmlidXRpb24gYW5kIHNjYWxlIGNvbnRyb2xzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcclxcblxcdG1hcmdpbjogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdHBhZGRpbmc6IDAgNXB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmZvY3VzIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBzdmcge1xcclxcblxcdGRpc3BsYXk6IGlubGluZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHQgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwwLDAsMC4yKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBwb3B1cCAqL1xcclxcblxcclxcbi5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcdHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogMTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCB7XFxyXFxuXFx0bWFyZ2luOiAxM3B4IDI0cHggMTNweCAyMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjM7XFxyXFxuXFx0Zm9udC1zaXplOiAxM3B4O1xcclxcblxcdGZvbnQtc2l6ZTogMS4wODMzM2VtO1xcclxcblxcdG1pbi1oZWlnaHQ6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCBwIHtcXHJcXG5cXHRtYXJnaW46IDE3cHggMDtcXHJcXG5cXHRtYXJnaW46IDEuM2VtIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0yMHB4O1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDE3cHg7XFxyXFxuXFx0aGVpZ2h0OiAxN3B4O1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHJcXG5cXHRtYXJnaW46IC0xMHB4IGF1dG8gMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLFxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0YmFja2dyb3VuZDogd2hpdGU7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAzcHggMTRweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdGJvcmRlcjogbm9uZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0aGVpZ2h0OiAyNHB4O1xcclxcblxcdGZvbnQ6IDE2cHgvMjRweCBUYWhvbWEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxyXFxuXFx0Y29sb3I6ICM3NTc1NzU7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3ZlcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpmb2N1cyB7XFxyXFxuXFx0Y29sb3I6ICM1ODU4NTg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIHtcXHJcXG5cXHRvdmVyZmxvdzogYXV0bztcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHQtbXMtem9vbTogMTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMjRweDtcXHJcXG5cXHRtYXJnaW46IDAgYXV0bztcXHJcXG5cXHJcXG5cXHQtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpXFxcIjtcXHJcXG5cXHRmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC16b29tLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGRpdiBpY29uICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtZGl2LWljb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzY2NjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogVG9vbHRpcCAqL1xcclxcbi8qIEJhc2Ugc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0aGF0IGhhcyBhIHRvb2x0aXAgKi9cXHJcXG4ubGVhZmxldC10b29sdGlwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cGFkZGluZzogNnB4O1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuXFx0Y29sb3I6ICMyMjI7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAubGVhZmxldC1pbnRlcmFjdGl2ZSB7XFxyXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3JkZXI6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHRjb250ZW50OiBcXFwiXFxcIjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGlyZWN0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiA1MCU7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdG1hcmdpbi1ib3R0b206IC0xMnB4O1xcclxcblxcdGJvcmRlci10b3AtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSB7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdG1hcmdpbi10b3A6IC0xMnB4O1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdGJvcmRlci1ib3R0b20tY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHRvcDogNTAlO1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdG1hcmdpbi1yaWdodDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLWxlZnQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItcmlnaHQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIFByaW50aW5nICovXFxyXFxuXFx0XFxyXFxuQG1lZGlhIHByaW50IHtcXHJcXG5cXHQvKiBQcmV2ZW50IHByaW50ZXJzIGZyb20gcmVtb3ZpbmcgYmFja2dyb3VuZC1pbWFnZXMgb2YgY29udHJvbHMuICovXFxyXFxuXFx0LmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0XFx0LXdlYmtpdC1wcmludC1jb2xvci1hZGp1c3Q6IGV4YWN0O1xcclxcblxcdFxcdGNvbG9yLWFkanVzdDogZXhhY3Q7XFxyXFxuXFx0XFx0fVxcclxcblxcdH1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/leaflet/dist/leaflet.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/YWU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0M7O0FBRWxDLDhCQUE4Qjs7QUFFOUIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHlDQUF5Qyw4RkFBOEYsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRXZlLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcz9mNjVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \"string\") {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzU0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0ge307XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1wYXJhbS1yZWFzc2lnblxuXG5cbiAgdXJsID0gdXJsICYmIHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmw7XG5cbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/getUrl.js\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers-2x.png":
/*!********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers-2x.png ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"/images/vendor/leaflet/dist/layers-2x.png?8f2c4d11474275fbc1614b9098334eae\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSw0RUFBNEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nPzNmZGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIvaW1hZ2VzL3ZlbmRvci9sZWFmbGV0L2Rpc3QvbGF5ZXJzLTJ4LnBuZz84ZjJjNGQxMTQ3NDI3NWZiYzE2MTRiOTA5ODMzNGVhZVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/images/layers-2x.png\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers.png":
/*!*****************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers.png ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"/images/vendor/leaflet/dist/layers.png?416d91365b44e4b4f4777663e6f009f3\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSx5RUFBeUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2FmMzEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIvaW1hZ2VzL3ZlbmRvci9sZWFmbGV0L2Rpc3QvbGF5ZXJzLnBuZz80MTZkOTEzNjViNDRlNGI0ZjQ3Nzc2NjNlNmYwMDlmM1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/images/layers.png\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"/images/vendor/leaflet/dist/marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLDhFQUE4RSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZz8wMzNjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiL2ltYWdlcy92ZW5kb3IvbGVhZmxldC9kaXN0L21hcmtlci1pY29uLnBuZz8yYjNlMWZhZjg5Zjk0YTQ4MzUzOTdlN2E0M2I0Zjc3ZFwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/images/marker-icon.png\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* @preserve\n * Leaflet 1.8.0, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  var version = \"1.8.0\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\r\n\r\n  // @function extend(dest: Object, src?: Object): Object\r\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\r\n  function extend(dest) {\r\n  \tvar i, j, len, src;\r\n\r\n  \tfor (j = 1, len = arguments.length; j < len; j++) {\r\n  \t\tsrc = arguments[j];\r\n  \t\tfor (i in src) {\r\n  \t\t\tdest[i] = src[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn dest;\r\n  }\r\n\r\n  // @function create(proto: Object, properties?: Object): Object\r\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\r\n  var create$2 = Object.create || (function () {\r\n  \tfunction F() {}\r\n  \treturn function (proto) {\r\n  \t\tF.prototype = proto;\r\n  \t\treturn new F();\r\n  \t};\r\n  })();\r\n\r\n  // @function bind(fn: Function, …): Function\r\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\r\n  // Has a `L.bind()` shortcut.\r\n  function bind(fn, obj) {\r\n  \tvar slice = Array.prototype.slice;\r\n\r\n  \tif (fn.bind) {\r\n  \t\treturn fn.bind.apply(fn, slice.call(arguments, 1));\r\n  \t}\r\n\r\n  \tvar args = slice.call(arguments, 2);\r\n\r\n  \treturn function () {\r\n  \t\treturn fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n  \t};\r\n  }\r\n\r\n  // @property lastId: Number\r\n  // Last unique ID used by [`stamp()`](#util-stamp)\r\n  var lastId = 0;\r\n\r\n  // @function stamp(obj: Object): Number\r\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\r\n  function stamp(obj) {\r\n  \tif (!('_leaflet_id' in obj)) {\r\n  \t\tobj['_leaflet_id'] = ++lastId;\r\n  \t}\r\n  \treturn obj._leaflet_id;\r\n  }\r\n\r\n  // @function throttle(fn: Function, time: Number, context: Object): Function\r\n  // Returns a function which executes function `fn` with the given scope `context`\r\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\r\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\r\n  // received by the bound function will be any arguments passed when binding the\r\n  // function, followed by any arguments passed when invoking the bound function.\r\n  // Has an `L.throttle` shortcut.\r\n  function throttle(fn, time, context) {\r\n  \tvar lock, args, wrapperFn, later;\r\n\r\n  \tlater = function () {\r\n  \t\t// reset lock and call if queued\r\n  \t\tlock = false;\r\n  \t\tif (args) {\r\n  \t\t\twrapperFn.apply(context, args);\r\n  \t\t\targs = false;\r\n  \t\t}\r\n  \t};\r\n\r\n  \twrapperFn = function () {\r\n  \t\tif (lock) {\r\n  \t\t\t// called too soon, queue to call later\r\n  \t\t\targs = arguments;\r\n\r\n  \t\t} else {\r\n  \t\t\t// call and lock until later\r\n  \t\t\tfn.apply(context, arguments);\r\n  \t\t\tsetTimeout(later, time);\r\n  \t\t\tlock = true;\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn wrapperFn;\r\n  }\r\n\r\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\r\n  // Returns the number `num` modulo `range` in such a way so it lies within\r\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\r\n  // `range[1]` unless `includeMax` is set to `true`.\r\n  function wrapNum(x, range, includeMax) {\r\n  \tvar max = range[1],\r\n  \t    min = range[0],\r\n  \t    d = max - min;\r\n  \treturn x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n  }\r\n\r\n  // @function falseFn(): Function\r\n  // Returns a function which always returns `false`.\r\n  function falseFn() { return false; }\r\n\r\n  // @function formatNum(num: Number, precision?: Number|false): Number\r\n  // Returns the number `num` rounded with specified `precision`.\r\n  // The default `precision` value is 6 decimal places.\r\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\r\n  function formatNum(num, precision) {\r\n  \tif (precision === false) { return num; }\r\n  \tvar pow = Math.pow(10, precision === undefined ? 6 : precision);\r\n  \treturn Math.round(num * pow) / pow;\r\n  }\r\n\r\n  // @function trim(str: String): String\r\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\r\n  function trim(str) {\r\n  \treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n  }\r\n\r\n  // @function splitWords(str: String): String[]\r\n  // Trims and splits the string on whitespace and returns the array of parts.\r\n  function splitWords(str) {\r\n  \treturn trim(str).split(/\\s+/);\r\n  }\r\n\r\n  // @function setOptions(obj: Object, options: Object): Object\r\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\r\n  function setOptions(obj, options) {\r\n  \tif (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\r\n  \t\tobj.options = obj.options ? create$2(obj.options) : {};\r\n  \t}\r\n  \tfor (var i in options) {\r\n  \t\tobj.options[i] = options[i];\r\n  \t}\r\n  \treturn obj.options;\r\n  }\r\n\r\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\r\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\r\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\r\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\r\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\r\n  function getParamString(obj, existingUrl, uppercase) {\r\n  \tvar params = [];\r\n  \tfor (var i in obj) {\r\n  \t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n  \t}\r\n  \treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n  }\r\n\r\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\r\n\r\n  // @function template(str: String, data: Object): String\r\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\r\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\r\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\r\n  // data values — they will be evaluated passing `data` as an argument.\r\n  function template(str, data) {\r\n  \treturn str.replace(templateRe, function (str, key) {\r\n  \t\tvar value = data[key];\r\n\r\n  \t\tif (value === undefined) {\r\n  \t\t\tthrow new Error('No value provided for variable ' + str);\r\n\r\n  \t\t} else if (typeof value === 'function') {\r\n  \t\t\tvalue = value(data);\r\n  \t\t}\r\n  \t\treturn value;\r\n  \t});\r\n  }\r\n\r\n  // @function isArray(obj): Boolean\r\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\r\n  var isArray = Array.isArray || function (obj) {\r\n  \treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n  };\r\n\r\n  // @function indexOf(array: Array, el: Object): Number\r\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\r\n  function indexOf(array, el) {\r\n  \tfor (var i = 0; i < array.length; i++) {\r\n  \t\tif (array[i] === el) { return i; }\r\n  \t}\r\n  \treturn -1;\r\n  }\r\n\r\n  // @property emptyImageUrl: String\r\n  // Data URI string containing a base64-encoded empty GIF image.\r\n  // Used as a hack to free memory from unused images on WebKit-powered\r\n  // mobile devices (by setting image `src` to this string).\r\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\r\n\r\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n  function getPrefixed(name) {\r\n  \treturn window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n  }\r\n\r\n  var lastTime = 0;\r\n\r\n  // fallback for IE 7-8\r\n  function timeoutDefer(fn) {\r\n  \tvar time = +new Date(),\r\n  \t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n  \tlastTime = time + timeToCall;\r\n  \treturn window.setTimeout(fn, timeToCall);\r\n  }\r\n\r\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n  \t\tgetPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n\r\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\r\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\r\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\r\n  // the browser doesn't have native support for\r\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\r\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\r\n  function requestAnimFrame(fn, context, immediate) {\r\n  \tif (immediate && requestFn === timeoutDefer) {\r\n  \t\tfn.call(context);\r\n  \t} else {\r\n  \t\treturn requestFn.call(window, bind(fn, context));\r\n  \t}\r\n  }\r\n\r\n  // @function cancelAnimFrame(id: Number): undefined\r\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\r\n  function cancelAnimFrame(id) {\r\n  \tif (id) {\r\n  \t\tcancelFn.call(window, id);\r\n  \t}\r\n  }\n\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId () { return lastId; },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\r\n  // @aka L.Class\r\n\r\n  // @section\r\n  // @uninheritable\r\n\r\n  // Thanks to John Resig and Dean Edwards for inspiration!\r\n\r\n  function Class() {}\r\n\r\n  Class.extend = function (props) {\r\n\r\n  \t// @function extend(props: Object): Function\r\n  \t// [Extends the current class](#class-inheritance) given the properties to be included.\r\n  \t// Returns a Javascript function that is a class constructor (to be called with `new`).\r\n  \tvar NewClass = function () {\r\n\r\n  \t\tsetOptions(this);\r\n\r\n  \t\t// call the constructor\r\n  \t\tif (this.initialize) {\r\n  \t\t\tthis.initialize.apply(this, arguments);\r\n  \t\t}\r\n\r\n  \t\t// call all constructor hooks\r\n  \t\tthis.callInitHooks();\r\n  \t};\r\n\r\n  \tvar parentProto = NewClass.__super__ = this.prototype;\r\n\r\n  \tvar proto = create$2(parentProto);\r\n  \tproto.constructor = NewClass;\r\n\r\n  \tNewClass.prototype = proto;\r\n\r\n  \t// inherit parent's statics\r\n  \tfor (var i in this) {\r\n  \t\tif (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\r\n  \t\t\tNewClass[i] = this[i];\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// mix static properties into the class\r\n  \tif (props.statics) {\r\n  \t\textend(NewClass, props.statics);\r\n  \t}\r\n\r\n  \t// mix includes into the prototype\r\n  \tif (props.includes) {\r\n  \t\tcheckDeprecatedMixinEvents(props.includes);\r\n  \t\textend.apply(null, [proto].concat(props.includes));\r\n  \t}\r\n\r\n  \t// mix given properties into the prototype\r\n  \textend(proto, props);\r\n  \tdelete proto.statics;\r\n  \tdelete proto.includes;\r\n\r\n  \t// merge options\r\n  \tif (proto.options) {\r\n  \t\tproto.options = parentProto.options ? create$2(parentProto.options) : {};\r\n  \t\textend(proto.options, props.options);\r\n  \t}\r\n\r\n  \tproto._initHooks = [];\r\n\r\n  \t// add method for calling all hooks\r\n  \tproto.callInitHooks = function () {\r\n\r\n  \t\tif (this._initHooksCalled) { return; }\r\n\r\n  \t\tif (parentProto.callInitHooks) {\r\n  \t\t\tparentProto.callInitHooks.call(this);\r\n  \t\t}\r\n\r\n  \t\tthis._initHooksCalled = true;\r\n\r\n  \t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n  \t\t\tproto._initHooks[i].call(this);\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn NewClass;\r\n  };\r\n\r\n\r\n  // @function include(properties: Object): this\r\n  // [Includes a mixin](#class-includes) into the current class.\r\n  Class.include = function (props) {\r\n  \tvar parentOptions = this.prototype.options;\r\n  \textend(this.prototype, props);\r\n  \tif (props.options) {\r\n  \t\tthis.prototype.options = parentOptions;\r\n  \t\tthis.mergeOptions(props.options);\r\n  \t}\r\n  \treturn this;\r\n  };\r\n\r\n  // @function mergeOptions(options: Object): this\r\n  // [Merges `options`](#class-options) into the defaults of the class.\r\n  Class.mergeOptions = function (options) {\r\n  \textend(this.prototype.options, options);\r\n  \treturn this;\r\n  };\r\n\r\n  // @function addInitHook(fn: Function): this\r\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\r\n  Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n  \tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n  \tvar init = typeof fn === 'function' ? fn : function () {\r\n  \t\tthis[fn].apply(this, args);\r\n  \t};\r\n\r\n  \tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n  \tthis.prototype._initHooks.push(init);\r\n  \treturn this;\r\n  };\r\n\r\n  function checkDeprecatedMixinEvents(includes) {\r\n  \tif (typeof L === 'undefined' || !L || !L.Mixin) { return; }\r\n\r\n  \tincludes = isArray(includes) ? includes : [includes];\r\n\r\n  \tfor (var i = 0; i < includes.length; i++) {\r\n  \t\tif (includes[i] === L.Mixin.Events) {\r\n  \t\t\tconsole.warn('Deprecated include of L.Mixin.Events: ' +\r\n  \t\t\t\t'this property will be removed in future releases, ' +\r\n  \t\t\t\t'please inherit from L.Evented instead.', new Error().stack);\r\n  \t\t}\r\n  \t}\r\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\r\n\r\n  var Events = {\r\n  \t/* @method on(type: String, fn: Function, context?: Object): this\r\n  \t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method on(eventMap: Object): this\r\n  \t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  \t */\r\n  \ton: function (types, fn, context) {\r\n\r\n  \t\t// types can be a map of types/handlers\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\t// we don't process space-separated events here for performance;\r\n  \t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n  \t\t\t\tthis._on(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\t// types can be a string of space-separated words\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tthis._on(types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t/* @method off(type: String, fn?: Function, context?: Object): this\r\n  \t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off(eventMap: Object): this\r\n  \t * Removes a set of type/listener pairs.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off: this\r\n  \t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n  \t */\r\n  \toff: function (types, fn, context) {\r\n\r\n  \t\tif (!arguments.length) {\r\n  \t\t\t// clear all listeners if called without arguments\r\n  \t\t\tdelete this._events;\r\n\r\n  \t\t} else if (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\tthis._off(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tvar removeAll = arguments.length === 1;\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tif (removeAll) {\r\n  \t\t\t\t\tthis._off(types[i]);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tthis._off(types[i], fn, context);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// attach listener (without syntactic sugar now)\r\n  \t_on: function (type, fn, context) {\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tthis._events = this._events || {};\r\n\r\n  \t\t/* get/init listeners for type */\r\n  \t\tvar typeListeners = this._events[type];\r\n  \t\tif (!typeListeners) {\r\n  \t\t\ttypeListeners = [];\r\n  \t\t\tthis._events[type] = typeListeners;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\t// Less memory footprint.\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n  \t\tvar newListener = {fn: fn, ctx: context},\r\n  \t\t    listeners = typeListeners;\r\n\r\n  \t\t// check if fn already there\r\n  \t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\tif (listeners[i].fn === fn && listeners[i].ctx === context) {\r\n  \t\t\t\treturn;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tlisteners.push(newListener);\r\n  \t},\r\n\r\n  \t_off: function (type, fn, context) {\r\n  \t\tvar listeners,\r\n  \t\t    i,\r\n  \t\t    len;\r\n\r\n  \t\tif (!this._events) { return; }\r\n\r\n  \t\tlisteners = this._events[type];\r\n\r\n  \t\tif (!listeners) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (arguments.length === 1) { // remove all\r\n  \t\t\tif (this._firingCount) {\r\n  \t\t\t\t// Set all removed listeners to noop\r\n  \t\t\t\t// so they are not called if remove happens in fire\r\n  \t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tlisteners[i].fn = falseFn;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\t// clear all listeners for a type if function isn't specified\r\n  \t\t\tdelete this._events[type];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\t// find fn and remove it\r\n  \t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\tvar l = listeners[i];\r\n  \t\t\tif (l.ctx !== context) { continue; }\r\n  \t\t\tif (l.fn === fn) {\r\n  \t\t\t\tif (this._firingCount) {\r\n  \t\t\t\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n  \t\t\t\t\tl.fn = falseFn;\r\n\r\n  \t\t\t\t\t/* copy array in case events are being fired */\r\n  \t\t\t\t\tthis._events[type] = listeners = listeners.slice();\r\n  \t\t\t\t}\r\n  \t\t\t\tlisteners.splice(i, 1);\r\n\r\n  \t\t\t\treturn;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tconsole.warn('listener not found');\r\n  \t},\r\n\r\n  \t// @method fire(type: String, data?: Object, propagate?: Boolean): this\r\n  \t// Fires an event of the specified type. You can optionally provide a data\r\n  \t// object — the first argument of the listener function will contain its\r\n  \t// properties. The event can optionally be propagated to event parents.\r\n  \tfire: function (type, data, propagate) {\r\n  \t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n  \t\tvar event = extend({}, data, {\r\n  \t\t\ttype: type,\r\n  \t\t\ttarget: this,\r\n  \t\t\tsourceTarget: data && data.sourceTarget || this\r\n  \t\t});\r\n\r\n  \t\tif (this._events) {\r\n  \t\t\tvar listeners = this._events[type];\r\n\r\n  \t\t\tif (listeners) {\r\n  \t\t\t\tthis._firingCount = (this._firingCount + 1) || 1;\r\n  \t\t\t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tvar l = listeners[i];\r\n  \t\t\t\t\tl.fn.call(l.ctx || this, event);\r\n  \t\t\t\t}\r\n\r\n  \t\t\t\tthis._firingCount--;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// propagate the event to parents (set with addEventParent)\r\n  \t\t\tthis._propagateEvent(event);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method listens(type: String, propagate?: Boolean): Boolean\r\n  \t// Returns `true` if a particular event type has any listeners attached to it.\r\n  \t// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\r\n  \tlistens: function (type, propagate) {\r\n  \t\tif (typeof type !== 'string') {\r\n  \t\t\tconsole.warn('\"string\" type argument expected');\r\n  \t\t}\r\n  \t\tvar listeners = this._events && this._events[type];\r\n  \t\tif (listeners && listeners.length) { return true; }\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// also check parents for listeners if event propagates\r\n  \t\t\tfor (var id in this._eventParents) {\r\n  \t\t\t\tif (this._eventParents[id].listens(type, propagate)) { return true; }\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn false;\r\n  \t},\r\n\r\n  \t// @method once(…): this\r\n  \t// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\r\n  \tonce: function (types, fn, context) {\r\n\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\tthis.once(type, types[type], fn);\r\n  \t\t\t}\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar handler = bind(function () {\r\n  \t\t\tthis\r\n  \t\t\t    .off(types, fn, context)\r\n  \t\t\t    .off(types, handler, context);\r\n  \t\t}, this);\r\n\r\n  \t\t// add a listener that's executed once and removed after that\r\n  \t\treturn this\r\n  \t\t    .on(types, fn, context)\r\n  \t\t    .on(types, handler, context);\r\n  \t},\r\n\r\n  \t// @method addEventParent(obj: Evented): this\r\n  \t// Adds an event parent - an `Evented` that will receive propagated events\r\n  \taddEventParent: function (obj) {\r\n  \t\tthis._eventParents = this._eventParents || {};\r\n  \t\tthis._eventParents[stamp(obj)] = obj;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeEventParent(obj: Evented): this\r\n  \t// Removes an event parent, so it will stop receiving propagated events\r\n  \tremoveEventParent: function (obj) {\r\n  \t\tif (this._eventParents) {\r\n  \t\t\tdelete this._eventParents[stamp(obj)];\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_propagateEvent: function (e) {\r\n  \t\tfor (var id in this._eventParents) {\r\n  \t\t\tthis._eventParents[id].fire(e.type, extend({\r\n  \t\t\t\tlayer: e.target,\r\n  \t\t\t\tpropagatedFrom: e.target\r\n  \t\t\t}, e), true);\r\n  \t\t}\r\n  \t}\r\n  };\r\n\r\n  // aliases; we should ditch those eventually\r\n\r\n  // @method addEventListener(…): this\r\n  // Alias to [`on(…)`](#evented-on)\r\n  Events.addEventListener = Events.on;\r\n\r\n  // @method removeEventListener(…): this\r\n  // Alias to [`off(…)`](#evented-off)\r\n\r\n  // @method clearAllEventListeners(…): this\r\n  // Alias to [`off()`](#evented-off)\r\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\r\n\r\n  // @method addOneTimeEventListener(…): this\r\n  // Alias to [`once(…)`](#evented-once)\r\n  Events.addOneTimeEventListener = Events.once;\r\n\r\n  // @method fireEvent(…): this\r\n  // Alias to [`fire(…)`](#evented-fire)\r\n  Events.fireEvent = Events.fire;\r\n\r\n  // @method hasEventListeners(…): Boolean\r\n  // Alias to [`listens(…)`](#evented-listens)\r\n  Events.hasEventListeners = Events.listens;\r\n\r\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Point(x, y, round) {\r\n  \t// @property x: Number; The `x` coordinate of the point\r\n  \tthis.x = (round ? Math.round(x) : x);\r\n  \t// @property y: Number; The `y` coordinate of the point\r\n  \tthis.y = (round ? Math.round(y) : y);\r\n  }\r\n\r\n  var trunc = Math.trunc || function (v) {\r\n  \treturn v > 0 ? Math.floor(v) : Math.ceil(v);\r\n  };\r\n\r\n  Point.prototype = {\r\n\r\n  \t// @method clone(): Point\r\n  \t// Returns a copy of the current point.\r\n  \tclone: function () {\r\n  \t\treturn new Point(this.x, this.y);\r\n  \t},\r\n\r\n  \t// @method add(otherPoint: Point): Point\r\n  \t// Returns the result of addition of the current and the given points.\r\n  \tadd: function (point) {\r\n  \t\t// non-destructive, returns a new point\r\n  \t\treturn this.clone()._add(toPoint(point));\r\n  \t},\r\n\r\n  \t_add: function (point) {\r\n  \t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n  \t\tthis.x += point.x;\r\n  \t\tthis.y += point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method subtract(otherPoint: Point): Point\r\n  \t// Returns the result of subtraction of the given point from the current.\r\n  \tsubtract: function (point) {\r\n  \t\treturn this.clone()._subtract(toPoint(point));\r\n  \t},\r\n\r\n  \t_subtract: function (point) {\r\n  \t\tthis.x -= point.x;\r\n  \t\tthis.y -= point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method divideBy(num: Number): Point\r\n  \t// Returns the result of division of the current point by the given number.\r\n  \tdivideBy: function (num) {\r\n  \t\treturn this.clone()._divideBy(num);\r\n  \t},\r\n\r\n  \t_divideBy: function (num) {\r\n  \t\tthis.x /= num;\r\n  \t\tthis.y /= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method multiplyBy(num: Number): Point\r\n  \t// Returns the result of multiplication of the current point by the given number.\r\n  \tmultiplyBy: function (num) {\r\n  \t\treturn this.clone()._multiplyBy(num);\r\n  \t},\r\n\r\n  \t_multiplyBy: function (num) {\r\n  \t\tthis.x *= num;\r\n  \t\tthis.y *= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method scaleBy(scale: Point): Point\r\n  \t// Multiply each coordinate of the current point by each coordinate of\r\n  \t// `scale`. In linear algebra terms, multiply the point by the\r\n  \t// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n  \t// defined by `scale`.\r\n  \tscaleBy: function (point) {\r\n  \t\treturn new Point(this.x * point.x, this.y * point.y);\r\n  \t},\r\n\r\n  \t// @method unscaleBy(scale: Point): Point\r\n  \t// Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n  \t// each coordinate of `scale`.\r\n  \tunscaleBy: function (point) {\r\n  \t\treturn new Point(this.x / point.x, this.y / point.y);\r\n  \t},\r\n\r\n  \t// @method round(): Point\r\n  \t// Returns a copy of the current point with rounded coordinates.\r\n  \tround: function () {\r\n  \t\treturn this.clone()._round();\r\n  \t},\r\n\r\n  \t_round: function () {\r\n  \t\tthis.x = Math.round(this.x);\r\n  \t\tthis.y = Math.round(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method floor(): Point\r\n  \t// Returns a copy of the current point with floored coordinates (rounded down).\r\n  \tfloor: function () {\r\n  \t\treturn this.clone()._floor();\r\n  \t},\r\n\r\n  \t_floor: function () {\r\n  \t\tthis.x = Math.floor(this.x);\r\n  \t\tthis.y = Math.floor(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method ceil(): Point\r\n  \t// Returns a copy of the current point with ceiled coordinates (rounded up).\r\n  \tceil: function () {\r\n  \t\treturn this.clone()._ceil();\r\n  \t},\r\n\r\n  \t_ceil: function () {\r\n  \t\tthis.x = Math.ceil(this.x);\r\n  \t\tthis.y = Math.ceil(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method trunc(): Point\r\n  \t// Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n  \ttrunc: function () {\r\n  \t\treturn this.clone()._trunc();\r\n  \t},\r\n\r\n  \t_trunc: function () {\r\n  \t\tthis.x = trunc(this.x);\r\n  \t\tthis.y = trunc(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherPoint: Point): Number\r\n  \t// Returns the cartesian distance between the current and the given points.\r\n  \tdistanceTo: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\tvar x = point.x - this.x,\r\n  \t\t    y = point.y - this.y;\r\n\r\n  \t\treturn Math.sqrt(x * x + y * y);\r\n  \t},\r\n\r\n  \t// @method equals(otherPoint: Point): Boolean\r\n  \t// Returns `true` if the given point has the same coordinates.\r\n  \tequals: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn point.x === this.x &&\r\n  \t\t       point.y === this.y;\r\n  \t},\r\n\r\n  \t// @method contains(otherPoint: Point): Boolean\r\n  \t// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n  \tcontains: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n  \t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point for debugging purposes.\r\n  \ttoString: function () {\r\n  \t\treturn 'Point(' +\r\n  \t\t        formatNum(this.x) + ', ' +\r\n  \t\t        formatNum(this.y) + ')';\r\n  \t}\r\n  };\r\n\r\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\r\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Number[])\r\n  // Expects an array of the form `[x, y]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Object)\r\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\r\n  function toPoint(x, y, round) {\r\n  \tif (x instanceof Point) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (isArray(x)) {\r\n  \t\treturn new Point(x[0], x[1]);\r\n  \t}\r\n  \tif (x === undefined || x === null) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (typeof x === 'object' && 'x' in x && 'y' in x) {\r\n  \t\treturn new Point(x.x, x.y);\r\n  \t}\r\n  \treturn new Point(x, y, round);\r\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Bounds(a, b) {\r\n  \tif (!a) { return; }\r\n\r\n  \tvar points = b ? [a, b] : a;\r\n\r\n  \tfor (var i = 0, len = points.length; i < len; i++) {\r\n  \t\tthis.extend(points[i]);\r\n  \t}\r\n  }\r\n\r\n  Bounds.prototype = {\r\n  \t// @method extend(point: Point): this\r\n  \t// Extends the bounds to contain the given point.\r\n  \textend: function (point) { // (Point)\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\t// @property min: Point\r\n  \t\t// The top left corner of the rectangle.\r\n  \t\t// @property max: Point\r\n  \t\t// The bottom right corner of the rectangle.\r\n  \t\tif (!this.min && !this.max) {\r\n  \t\t\tthis.min = point.clone();\r\n  \t\t\tthis.max = point.clone();\r\n  \t\t} else {\r\n  \t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n  \t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n  \t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n  \t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getCenter(round?: Boolean): Point\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function (round) {\r\n  \t\treturn new Point(\r\n  \t\t        (this.min.x + this.max.x) / 2,\r\n  \t\t        (this.min.y + this.max.y) / 2, round);\r\n  \t},\r\n\r\n  \t// @method getBottomLeft(): Point\r\n  \t// Returns the bottom-left point of the bounds.\r\n  \tgetBottomLeft: function () {\r\n  \t\treturn new Point(this.min.x, this.max.y);\r\n  \t},\r\n\r\n  \t// @method getTopRight(): Point\r\n  \t// Returns the top-right point of the bounds.\r\n  \tgetTopRight: function () { // -> Point\r\n  \t\treturn new Point(this.max.x, this.min.y);\r\n  \t},\r\n\r\n  \t// @method getTopLeft(): Point\r\n  \t// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\r\n  \tgetTopLeft: function () {\r\n  \t\treturn this.min; // left, top\r\n  \t},\r\n\r\n  \t// @method getBottomRight(): Point\r\n  \t// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\r\n  \tgetBottomRight: function () {\r\n  \t\treturn this.max; // right, bottom\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the size of the given bounds\r\n  \tgetSize: function () {\r\n  \t\treturn this.max.subtract(this.min);\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n  \t// @alternative\r\n  \t// @method contains(point: Point): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) {\r\n  \t\tvar min, max;\r\n\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof Point) {\r\n  \t\t\tobj = toPoint(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tif (obj instanceof Bounds) {\r\n  \t\t\tmin = obj.min;\r\n  \t\t\tmax = obj.max;\r\n  \t\t} else {\r\n  \t\t\tmin = max = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (min.x >= this.min.x) &&\r\n  \t\t       (max.x <= this.max.x) &&\r\n  \t\t       (min.y >= this.min.y) &&\r\n  \t\t       (max.y <= this.max.y);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds\r\n  \t// intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n  \t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n  \t\treturn xIntersects && yIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds\r\n  \t// overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xOverlaps = (max2.x > min.x) && (min2.x < max.x),\r\n  \t\t    yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n\r\n  \t\treturn xOverlaps && yOverlaps;\r\n  \t},\r\n\r\n  \tisValid: function () {\r\n  \t\treturn !!(this.min && this.max);\r\n  \t}\r\n  };\r\n\r\n\r\n  // @factory L.bounds(corner1: Point, corner2: Point)\r\n  // Creates a Bounds object from two corners coordinate pairs.\r\n  // @alternative\r\n  // @factory L.bounds(points: Point[])\r\n  // Creates a Bounds object from the given array of points.\r\n  function toBounds(a, b) {\r\n  \tif (!a || a instanceof Bounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new Bounds(a, b);\r\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])\r\n  \tif (!corner1) { return; }\r\n\r\n  \tvar latlngs = corner2 ? [corner1, corner2] : corner1;\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\tthis.extend(latlngs[i]);\r\n  \t}\r\n  }\r\n\r\n  LatLngBounds.prototype = {\r\n\r\n  \t// @method extend(latlng: LatLng): this\r\n  \t// Extend the bounds to contain the given point\r\n\r\n  \t// @alternative\r\n  \t// @method extend(otherBounds: LatLngBounds): this\r\n  \t// Extend the bounds to contain the given bounds\r\n  \textend: function (obj) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLng) {\r\n  \t\t\tsw2 = obj;\r\n  \t\t\tne2 = obj;\r\n\r\n  \t\t} else if (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj._southWest;\r\n  \t\t\tne2 = obj._northEast;\r\n\r\n  \t\t\tif (!sw2 || !ne2) { return this; }\r\n\r\n  \t\t} else {\r\n  \t\t\treturn obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\r\n  \t\t}\r\n\r\n  \t\tif (!sw && !ne) {\r\n  \t\t\tthis._southWest = new LatLng(sw2.lat, sw2.lng);\r\n  \t\t\tthis._northEast = new LatLng(ne2.lat, ne2.lng);\r\n  \t\t} else {\r\n  \t\t\tsw.lat = Math.min(sw2.lat, sw.lat);\r\n  \t\t\tsw.lng = Math.min(sw2.lng, sw.lng);\r\n  \t\t\tne.lat = Math.max(ne2.lat, ne.lat);\r\n  \t\t\tne.lng = Math.max(ne2.lng, ne.lng);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method pad(bufferRatio: Number): LatLngBounds\r\n  \t// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n  \t// For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n  \t// Negative values will retract the bounds.\r\n  \tpad: function (bufferRatio) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n  \t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n  \t\treturn new LatLngBounds(\r\n  \t\t        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n  \t\t        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function () {\r\n  \t\treturn new LatLng(\r\n  \t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n  \t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n  \t},\r\n\r\n  \t// @method getSouthWest(): LatLng\r\n  \t// Returns the south-west point of the bounds.\r\n  \tgetSouthWest: function () {\r\n  \t\treturn this._southWest;\r\n  \t},\r\n\r\n  \t// @method getNorthEast(): LatLng\r\n  \t// Returns the north-east point of the bounds.\r\n  \tgetNorthEast: function () {\r\n  \t\treturn this._northEast;\r\n  \t},\r\n\r\n  \t// @method getNorthWest(): LatLng\r\n  \t// Returns the north-west point of the bounds.\r\n  \tgetNorthWest: function () {\r\n  \t\treturn new LatLng(this.getNorth(), this.getWest());\r\n  \t},\r\n\r\n  \t// @method getSouthEast(): LatLng\r\n  \t// Returns the south-east point of the bounds.\r\n  \tgetSouthEast: function () {\r\n  \t\treturn new LatLng(this.getSouth(), this.getEast());\r\n  \t},\r\n\r\n  \t// @method getWest(): Number\r\n  \t// Returns the west longitude of the bounds\r\n  \tgetWest: function () {\r\n  \t\treturn this._southWest.lng;\r\n  \t},\r\n\r\n  \t// @method getSouth(): Number\r\n  \t// Returns the south latitude of the bounds\r\n  \tgetSouth: function () {\r\n  \t\treturn this._southWest.lat;\r\n  \t},\r\n\r\n  \t// @method getEast(): Number\r\n  \t// Returns the east longitude of the bounds\r\n  \tgetEast: function () {\r\n  \t\treturn this._northEast.lng;\r\n  \t},\r\n\r\n  \t// @method getNorth(): Number\r\n  \t// Returns the north latitude of the bounds\r\n  \tgetNorth: function () {\r\n  \t\treturn this._northEast.lat;\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n\r\n  \t// @alternative\r\n  \t// @method contains (latlng: LatLng): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\r\n  \t\t\tobj = toLatLng(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toLatLngBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj.getSouthWest();\r\n  \t\t\tne2 = obj.getNorthEast();\r\n  \t\t} else {\r\n  \t\t\tsw2 = ne2 = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n  \t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n  \t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n  \t\treturn latIntersects && lngIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),\r\n  \t\t    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n\r\n  \t\treturn latOverlaps && lngOverlaps;\r\n  \t},\r\n\r\n  \t// @method toBBoxString(): String\r\n  \t// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\r\n  \ttoBBoxString: function () {\r\n  \t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n  \t},\r\n\r\n  \t// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (bounds, maxMargin) {\r\n  \t\tif (!bounds) { return false; }\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\treturn this._southWest.equals(bounds.getSouthWest(), maxMargin) &&\r\n  \t\t       this._northEast.equals(bounds.getNorthEast(), maxMargin);\r\n  \t},\r\n\r\n  \t// @method isValid(): Boolean\r\n  \t// Returns `true` if the bounds are properly initialized.\r\n  \tisValid: function () {\r\n  \t\treturn !!(this._southWest && this._northEast);\r\n  \t}\r\n  };\r\n\r\n  // TODO International date line?\r\n\r\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\r\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\r\n\r\n  // @alternative\r\n  // @factory L.latLngBounds(latlngs: LatLng[])\r\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\r\n  function toLatLngBounds(a, b) {\r\n  \tif (a instanceof LatLngBounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new LatLngBounds(a, b);\r\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLng(lat, lng, alt) {\r\n  \tif (isNaN(lat) || isNaN(lng)) {\r\n  \t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n  \t}\r\n\r\n  \t// @property lat: Number\r\n  \t// Latitude in degrees\r\n  \tthis.lat = +lat;\r\n\r\n  \t// @property lng: Number\r\n  \t// Longitude in degrees\r\n  \tthis.lng = +lng;\r\n\r\n  \t// @property alt: Number\r\n  \t// Altitude in meters (optional)\r\n  \tif (alt !== undefined) {\r\n  \t\tthis.alt = +alt;\r\n  \t}\r\n  }\r\n\r\n  LatLng.prototype = {\r\n  \t// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (obj, maxMargin) {\r\n  \t\tif (!obj) { return false; }\r\n\r\n  \t\tobj = toLatLng(obj);\r\n\r\n  \t\tvar margin = Math.max(\r\n  \t\t        Math.abs(this.lat - obj.lat),\r\n  \t\t        Math.abs(this.lng - obj.lng));\r\n\r\n  \t\treturn margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point (for debugging purposes).\r\n  \ttoString: function (precision) {\r\n  \t\treturn 'LatLng(' +\r\n  \t\t        formatNum(this.lat, precision) + ', ' +\r\n  \t\t        formatNum(this.lng, precision) + ')';\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherLatLng: LatLng): Number\r\n  \t// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\r\n  \tdistanceTo: function (other) {\r\n  \t\treturn Earth.distance(this, toLatLng(other));\r\n  \t},\r\n\r\n  \t// @method wrap(): LatLng\r\n  \t// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\r\n  \twrap: function () {\r\n  \t\treturn Earth.wrapLatLng(this);\r\n  \t},\r\n\r\n  \t// @method toBounds(sizeInMeters: Number): LatLngBounds\r\n  \t// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\r\n  \ttoBounds: function (sizeInMeters) {\r\n  \t\tvar latAccuracy = 180 * sizeInMeters / 40075017,\r\n  \t\t    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n\r\n  \t\treturn toLatLngBounds(\r\n  \t\t        [this.lat - latAccuracy, this.lng - lngAccuracy],\r\n  \t\t        [this.lat + latAccuracy, this.lng + lngAccuracy]);\r\n  \t},\r\n\r\n  \tclone: function () {\r\n  \t\treturn new LatLng(this.lat, this.lng, this.alt);\r\n  \t}\r\n  };\r\n\r\n\r\n\r\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\r\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Array): LatLng\r\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Object): LatLng\r\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\r\n\r\n  function toLatLng(a, b, c) {\r\n  \tif (a instanceof LatLng) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (isArray(a) && typeof a[0] !== 'object') {\r\n  \t\tif (a.length === 3) {\r\n  \t\t\treturn new LatLng(a[0], a[1], a[2]);\r\n  \t\t}\r\n  \t\tif (a.length === 2) {\r\n  \t\t\treturn new LatLng(a[0], a[1]);\r\n  \t\t}\r\n  \t\treturn null;\r\n  \t}\r\n  \tif (a === undefined || a === null) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (typeof a === 'object' && 'lat' in a) {\r\n  \t\treturn new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\r\n  \t}\r\n  \tif (b === undefined) {\r\n  \t\treturn null;\r\n  \t}\r\n  \treturn new LatLng(a, b, c);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\r\n\r\n  var CRS = {\r\n  \t// @method latLngToPoint(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects geographical coordinates into pixel coordinates for a given zoom.\r\n  \tlatLngToPoint: function (latlng, zoom) {\r\n  \t\tvar projectedPoint = this.projection.project(latlng),\r\n  \t\t    scale = this.scale(zoom);\r\n\r\n  \t\treturn this.transformation._transform(projectedPoint, scale);\r\n  \t},\r\n\r\n  \t// @method pointToLatLng(point: Point, zoom: Number): LatLng\r\n  \t// The inverse of `latLngToPoint`. Projects pixel coordinates on a given\r\n  \t// zoom into geographical coordinates.\r\n  \tpointToLatLng: function (point, zoom) {\r\n  \t\tvar scale = this.scale(zoom),\r\n  \t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n  \t\treturn this.projection.unproject(untransformedPoint);\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng): Point\r\n  \t// Projects geographical coordinates into coordinates in units accepted for\r\n  \t// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\r\n  \tproject: function (latlng) {\r\n  \t\treturn this.projection.project(latlng);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point): LatLng\r\n  \t// Given a projected coordinate returns the corresponding LatLng.\r\n  \t// The inverse of `project`.\r\n  \tunproject: function (point) {\r\n  \t\treturn this.projection.unproject(point);\r\n  \t},\r\n\r\n  \t// @method scale(zoom: Number): Number\r\n  \t// Returns the scale used when transforming projected coordinates into\r\n  \t// pixel coordinates for a particular zoom. For example, it returns\r\n  \t// `256 * 2^zoom` for Mercator-based CRS.\r\n  \tscale: function (zoom) {\r\n  \t\treturn 256 * Math.pow(2, zoom);\r\n  \t},\r\n\r\n  \t// @method zoom(scale: Number): Number\r\n  \t// Inverse of `scale()`, returns the zoom level corresponding to a scale\r\n  \t// factor of `scale`.\r\n  \tzoom: function (scale) {\r\n  \t\treturn Math.log(scale / 256) / Math.LN2;\r\n  \t},\r\n\r\n  \t// @method getProjectedBounds(zoom: Number): Bounds\r\n  \t// Returns the projection's bounds scaled and transformed for the provided `zoom`.\r\n  \tgetProjectedBounds: function (zoom) {\r\n  \t\tif (this.infinite) { return null; }\r\n\r\n  \t\tvar b = this.projection.bounds,\r\n  \t\t    s = this.scale(zoom),\r\n  \t\t    min = this.transformation.transform(b.min, s),\r\n  \t\t    max = this.transformation.transform(b.max, s);\r\n\r\n  \t\treturn new Bounds(min, max);\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates.\r\n\r\n  \t// @property code: String\r\n  \t// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\r\n  \t//\r\n  \t// @property wrapLng: Number[]\r\n  \t// An array of two numbers defining whether the longitude (horizontal) coordinate\r\n  \t// axis wraps around a given range and how. Defaults to `[-180, 180]` in most\r\n  \t// geographical CRSs. If `undefined`, the longitude axis does not wrap around.\r\n  \t//\r\n  \t// @property wrapLat: Number[]\r\n  \t// Like `wrapLng`, but for the latitude (vertical) axis.\r\n\r\n  \t// wrapLng: [min, max],\r\n  \t// wrapLat: [min, max],\r\n\r\n  \t// @property infinite: Boolean\r\n  \t// If true, the coordinate space will be unbounded (infinite in both axes)\r\n  \tinfinite: false,\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where lat and lng has been wrapped according to the\r\n  \t// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\tvar lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n  \t\t    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n  \t\t    alt = latlng.alt;\r\n\r\n  \t\treturn new LatLng(lat, lng, alt);\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring\r\n  \t// that its center is within the CRS's bounds.\r\n  \t// Only accepts actual `L.LatLngBounds` instances, not arrays.\r\n  \twrapLatLngBounds: function (bounds) {\r\n  \t\tvar center = bounds.getCenter(),\r\n  \t\t    newCenter = this.wrapLatLng(center),\r\n  \t\t    latShift = center.lat - newCenter.lat,\r\n  \t\t    lngShift = center.lng - newCenter.lng;\r\n\r\n  \t\tif (latShift === 0 && lngShift === 0) {\r\n  \t\t\treturn bounds;\r\n  \t\t}\r\n\r\n  \t\tvar sw = bounds.getSouthWest(),\r\n  \t\t    ne = bounds.getNorthEast(),\r\n  \t\t    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\r\n  \t\t    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\r\n\r\n  \t\treturn new LatLngBounds(newSw, newNe);\r\n  \t}\r\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n  \twrapLng: [-180, 180],\n\n  \t// Mean Earth Radius, as recommended for use by\n  \t// the International Union of Geodesy and Geophysics,\n  \t// see https://rosettacode.org/wiki/Haversine_formula\n  \tR: 6371000,\n\n  \t// distance between two geographical points using spherical law of cosines approximation\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar rad = Math.PI / 180,\n  \t\t    lat1 = latlng1.lat * rad,\n  \t\t    lat2 = latlng2.lat * rad,\n  \t\t    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n  \t\t    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n  \t\t    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n  \t\t    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  \t\treturn this.R * c;\n  \t}\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\r\n\r\n  var earthRadius = 6378137;\r\n\r\n  var SphericalMercator = {\r\n\r\n  \tR: earthRadius,\r\n  \tMAX_LATITUDE: 85.0511287798,\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    max = this.MAX_LATITUDE,\r\n  \t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n  \t\t    sin = Math.sin(lat * d);\r\n\r\n  \t\treturn new Point(\r\n  \t\t\tthis.R * latlng.lng * d,\r\n  \t\t\tthis.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI;\r\n\r\n  \t\treturn new LatLng(\r\n  \t\t\t(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\r\n  \t\t\tpoint.x * d / this.R);\r\n  \t},\r\n\r\n  \tbounds: (function () {\r\n  \t\tvar d = earthRadius * Math.PI;\r\n  \t\treturn new Bounds([-d, -d], [d, d]);\r\n  \t})()\r\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\r\n\r\n\r\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Creates a `Transformation` object with the given coefficients.\r\n  function Transformation(a, b, c, d) {\r\n  \tif (isArray(a)) {\r\n  \t\t// use array properties\r\n  \t\tthis._a = a[0];\r\n  \t\tthis._b = a[1];\r\n  \t\tthis._c = a[2];\r\n  \t\tthis._d = a[3];\r\n  \t\treturn;\r\n  \t}\r\n  \tthis._a = a;\r\n  \tthis._b = b;\r\n  \tthis._c = c;\r\n  \tthis._d = d;\r\n  }\r\n\r\n  Transformation.prototype = {\r\n  \t// @method transform(point: Point, scale?: Number): Point\r\n  \t// Returns a transformed point, optionally multiplied by the given scale.\r\n  \t// Only accepts actual `L.Point` instances, not arrays.\r\n  \ttransform: function (point, scale) { // (Point, Number) -> Point\r\n  \t\treturn this._transform(point.clone(), scale);\r\n  \t},\r\n\r\n  \t// destructive transform (faster)\r\n  \t_transform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\tpoint.x = scale * (this._a * point.x + this._b);\r\n  \t\tpoint.y = scale * (this._c * point.y + this._d);\r\n  \t\treturn point;\r\n  \t},\r\n\r\n  \t// @method untransform(point: Point, scale?: Number): Point\r\n  \t// Returns the reverse transformation of the given point, optionally divided\r\n  \t// by the given scale. Only accepts actual `L.Point` instances, not arrays.\r\n  \tuntransform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\treturn new Point(\r\n  \t\t        (point.x / scale - this._b) / this._a,\r\n  \t\t        (point.y / scale - this._d) / this._c);\r\n  \t}\r\n  };\r\n\r\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n\r\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Instantiates a Transformation object with the given coefficients.\r\n\r\n  // @alternative\r\n  // @factory L.transformation(coefficients: Array): Transformation\r\n  // Expects an coefficients array of the form\r\n  // `[a: Number, b: Number, c: Number, d: Number]`.\r\n\r\n  function toTransformation(a, b, c, d) {\r\n  \treturn new Transformation(a, b, c, d);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\r\n\r\n  var EPSG3857 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3857',\r\n  \tprojection: SphericalMercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * SphericalMercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\r\n\r\n  var EPSG900913 = extend({}, EPSG3857, {\r\n  \tcode: 'EPSG:900913'\r\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n  \treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n  \tvar str = '',\n  \ti, j, len, len2, points, p;\n\n  \tfor (i = 0, len = rings.length; i < len; i++) {\n  \t\tpoints = rings[i];\n\n  \t\tfor (j = 0, len2 = points.length; j < len2; j++) {\n  \t\t\tp = points[j];\n  \t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n  \t\t}\n\n  \t\t// closes the ring for polygons; \"x\" is VML syntax\n  \t\tstr += closed ? (Browser.svg ? 'z' : 'x') : '';\n  \t}\n\n  \t// SVG complains about empty path strings\n  \treturn str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\r\n\r\n  var style = document.documentElement.style;\r\n\r\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\r\n  var ie = 'ActiveXObject' in window;\r\n\r\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\r\n  var ielt9 = ie && !document.addEventListener;\r\n\r\n  // @property edge: Boolean; `true` for the Edge web browser.\r\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\r\n\r\n  // @property webkit: Boolean;\r\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\r\n  var webkit = userAgentContains('webkit');\r\n\r\n  // @property android: Boolean\r\n  // **Deprecated.** `true` for any browser running on an Android platform.\r\n  var android = userAgentContains('android');\r\n\r\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\r\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\r\n\r\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\r\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\r\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\r\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\r\n\r\n  // @property opera: Boolean; `true` for the Opera browser\r\n  var opera = !!window.opera;\r\n\r\n  // @property chrome: Boolean; `true` for the Chrome browser.\r\n  var chrome = !edge && userAgentContains('chrome');\r\n\r\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\r\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\r\n\r\n  // @property safari: Boolean; `true` for the Safari browser.\r\n  var safari = !chrome && userAgentContains('safari');\r\n\r\n  var phantom = userAgentContains('phantom');\r\n\r\n  // @property opera12: Boolean\r\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\r\n  var opera12 = 'OTransition' in style;\r\n\r\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\r\n  var win = navigator.platform.indexOf('Win') === 0;\r\n\r\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\r\n  var ie3d = ie && ('transition' in style);\r\n\r\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\r\n  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;\r\n\r\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\r\n  var gecko3d = 'MozPerspective' in style;\r\n\r\n  // @property any3d: Boolean\r\n  // `true` for all browsers supporting CSS transforms.\r\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\r\n\r\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\r\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\r\n\r\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\r\n  var mobileWebkit = mobile && webkit;\r\n\r\n  // @property mobileWebkit3d: Boolean\r\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\r\n  var mobileWebkit3d = mobile && webkit3d;\r\n\r\n  // @property msPointer: Boolean\r\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\r\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\r\n\r\n  // @property pointer: Boolean\r\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\r\n  var pointer = !!(window.PointerEvent || msPointer);\r\n\r\n  // @property touchNative: Boolean\r\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\r\n  // **This does not necessarily mean** that the browser is running in a computer with\r\n  // a touchscreen, it only means that the browser is capable of understanding\r\n  // touch events.\r\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\r\n\r\n  // @property touch: Boolean\r\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\r\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\r\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\r\n\r\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\r\n  var mobileOpera = mobile && opera;\r\n\r\n  // @property mobileGecko: Boolean\r\n  // `true` for gecko-based browsers running in a mobile device.\r\n  var mobileGecko = mobile && gecko;\r\n\r\n  // @property retina: Boolean\r\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\r\n  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;\r\n\r\n  // @property passiveEvents: Boolean\r\n  // `true` for browsers that support passive events.\r\n  var passiveEvents = (function () {\r\n  \tvar supportsPassiveOption = false;\r\n  \ttry {\r\n  \t\tvar opts = Object.defineProperty({}, 'passive', {\r\n  \t\t\tget: function () { // eslint-disable-line getter-return\r\n  \t\t\t\tsupportsPassiveOption = true;\r\n  \t\t\t}\r\n  \t\t});\r\n  \t\twindow.addEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t\twindow.removeEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t} catch (e) {\r\n  \t\t// Errors can safely be ignored since this is only a browser support test.\r\n  \t}\r\n  \treturn supportsPassiveOption;\r\n  }());\r\n\r\n  // @property canvas: Boolean\r\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\r\n  var canvas$1 = (function () {\r\n  \treturn !!document.createElement('canvas').getContext;\r\n  }());\r\n\r\n  // @property svg: Boolean\r\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\r\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\r\n\r\n  var inlineSvg = !!svg$1 && (function () {\r\n  \tvar div = document.createElement('div');\r\n  \tdiv.innerHTML = '<svg/>';\r\n  \treturn (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\r\n  })();\r\n\r\n  // @property vml: Boolean\r\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\r\n  var vml = !svg$1 && (function () {\r\n  \ttry {\r\n  \t\tvar div = document.createElement('div');\r\n  \t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n  \t\tvar shape = div.firstChild;\r\n  \t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n  \t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n  \t} catch (e) {\r\n  \t\treturn false;\r\n  \t}\r\n  }());\r\n\r\n  function userAgentContains(str) {\r\n  \treturn navigator.userAgent.toLowerCase().indexOf(str) >= 0;\r\n  }\r\n\r\n\r\n  var Browser = {\r\n  \tie: ie,\r\n  \tielt9: ielt9,\r\n  \tedge: edge,\r\n  \twebkit: webkit,\r\n  \tandroid: android,\r\n  \tandroid23: android23,\r\n  \tandroidStock: androidStock,\r\n  \topera: opera,\r\n  \tchrome: chrome,\r\n  \tgecko: gecko,\r\n  \tsafari: safari,\r\n  \tphantom: phantom,\r\n  \topera12: opera12,\r\n  \twin: win,\r\n  \tie3d: ie3d,\r\n  \twebkit3d: webkit3d,\r\n  \tgecko3d: gecko3d,\r\n  \tany3d: any3d,\r\n  \tmobile: mobile,\r\n  \tmobileWebkit: mobileWebkit,\r\n  \tmobileWebkit3d: mobileWebkit3d,\r\n  \tmsPointer: msPointer,\r\n  \tpointer: pointer,\r\n  \ttouch: touch,\r\n  \ttouchNative: touchNative,\r\n  \tmobileOpera: mobileOpera,\r\n  \tmobileGecko: mobileGecko,\r\n  \tretina: retina,\r\n  \tpassiveEvents: passiveEvents,\r\n  \tcanvas: canvas$1,\r\n  \tsvg: svg$1,\r\n  \tvml: vml,\r\n  \tinlineSvg: inlineSvg\r\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';\n  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';\n  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n  \ttouchstart  : POINTER_DOWN,\n  \ttouchmove   : POINTER_MOVE,\n  \ttouchend    : POINTER_UP,\n  \ttouchcancel : POINTER_CANCEL\n  };\n  var handle = {\n  \ttouchstart  : _onPointerStart,\n  \ttouchmove   : _handlePointer,\n  \ttouchend    : _handlePointer,\n  \ttouchcancel : _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n  \tif (type === 'touchstart') {\n  \t\t_addPointerDocListener();\n  \t}\n  \tif (!handle[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn L.Util.falseFn;\n  \t}\n  \thandler = handle[type].bind(this, handler);\n  \tobj.addEventListener(pEvent[type], handler, false);\n  \treturn handler;\n  }\n\n  function removePointerListener(obj, type, handler) {\n  \tif (!pEvent[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn;\n  \t}\n  \tobj.removeEventListener(pEvent[type], handler, false);\n  }\n\n  function _globalPointerDown(e) {\n  \t_pointers[e.pointerId] = e;\n  }\n\n  function _globalPointerMove(e) {\n  \tif (_pointers[e.pointerId]) {\n  \t\t_pointers[e.pointerId] = e;\n  \t}\n  }\n\n  function _globalPointerUp(e) {\n  \tdelete _pointers[e.pointerId];\n  }\n\n  function _addPointerDocListener() {\n  \t// need to keep track of what pointers and how many are active to provide e.touches emulation\n  \tif (!_pointerDocListener) {\n  \t\t// we listen document as any drags that end by moving the touch off the screen get fired there\n  \t\tdocument.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n  \t\tdocument.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n  \t\tdocument.addEventListener(POINTER_UP, _globalPointerUp, true);\n  \t\tdocument.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n\n  \t\t_pointerDocListener = true;\n  \t}\n  }\n\n  function _handlePointer(handler, e) {\n  \tif (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }\n\n  \te.touches = [];\n  \tfor (var i in _pointers) {\n  \t\te.touches.push(_pointers[i]);\n  \t}\n  \te.changedTouches = [e];\n\n  \thandler(e);\n  }\n\n  function _onPointerStart(handler, e) {\n  \t// IE10 specific: MsTouch needs preventDefault. See #2000\n  \tif (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n  \t\tpreventDefault(e);\n  \t}\n  \t_handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\r\n\r\n  function makeDblclick(event) {\r\n  \t// in modern browsers `type` cannot be just overridden:\r\n  \t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\r\n  \tvar newEvent = {},\r\n  \t    prop, i;\r\n  \tfor (i in event) {\r\n  \t\tprop = event[i];\r\n  \t\tnewEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\r\n  \t}\r\n  \tevent = newEvent;\r\n  \tnewEvent.type = 'dblclick';\r\n  \tnewEvent.detail = 2;\r\n  \tnewEvent.isTrusted = false;\r\n  \tnewEvent._simulated = true; // for debug purposes\r\n  \treturn newEvent;\r\n  }\r\n\r\n  var delay = 200;\r\n  function addDoubleTapListener(obj, handler) {\r\n  \t// Most browsers handle double tap natively\r\n  \tobj.addEventListener('dblclick', handler);\r\n\r\n  \t// On some platforms the browser doesn't fire native dblclicks for touch events.\r\n  \t// It seems that in all such cases `detail` property of `click` event is always `1`.\r\n  \t// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\r\n  \tvar last = 0,\r\n  \t    detail;\r\n  \tfunction simDblclick(e) {\r\n  \t\tif (e.detail !== 1) {\r\n  \t\t\tdetail = e.detail; // keep in sync to avoid false dblclick in some cases\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (e.pointerType === 'mouse' ||\r\n  \t\t\t(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {\r\n\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar now = Date.now();\r\n  \t\tif (now - last <= delay) {\r\n  \t\t\tdetail++;\r\n  \t\t\tif (detail === 2) {\r\n  \t\t\t\thandler(makeDblclick(e));\r\n  \t\t\t}\r\n  \t\t} else {\r\n  \t\t\tdetail = 1;\r\n  \t\t}\r\n  \t\tlast = now;\r\n  \t}\r\n\r\n  \tobj.addEventListener('click', simDblclick);\r\n\r\n  \treturn {\r\n  \t\tdblclick: handler,\r\n  \t\tsimDblclick: simDblclick\r\n  \t};\r\n  }\r\n\r\n  function removeDoubleTapListener(obj, handlers) {\r\n  \tobj.removeEventListener('dblclick', handlers.dblclick);\r\n  \tobj.removeEventListener('click', handlers.simDblclick);\r\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\r\n\r\n\r\n  // @property TRANSFORM: String\r\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\r\n  var TRANSFORM = testProp(\r\n  \t['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\n  // @property TRANSITION: String\r\n  // Vendor-prefixed transition style name.\r\n  var TRANSITION = testProp(\r\n  \t['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\n  // @property TRANSITION_END: String\r\n  // Vendor-prefixed transitionend event name.\r\n  var TRANSITION_END =\r\n  \tTRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\r\n\r\n\r\n  // @function get(id: String|HTMLElement): HTMLElement\r\n  // Returns an element given its DOM id, or returns the element itself\r\n  // if it was passed directly.\r\n  function get(id) {\r\n  \treturn typeof id === 'string' ? document.getElementById(id) : id;\r\n  }\r\n\r\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\r\n  // Returns the value for a certain style attribute on an element,\r\n  // including computed values or values set through CSS.\r\n  function getStyle(el, style) {\r\n  \tvar value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n\r\n  \tif ((!value || value === 'auto') && document.defaultView) {\r\n  \t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n  \t\tvalue = css ? css[style] : null;\r\n  \t}\r\n  \treturn value === 'auto' ? null : value;\r\n  }\r\n\r\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\r\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\r\n  function create$1(tagName, className, container) {\r\n  \tvar el = document.createElement(tagName);\r\n  \tel.className = className || '';\r\n\r\n  \tif (container) {\r\n  \t\tcontainer.appendChild(el);\r\n  \t}\r\n  \treturn el;\r\n  }\r\n\r\n  // @function remove(el: HTMLElement)\r\n  // Removes `el` from its parent element\r\n  function remove(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent) {\r\n  \t\tparent.removeChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function empty(el: HTMLElement)\r\n  // Removes all of `el`'s children elements from `el`\r\n  function empty(el) {\r\n  \twhile (el.firstChild) {\r\n  \t\tel.removeChild(el.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function toFront(el: HTMLElement)\r\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\r\n  function toFront(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.lastChild !== el) {\r\n  \t\tparent.appendChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function toBack(el: HTMLElement)\r\n  // Makes `el` the first child of its parent, so it renders behind the other children.\r\n  function toBack(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.firstChild !== el) {\r\n  \t\tparent.insertBefore(el, parent.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function hasClass(el: HTMLElement, name: String): Boolean\r\n  // Returns `true` if the element's class attribute contains `name`.\r\n  function hasClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\treturn el.classList.contains(name);\r\n  \t}\r\n  \tvar className = getClass(el);\r\n  \treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n  }\r\n\r\n  // @function addClass(el: HTMLElement, name: String)\r\n  // Adds `name` to the element's class attribute.\r\n  function addClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tvar classes = splitWords(name);\r\n  \t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n  \t\t\tel.classList.add(classes[i]);\r\n  \t\t}\r\n  \t} else if (!hasClass(el, name)) {\r\n  \t\tvar className = getClass(el);\r\n  \t\tsetClass(el, (className ? className + ' ' : '') + name);\r\n  \t}\r\n  }\r\n\r\n  // @function removeClass(el: HTMLElement, name: String)\r\n  // Removes `name` from the element's class attribute.\r\n  function removeClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tel.classList.remove(name);\r\n  \t} else {\r\n  \t\tsetClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n  \t}\r\n  }\r\n\r\n  // @function setClass(el: HTMLElement, name: String)\r\n  // Sets the element's class.\r\n  function setClass(el, name) {\r\n  \tif (el.className.baseVal === undefined) {\r\n  \t\tel.className = name;\r\n  \t} else {\r\n  \t\t// in case of SVG element\r\n  \t\tel.className.baseVal = name;\r\n  \t}\r\n  }\r\n\r\n  // @function getClass(el: HTMLElement): String\r\n  // Returns the element's class.\r\n  function getClass(el) {\r\n  \t// Check if the element is an SVGElementInstance and use the correspondingElement instead\r\n  \t// (Required for linked SVG elements in IE11.)\r\n  \tif (el.correspondingElement) {\r\n  \t\tel = el.correspondingElement;\r\n  \t}\r\n  \treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n  }\r\n\r\n  // @function setOpacity(el: HTMLElement, opacity: Number)\r\n  // Set the opacity of an element (including old IE support).\r\n  // `opacity` must be a number from `0` to `1`.\r\n  function setOpacity(el, value) {\r\n  \tif ('opacity' in el.style) {\r\n  \t\tel.style.opacity = value;\r\n  \t} else if ('filter' in el.style) {\r\n  \t\t_setOpacityIE(el, value);\r\n  \t}\r\n  }\r\n\r\n  function _setOpacityIE(el, value) {\r\n  \tvar filter = false,\r\n  \t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n  \t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n  \ttry {\r\n  \t\tfilter = el.filters.item(filterName);\r\n  \t} catch (e) {\r\n  \t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n  \t\t// it isn't needed and breaks transparent pngs.\r\n  \t\tif (value === 1) { return; }\r\n  \t}\r\n\r\n  \tvalue = Math.round(value * 100);\r\n\r\n  \tif (filter) {\r\n  \t\tfilter.Enabled = (value !== 100);\r\n  \t\tfilter.Opacity = value;\r\n  \t} else {\r\n  \t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n  \t}\r\n  }\r\n\r\n  // @function testProp(props: String[]): String|false\r\n  // Goes through the array of style names and returns the first name\r\n  // that is a valid style name for an element. If no such name is found,\r\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\r\n  function testProp(props) {\r\n  \tvar style = document.documentElement.style;\r\n\r\n  \tfor (var i = 0; i < props.length; i++) {\r\n  \t\tif (props[i] in style) {\r\n  \t\t\treturn props[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn false;\r\n  }\r\n\r\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\r\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\r\n  // and optionally scaled by `scale`. Does not have an effect if the\r\n  // browser doesn't support 3D CSS transforms.\r\n  function setTransform(el, offset, scale) {\r\n  \tvar pos = offset || new Point(0, 0);\r\n\r\n  \tel.style[TRANSFORM] =\r\n  \t\t(Browser.ie3d ?\r\n  \t\t\t'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n  \t\t\t'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n  \t\t(scale ? ' scale(' + scale + ')' : '');\r\n  }\r\n\r\n  // @function setPosition(el: HTMLElement, position: Point)\r\n  // Sets the position of `el` to coordinates specified by `position`,\r\n  // using CSS translate or top/left positioning depending on the browser\r\n  // (used by Leaflet internally to position its layers).\r\n  function setPosition(el, point) {\r\n\r\n  \t/*eslint-disable */\r\n  \tel._leaflet_pos = point;\r\n  \t/* eslint-enable */\r\n\r\n  \tif (Browser.any3d) {\r\n  \t\tsetTransform(el, point);\r\n  \t} else {\r\n  \t\tel.style.left = point.x + 'px';\r\n  \t\tel.style.top = point.y + 'px';\r\n  \t}\r\n  }\r\n\r\n  // @function getPosition(el: HTMLElement): Point\r\n  // Returns the coordinates of an element previously positioned with setPosition.\r\n  function getPosition(el) {\r\n  \t// this method is only used for elements previously positioned using setPosition,\r\n  \t// so it's safe to cache the position for performance\r\n\r\n  \treturn el._leaflet_pos || new Point(0, 0);\r\n  }\r\n\r\n  // @function disableTextSelection()\r\n  // Prevents the user from generating `selectstart` DOM events, usually generated\r\n  // when the user drags the mouse through a page with text. Used internally\r\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\r\n  // the map. Affects drag interactions on the whole document.\r\n\r\n  // @function enableTextSelection()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\r\n  var disableTextSelection;\r\n  var enableTextSelection;\r\n  var _userSelect;\r\n  if ('onselectstart' in document) {\r\n  \tdisableTextSelection = function () {\r\n  \t\ton(window, 'selectstart', preventDefault);\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\toff(window, 'selectstart', preventDefault);\r\n  \t};\r\n  } else {\r\n  \tvar userSelectProperty = testProp(\r\n  \t\t['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n  \tdisableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tvar style = document.documentElement.style;\r\n  \t\t\t_userSelect = style[userSelectProperty];\r\n  \t\t\tstyle[userSelectProperty] = 'none';\r\n  \t\t}\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tdocument.documentElement.style[userSelectProperty] = _userSelect;\r\n  \t\t\t_userSelect = undefined;\r\n  \t\t}\r\n  \t};\r\n  }\r\n\r\n  // @function disableImageDrag()\r\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\r\n  // for `dragstart` DOM events, usually generated when the user drags an image.\r\n  function disableImageDrag() {\r\n  \ton(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  // @function enableImageDrag()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\r\n  function enableImageDrag() {\r\n  \toff(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  var _outlineElement, _outlineStyle;\r\n  // @function preventOutline(el: HTMLElement)\r\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\r\n  // of the element `el` invisible. Used internally by Leaflet to prevent\r\n  // focusable elements from displaying an outline when the user performs a\r\n  // drag interaction on them.\r\n  function preventOutline(element) {\r\n  \twhile (element.tabIndex === -1) {\r\n  \t\telement = element.parentNode;\r\n  \t}\r\n  \tif (!element.style) { return; }\r\n  \trestoreOutline();\r\n  \t_outlineElement = element;\r\n  \t_outlineStyle = element.style.outline;\r\n  \telement.style.outline = 'none';\r\n  \ton(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function restoreOutline()\r\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\r\n  function restoreOutline() {\r\n  \tif (!_outlineElement) { return; }\r\n  \t_outlineElement.style.outline = _outlineStyle;\r\n  \t_outlineElement = undefined;\r\n  \t_outlineStyle = undefined;\r\n  \toff(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\r\n  // Finds the closest parent node which size (width and height) is not null.\r\n  function getSizedParentNode(element) {\r\n  \tdo {\r\n  \t\telement = element.parentNode;\r\n  \t} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\r\n  \treturn element;\r\n  }\r\n\r\n  // @function getScale(el: HTMLElement): Object\r\n  // Computes the CSS scale currently applied on the element.\r\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\r\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\r\n  function getScale(element) {\r\n  \tvar rect = element.getBoundingClientRect(); // Read-only in old browsers.\r\n\r\n  \treturn {\r\n  \t\tx: rect.width / element.offsetWidth || 1,\r\n  \t\ty: rect.height / element.offsetHeight || 1,\r\n  \t\tboundingClientRect: rect\r\n  \t};\r\n  }\n\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection () { return disableTextSelection; },\n    get enableTextSelection () { return enableTextSelection; },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\r\n\r\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n\r\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Adds a listener function (`fn`) to a particular DOM event type of the\r\n  // element `el`. You can optionally specify the context of the listener\r\n  // (object the `this` keyword will point to). You can also pass several\r\n  // space-separated types (e.g. `'click dblclick'`).\r\n\r\n  // @alternative\r\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  function on(obj, types, fn, context) {\r\n\r\n  \tif (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\taddOne(obj, type, types[type], fn);\r\n  \t\t}\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\taddOne(obj, types[i], fn, context);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  var eventsKey = '_leaflet_events';\r\n\r\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Removes a previously added listener function.\r\n  // Note that if you passed a custom context to on, you must pass the same\r\n  // context to `off` in order to remove the listener.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, types: String): this\r\n  // Removes all previously added listeners of given types.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement): this\r\n  // Removes all previously added listeners from given HTMLElement\r\n  function off(obj, types, fn, context) {\r\n\r\n  \tif (arguments.length === 1) {\r\n  \t\tbatchRemove(obj);\r\n  \t\tdelete obj[eventsKey];\r\n\r\n  \t} else if (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\tremoveOne(obj, type, types[type], fn);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tif (arguments.length === 2) {\r\n  \t\t\tbatchRemove(obj, function (type) {\r\n  \t\t\t\treturn indexOf(types, type) !== -1;\r\n  \t\t\t});\r\n  \t\t} else {\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tremoveOne(obj, types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  function batchRemove(obj, filterFn) {\r\n  \tfor (var id in obj[eventsKey]) {\r\n  \t\tvar type = id.split(/\\d/)[0];\r\n  \t\tif (!filterFn || filterFn(type)) {\r\n  \t\t\tremoveOne(obj, type, null, null, id);\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  var mouseSubst = {\r\n  \tmouseenter: 'mouseover',\r\n  \tmouseleave: 'mouseout',\r\n  \twheel: !('onwheel' in window) && 'mousewheel'\r\n  };\r\n\r\n  function addOne(obj, type, fn, context) {\r\n  \tvar id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n\r\n  \tif (obj[eventsKey] && obj[eventsKey][id]) { return this; }\r\n\r\n  \tvar handler = function (e) {\r\n  \t\treturn fn.call(context || obj, e || window.event);\r\n  \t};\r\n\r\n  \tvar originalHandler = handler;\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\t// Needs DomEvent.Pointer.js\r\n  \t\thandler = addPointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\thandler = addDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('addEventListener' in obj) {\r\n\r\n  \t\tif (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {\r\n  \t\t\tobj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);\r\n\r\n  \t\t} else if (type === 'mouseenter' || type === 'mouseleave') {\r\n  \t\t\thandler = function (e) {\r\n  \t\t\t\te = e || window.event;\r\n  \t\t\t\tif (isExternalTarget(obj, e)) {\r\n  \t\t\t\t\toriginalHandler(e);\r\n  \t\t\t\t}\r\n  \t\t\t};\r\n  \t\t\tobj.addEventListener(mouseSubst[type], handler, false);\r\n\r\n  \t\t} else {\r\n  \t\t\tobj.addEventListener(type, originalHandler, false);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\tobj.attachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey] = obj[eventsKey] || {};\r\n  \tobj[eventsKey][id] = handler;\r\n  }\r\n\r\n  function removeOne(obj, type, fn, context, id) {\r\n  \tid = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n  \tvar handler = obj[eventsKey] && obj[eventsKey][id];\r\n\r\n  \tif (!handler) { return this; }\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\tremovePointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\tremoveDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('removeEventListener' in obj) {\r\n\r\n  \t\tobj.removeEventListener(mouseSubst[type] || type, handler, false);\r\n\r\n  \t} else {\r\n  \t\tobj.detachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey][id] = null;\r\n  }\r\n\r\n  // @function stopPropagation(ev: DOMEvent): this\r\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\r\n  // ```js\r\n  // L.DomEvent.on(div, 'click', function (ev) {\r\n  // \tL.DomEvent.stopPropagation(ev);\r\n  // });\r\n  // ```\r\n  function stopPropagation(e) {\r\n\r\n  \tif (e.stopPropagation) {\r\n  \t\te.stopPropagation();\r\n  \t} else if (e.originalEvent) {  // In case of Leaflet event.\r\n  \t\te.originalEvent._stopped = true;\r\n  \t} else {\r\n  \t\te.cancelBubble = true;\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableScrollPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\r\n  function disableScrollPropagation(el) {\r\n  \taddOne(el, 'wheel', stopPropagation);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableClickPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\r\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\r\n  function disableClickPropagation(el) {\r\n  \ton(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\r\n  \tel['_leaflet_disable_click'] = true;\r\n  \treturn this;\r\n  }\r\n\r\n  // @function preventDefault(ev: DOMEvent): this\r\n  // Prevents the default action of the DOM Event `ev` from happening (such as\r\n  // following a link in the href of the a element, or doing a POST request\r\n  // with page reload when a `<form>` is submitted).\r\n  // Use it inside listener functions.\r\n  function preventDefault(e) {\r\n  \tif (e.preventDefault) {\r\n  \t\te.preventDefault();\r\n  \t} else {\r\n  \t\te.returnValue = false;\r\n  \t}\r\n  \treturn this;\r\n  }\r\n\r\n  // @function stop(ev: DOMEvent): this\r\n  // Does `stopPropagation` and `preventDefault` at the same time.\r\n  function stop(e) {\r\n  \tpreventDefault(e);\r\n  \tstopPropagation(e);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\r\n  // Gets normalized mouse position from a DOM event relative to the\r\n  // `container` (border excluded) or to the whole page if not specified.\r\n  function getMousePosition(e, container) {\r\n  \tif (!container) {\r\n  \t\treturn new Point(e.clientX, e.clientY);\r\n  \t}\r\n\r\n  \tvar scale = getScale(container),\r\n  \t    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\r\n\r\n  \treturn new Point(\r\n  \t\t// offset.left/top values are in page scale (like clientX/Y),\r\n  \t\t// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\r\n  \t\t(e.clientX - offset.left) / scale.x - container.clientLeft,\r\n  \t\t(e.clientY - offset.top) / scale.y - container.clientTop\r\n  \t);\r\n  }\r\n\r\n  // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\r\n  // and Firefox scrolls device pixels, not CSS pixels\r\n  var wheelPxFactor =\r\n  \t(Browser.win && Browser.chrome) ? 2 * window.devicePixelRatio :\r\n  \tBrowser.gecko ? window.devicePixelRatio : 1;\r\n\r\n  // @function getWheelDelta(ev: DOMEvent): Number\r\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\r\n  // pixels scrolled (negative if scrolling down).\r\n  // Events from pointing devices without precise scrolling are mapped to\r\n  // a best guess of 60 pixels.\r\n  function getWheelDelta(e) {\r\n  \treturn (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\r\n  \t       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels\r\n  \t       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines\r\n  \t       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages\r\n  \t       (e.deltaX || e.deltaZ) ? 0 :\t// Skip horizontal/depth wheel events\r\n  \t       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\r\n  \t       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines\r\n  \t       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\r\n  \t       0;\r\n  }\r\n\r\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\r\n  function isExternalTarget(el, e) {\r\n\r\n  \tvar related = e.relatedTarget;\r\n\r\n  \tif (!related) { return true; }\r\n\r\n  \ttry {\r\n  \t\twhile (related && (related !== el)) {\r\n  \t\t\trelated = related.parentNode;\r\n  \t\t}\r\n  \t} catch (err) {\r\n  \t\treturn false;\r\n  \t}\r\n  \treturn (related !== el);\r\n  }\n\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n\n  \t// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n  \t// Run an animation of a given element to a new position, optionally setting\n  \t// duration in seconds (`0.25` by default) and easing linearity factor (3rd\n  \t// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n  \t// `0.5` by default).\n  \trun: function (el, newPos, duration, easeLinearity) {\n  \t\tthis.stop();\n\n  \t\tthis._el = el;\n  \t\tthis._inProgress = true;\n  \t\tthis._duration = duration || 0.25;\n  \t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n  \t\tthis._startPos = getPosition(el);\n  \t\tthis._offset = newPos.subtract(this._startPos);\n  \t\tthis._startTime = +new Date();\n\n  \t\t// @event start: Event\n  \t\t// Fired when the animation starts\n  \t\tthis.fire('start');\n\n  \t\tthis._animate();\n  \t},\n\n  \t// @method stop()\n  \t// Stops the animation (if currently running).\n  \tstop: function () {\n  \t\tif (!this._inProgress) { return; }\n\n  \t\tthis._step(true);\n  \t\tthis._complete();\n  \t},\n\n  \t_animate: function () {\n  \t\t// animation loop\n  \t\tthis._animId = requestAnimFrame(this._animate, this);\n  \t\tthis._step();\n  \t},\n\n  \t_step: function (round) {\n  \t\tvar elapsed = (+new Date()) - this._startTime,\n  \t\t    duration = this._duration * 1000;\n\n  \t\tif (elapsed < duration) {\n  \t\t\tthis._runFrame(this._easeOut(elapsed / duration), round);\n  \t\t} else {\n  \t\t\tthis._runFrame(1);\n  \t\t\tthis._complete();\n  \t\t}\n  \t},\n\n  \t_runFrame: function (progress, round) {\n  \t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n  \t\tif (round) {\n  \t\t\tpos._round();\n  \t\t}\n  \t\tsetPosition(this._el, pos);\n\n  \t\t// @event step: Event\n  \t\t// Fired continuously during the animation.\n  \t\tthis.fire('step');\n  \t},\n\n  \t_complete: function () {\n  \t\tcancelAnimFrame(this._animId);\n\n  \t\tthis._inProgress = false;\n  \t\t// @event end: Event\n  \t\t// Fired when the animation ends.\n  \t\tthis.fire('end');\n  \t},\n\n  \t_easeOut: function (t) {\n  \t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n  \t}\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\r\n\r\n  var Map = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section Map State Options\r\n  \t\t// @option crs: CRS = L.CRS.EPSG3857\r\n  \t\t// The [Coordinate Reference System](#crs) to use. Don't change this if you're not\r\n  \t\t// sure what it means.\r\n  \t\tcrs: EPSG3857,\r\n\r\n  \t\t// @option center: LatLng = undefined\r\n  \t\t// Initial geographic center of the map\r\n  \t\tcenter: undefined,\r\n\r\n  \t\t// @option zoom: Number = undefined\r\n  \t\t// Initial map zoom level\r\n  \t\tzoom: undefined,\r\n\r\n  \t\t// @option minZoom: Number = *\r\n  \t\t// Minimum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the lowest of their `minZoom` options will be used instead.\r\n  \t\tminZoom: undefined,\r\n\r\n  \t\t// @option maxZoom: Number = *\r\n  \t\t// Maximum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the highest of their `maxZoom` options will be used instead.\r\n  \t\tmaxZoom: undefined,\r\n\r\n  \t\t// @option layers: Layer[] = []\r\n  \t\t// Array of layers that will be added to the map initially\r\n  \t\tlayers: [],\r\n\r\n  \t\t// @option maxBounds: LatLngBounds = null\r\n  \t\t// When this option is set, the map restricts the view to the given\r\n  \t\t// geographical bounds, bouncing the user back if the user tries to pan\r\n  \t\t// outside the view. To set the restriction dynamically, use\r\n  \t\t// [`setMaxBounds`](#map-setmaxbounds) method.\r\n  \t\tmaxBounds: undefined,\r\n\r\n  \t\t// @option renderer: Renderer = *\r\n  \t\t// The default method for drawing vector layers on the map. `L.SVG`\r\n  \t\t// or `L.Canvas` by default depending on browser support.\r\n  \t\trenderer: undefined,\r\n\r\n\r\n  \t\t// @section Animation Options\r\n  \t\t// @option zoomAnimation: Boolean = true\r\n  \t\t// Whether the map zoom animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tzoomAnimation: true,\r\n\r\n  \t\t// @option zoomAnimationThreshold: Number = 4\r\n  \t\t// Won't animate zoom if the zoom difference exceeds this value.\r\n  \t\tzoomAnimationThreshold: 4,\r\n\r\n  \t\t// @option fadeAnimation: Boolean = true\r\n  \t\t// Whether the tile fade animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tfadeAnimation: true,\r\n\r\n  \t\t// @option markerZoomAnimation: Boolean = true\r\n  \t\t// Whether markers animate their zoom with the zoom animation, if disabled\r\n  \t\t// they will disappear for the length of the animation. By default it's\r\n  \t\t// enabled in all browsers that support CSS3 Transitions except Android.\r\n  \t\tmarkerZoomAnimation: true,\r\n\r\n  \t\t// @option transform3DLimit: Number = 2^23\r\n  \t\t// Defines the maximum size of a CSS translation transform. The default\r\n  \t\t// value should not be changed unless a web browser positions layers in\r\n  \t\t// the wrong place after doing a large `panBy`.\r\n  \t\ttransform3DLimit: 8388608, // Precision limit of a 32-bit float\r\n\r\n  \t\t// @section Interaction Options\r\n  \t\t// @option zoomSnap: Number = 1\r\n  \t\t// Forces the map's zoom level to always be a multiple of this, particularly\r\n  \t\t// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\r\n  \t\t// By default, the zoom level snaps to the nearest integer; lower values\r\n  \t\t// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\r\n  \t\t// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\r\n  \t\tzoomSnap: 1,\r\n\r\n  \t\t// @option zoomDelta: Number = 1\r\n  \t\t// Controls how much the map's zoom level will change after a\r\n  \t\t// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\r\n  \t\t// or `-` on the keyboard, or using the [zoom controls](#control-zoom).\r\n  \t\t// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\r\n  \t\tzoomDelta: 1,\r\n\r\n  \t\t// @option trackResize: Boolean = true\r\n  \t\t// Whether the map automatically handles browser window resize to update itself.\r\n  \t\ttrackResize: true\r\n  \t},\r\n\r\n  \tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// Make sure to assign internal flags at the beginning,\r\n  \t\t// to avoid inconsistent state in some edge cases.\r\n  \t\tthis._handlers = [];\r\n  \t\tthis._layers = {};\r\n  \t\tthis._zoomBoundLayers = {};\r\n  \t\tthis._sizeChanged = true;\r\n\r\n  \t\tthis._initContainer(id);\r\n  \t\tthis._initLayout();\r\n\r\n  \t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n  \t\tthis._onResize = bind(this._onResize, this);\r\n\r\n  \t\tthis._initEvents();\r\n\r\n  \t\tif (options.maxBounds) {\r\n  \t\t\tthis.setMaxBounds(options.maxBounds);\r\n  \t\t}\r\n\r\n  \t\tif (options.zoom !== undefined) {\r\n  \t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n  \t\t}\r\n\r\n  \t\tif (options.center && options.zoom !== undefined) {\r\n  \t\t\tthis.setView(toLatLng(options.center), options.zoom, {reset: true});\r\n  \t\t}\r\n\r\n  \t\tthis.callInitHooks();\r\n\r\n  \t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\r\n  \t\tthis._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&\r\n  \t\t\t\tthis.options.zoomAnimation;\r\n\r\n  \t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\r\n  \t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tthis._createAnimProxy();\r\n  \t\t\ton(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\r\n  \t\t}\r\n\r\n  \t\tthis._addLayers(this.options.layers);\r\n  \t},\r\n\r\n\r\n  \t// @section Methods for modifying map state\r\n\r\n  \t// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) with the given\r\n  \t// animation options.\r\n  \tsetView: function (center, zoom, options) {\r\n\r\n  \t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\r\n  \t\tcenter = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\r\n  \t\toptions = options || {};\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tif (this._loaded && !options.reset && options !== true) {\r\n\r\n  \t\t\tif (options.animate !== undefined) {\r\n  \t\t\t\toptions.zoom = extend({animate: options.animate}, options.zoom);\r\n  \t\t\t\toptions.pan = extend({animate: options.animate, duration: options.duration}, options.pan);\r\n  \t\t\t}\r\n\r\n  \t\t\t// try animating pan or zoom\r\n  \t\t\tvar moved = (this._zoom !== zoom) ?\r\n  \t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\r\n  \t\t\t\tthis._tryAnimatedPan(center, options.pan);\r\n\r\n  \t\t\tif (moved) {\r\n  \t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\treturn this;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// animation didn't start, just reset the map view\r\n  \t\tthis._resetView(center, zoom);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setZoom(zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the zoom of the map.\r\n  \tsetZoom: function (zoom, options) {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthis._zoom = zoom;\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t// @method zoomIn(delta?: Number, options?: Zoom options): this\r\n  \t// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomIn: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom + delta, options);\r\n  \t},\r\n\r\n  \t// @method zoomOut(delta?: Number, options?: Zoom options): this\r\n  \t// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomOut: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom - delta, options);\r\n  \t},\r\n\r\n  \t// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified geographical point on the map\r\n  \t// stationary (e.g. used internally for scroll zoom and double-click zoom).\r\n  \t// @alternative\r\n  \t// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\r\n  \tsetZoomAround: function (latlng, zoom, options) {\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n  \t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n  \t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n  \t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tbounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n  \t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n  \t\tzoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n  \t\tif (zoom === Infinity) {\r\n  \t\t\treturn {\r\n  \t\t\t\tcenter: bounds.getCenter(),\r\n  \t\t\t\tzoom: zoom\r\n  \t\t\t};\r\n  \t\t}\r\n\r\n  \t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n  \t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n  \t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n  \t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n  \t\treturn {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets a map view that contains the given geographical bounds with the\r\n  \t// maximum zoom level possible.\r\n  \tfitBounds: function (bounds, options) {\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthrow new Error('Bounds are not valid.');\r\n  \t\t}\r\n\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.setView(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method fitWorld(options?: fitBounds options): this\r\n  \t// Sets a map view that mostly contains the whole world with the maximum\r\n  \t// zoom level possible.\r\n  \tfitWorld: function (options) {\r\n  \t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n  \t},\r\n\r\n  \t// @method panTo(latlng: LatLng, options?: Pan options): this\r\n  \t// Pans the map to a given center.\r\n  \tpanTo: function (center, options) { // (LatLng)\r\n  \t\treturn this.setView(center, this._zoom, {pan: options});\r\n  \t},\r\n\r\n  \t// @method panBy(offset: Point, options?: Pan options): this\r\n  \t// Pans the map by a given number of pixels (animated).\r\n  \tpanBy: function (offset, options) {\r\n  \t\toffset = toPoint(offset).round();\r\n  \t\toptions = options || {};\r\n\r\n  \t\tif (!offset.x && !offset.y) {\r\n  \t\t\treturn this.fire('moveend');\r\n  \t\t}\r\n  \t\t// If we pan too far, Chrome gets issues with tiles\r\n  \t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) {\r\n  \t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tif (!this._panAnim) {\r\n  \t\t\tthis._panAnim = new PosAnimation();\r\n\r\n  \t\t\tthis._panAnim.on({\r\n  \t\t\t\t'step': this._onPanTransitionStep,\r\n  \t\t\t\t'end': this._onPanTransitionEnd\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\t// don't fire movestart if animating inertia\r\n  \t\tif (!options.noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n\r\n  \t\t// animate pan unless animate: false specified\r\n  \t\tif (options.animate !== false) {\r\n  \t\t\taddClass(this._mapPane, 'leaflet-pan-anim');\r\n\r\n  \t\t\tvar newPos = this._getMapPanePos().subtract(offset).round();\r\n  \t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\r\n  \t\t} else {\r\n  \t\t\tthis._rawPanBy(offset);\r\n  \t\t\tthis.fire('move').fire('moveend');\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) performing a smooth\r\n  \t// pan-zoom animation.\r\n  \tflyTo: function (targetCenter, targetZoom, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tif (options.animate === false || !Browser.any3d) {\r\n  \t\t\treturn this.setView(targetCenter, targetZoom, options);\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tvar from = this.project(this.getCenter()),\r\n  \t\t    to = this.project(targetCenter),\r\n  \t\t    size = this.getSize(),\r\n  \t\t    startZoom = this._zoom;\r\n\r\n  \t\ttargetCenter = toLatLng(targetCenter);\r\n  \t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\r\n\r\n  \t\tvar w0 = Math.max(size.x, size.y),\r\n  \t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\r\n  \t\t    u1 = (to.distanceTo(from)) || 1,\r\n  \t\t    rho = 1.42,\r\n  \t\t    rho2 = rho * rho;\r\n\r\n  \t\tfunction r(i) {\r\n  \t\t\tvar s1 = i ? -1 : 1,\r\n  \t\t\t    s2 = i ? w1 : w0,\r\n  \t\t\t    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\r\n  \t\t\t    b1 = 2 * s2 * rho2 * u1,\r\n  \t\t\t    b = t1 / b1,\r\n  \t\t\t    sq = Math.sqrt(b * b + 1) - b;\r\n\r\n  \t\t\t    // workaround for floating point precision bug when sq = 0, log = -Infinite,\r\n  \t\t\t    // thus triggering an infinite loop in flyTo\r\n  \t\t\t    var log = sq < 0.000000001 ? -18 : Math.log(sq);\r\n\r\n  \t\t\treturn log;\r\n  \t\t}\r\n\r\n  \t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\r\n  \t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\r\n  \t\tfunction tanh(n) { return sinh(n) / cosh(n); }\r\n\r\n  \t\tvar r0 = r(0);\r\n\r\n  \t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\r\n  \t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\r\n\r\n  \t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\r\n\r\n  \t\tvar start = Date.now(),\r\n  \t\t    S = (r(1) - r0) / rho,\r\n  \t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\r\n\r\n  \t\tfunction frame() {\r\n  \t\t\tvar t = (Date.now() - start) / duration,\r\n  \t\t\t    s = easeOut(t) * S;\r\n\r\n  \t\t\tif (t <= 1) {\r\n  \t\t\t\tthis._flyToFrame = requestAnimFrame(frame, this);\r\n\r\n  \t\t\t\tthis._move(\r\n  \t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\r\n  \t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\r\n  \t\t\t\t\t{flyTo: true});\r\n\r\n  \t\t\t} else {\r\n  \t\t\t\tthis\r\n  \t\t\t\t\t._move(targetCenter, targetZoom)\r\n  \t\t\t\t\t._moveEnd(true);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._moveStart(true, options.noMoveStart);\r\n\r\n  \t\tframe.call(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\r\n  \t// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\r\n  \tflyToBounds: function (bounds, options) {\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.flyTo(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method setMaxBounds(bounds: LatLngBounds): this\r\n  \t// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\r\n  \tsetMaxBounds: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthis.options.maxBounds = null;\r\n  \t\t\treturn this.off('moveend', this._panInsideMaxBounds);\r\n  \t\t} else if (this.options.maxBounds) {\r\n  \t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n  \t\t}\r\n\r\n  \t\tthis.options.maxBounds = bounds;\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\tthis._panInsideMaxBounds();\r\n  \t\t}\r\n\r\n  \t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n  \t},\r\n\r\n  \t// @method setMinZoom(zoom: Number): this\r\n  \t// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\r\n  \tsetMinZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.minZoom;\r\n  \t\tthis.options.minZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() < this.options.minZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setMaxZoom(zoom: Number): this\r\n  \t// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\r\n  \tsetMaxZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.maxZoom;\r\n  \t\tthis.options.maxZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() > this.options.maxZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\r\n  \t// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\r\n  \tpanInsideBounds: function (bounds, options) {\r\n  \t\tthis._enforcingBounds = true;\r\n  \t\tvar center = this.getCenter(),\r\n  \t\t    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\r\n\r\n  \t\tif (!center.equals(newCenter)) {\r\n  \t\t\tthis.panTo(newCenter, options);\r\n  \t\t}\r\n\r\n  \t\tthis._enforcingBounds = false;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInside(latlng: LatLng, options?: padding options): this\r\n  \t// Pans the map the minimum amount to make the `latlng` visible. Use\r\n  \t// padding options to fit the display to more restricted bounds.\r\n  \t// If `latlng` is already within the (optionally padded) display bounds,\r\n  \t// the map will not be panned.\r\n  \tpanInside: function (latlng, options) {\r\n  \t\toptions = options || {};\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n  \t\t    pixelCenter = this.project(this.getCenter()),\r\n  \t\t    pixelPoint = this.project(latlng),\r\n  \t\t    pixelBounds = this.getPixelBounds(),\r\n  \t\t    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\r\n  \t\t    paddedSize = paddedBounds.getSize();\r\n\r\n  \t\tif (!paddedBounds.contains(pixelPoint)) {\r\n  \t\t\tthis._enforcingBounds = true;\r\n  \t\t\tvar centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\r\n  \t\t\tvar offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\r\n  \t\t\tpixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\r\n  \t\t\tpixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\r\n  \t\t\tthis.panTo(this.unproject(pixelCenter), options);\r\n  \t\t\tthis._enforcingBounds = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method invalidateSize(options: Zoom/pan options): this\r\n  \t// Checks if the map container size changed and updates the map if so —\r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default. If `options.pan` is `false`, panning will not occur.\r\n  \t// If `options.debounceMoveend` is `true`, it will delay `moveend` event so\r\n  \t// that it doesn't happen often even if the method is called many\r\n  \t// times in a row.\r\n\r\n  \t// @alternative\r\n  \t// @method invalidateSize(animate: Boolean): this\r\n  \t// Checks if the map container size changed and updates the map if so —\r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default.\r\n  \tinvalidateSize: function (options) {\r\n  \t\tif (!this._loaded) { return this; }\r\n\r\n  \t\toptions = extend({\r\n  \t\t\tanimate: false,\r\n  \t\t\tpan: true\r\n  \t\t}, options === true ? {animate: true} : options);\r\n\r\n  \t\tvar oldSize = this.getSize();\r\n  \t\tthis._sizeChanged = true;\r\n  \t\tthis._lastCenter = null;\r\n\r\n  \t\tvar newSize = this.getSize(),\r\n  \t\t    oldCenter = oldSize.divideBy(2).round(),\r\n  \t\t    newCenter = newSize.divideBy(2).round(),\r\n  \t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n  \t\tif (options.animate && options.pan) {\r\n  \t\t\tthis.panBy(offset);\r\n\r\n  \t\t} else {\r\n  \t\t\tif (options.pan) {\r\n  \t\t\t\tthis._rawPanBy(offset);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.fire('move');\r\n\r\n  \t\t\tif (options.debounceMoveend) {\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\tthis._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.fire('moveend');\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @section Map state change events\r\n  \t\t// @event resize: ResizeEvent\r\n  \t\t// Fired when the map is resized.\r\n  \t\treturn this.fire('resize', {\r\n  \t\t\toldSize: oldSize,\r\n  \t\t\tnewSize: newSize\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @section Methods for modifying map state\r\n  \t// @method stop(): this\r\n  \t// Stops the currently running `panTo` or `flyTo` animation, if any.\r\n  \tstop: function () {\r\n  \t\tthis.setZoom(this._limitZoom(this._zoom));\r\n  \t\tif (!this.options.zoomSnap) {\r\n  \t\t\tthis.fire('viewreset');\r\n  \t\t}\r\n  \t\treturn this._stop();\r\n  \t},\r\n\r\n  \t// @section Geolocation methods\r\n  \t// @method locate(options?: Locate options): this\r\n  \t// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\r\n  \t// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\r\n  \t// and optionally sets the map view to the user's location with respect to\r\n  \t// detection accuracy (or to the world view if geolocation failed).\r\n  \t// Note that, if your page doesn't use HTTPS, this method will fail in\r\n  \t// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\r\n  \t// See `Locate options` for more details.\r\n  \tlocate: function (options) {\r\n\r\n  \t\toptions = this._locateOptions = extend({\r\n  \t\t\ttimeout: 10000,\r\n  \t\t\twatch: false\r\n  \t\t\t// setView: false\r\n  \t\t\t// maxZoom: <Number>\r\n  \t\t\t// maximumAge: 0\r\n  \t\t\t// enableHighAccuracy: false\r\n  \t\t}, options);\r\n\r\n  \t\tif (!('geolocation' in navigator)) {\r\n  \t\t\tthis._handleGeolocationError({\r\n  \t\t\t\tcode: 0,\r\n  \t\t\t\tmessage: 'Geolocation not supported.'\r\n  \t\t\t});\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar onResponse = bind(this._handleGeolocationResponse, this),\r\n  \t\t    onError = bind(this._handleGeolocationError, this);\r\n\r\n  \t\tif (options.watch) {\r\n  \t\t\tthis._locationWatchId =\r\n  \t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n  \t\t} else {\r\n  \t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method stopLocate(): this\r\n  \t// Stops watching location previously initiated by `map.locate({watch: true})`\r\n  \t// and aborts resetting the map view if map.locate was called with\r\n  \t// `{setView: true}`.\r\n  \tstopLocate: function () {\r\n  \t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n  \t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n  \t\t}\r\n  \t\tif (this._locateOptions) {\r\n  \t\t\tthis._locateOptions.setView = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_handleGeolocationError: function (error) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar c = error.code,\r\n  \t\t    message = error.message ||\r\n  \t\t            (c === 1 ? 'permission denied' :\r\n  \t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n  \t\tif (this._locateOptions.setView && !this._loaded) {\r\n  \t\t\tthis.fitWorld();\r\n  \t\t}\r\n\r\n  \t\t// @section Location events\r\n  \t\t// @event locationerror: ErrorEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method) failed.\r\n  \t\tthis.fire('locationerror', {\r\n  \t\t\tcode: c,\r\n  \t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_handleGeolocationResponse: function (pos) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar lat = pos.coords.latitude,\r\n  \t\t    lng = pos.coords.longitude,\r\n  \t\t    latlng = new LatLng(lat, lng),\r\n  \t\t    bounds = latlng.toBounds(pos.coords.accuracy * 2),\r\n  \t\t    options = this._locateOptions;\r\n\r\n  \t\tif (options.setView) {\r\n  \t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n  \t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n  \t\t}\r\n\r\n  \t\tvar data = {\r\n  \t\t\tlatlng: latlng,\r\n  \t\t\tbounds: bounds,\r\n  \t\t\ttimestamp: pos.timestamp\r\n  \t\t};\r\n\r\n  \t\tfor (var i in pos.coords) {\r\n  \t\t\tif (typeof pos.coords[i] === 'number') {\r\n  \t\t\t\tdata[i] = pos.coords[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @event locationfound: LocationEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method)\r\n  \t\t// went successfully.\r\n  \t\tthis.fire('locationfound', data);\r\n  \t},\r\n\r\n  \t// TODO Appropriate docs section?\r\n  \t// @section Other Methods\r\n  \t// @method addHandler(name: String, HandlerClass: Function): this\r\n  \t// Adds a new `Handler` to the map, given its name and constructor function.\r\n  \taddHandler: function (name, HandlerClass) {\r\n  \t\tif (!HandlerClass) { return this; }\r\n\r\n  \t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n  \t\tthis._handlers.push(handler);\r\n\r\n  \t\tif (this.options[name]) {\r\n  \t\t\thandler.enable();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove(): this\r\n  \t// Destroys the map and clears all related event listeners.\r\n  \tremove: function () {\r\n\r\n  \t\tthis._initEvents(true);\r\n  \t\tif (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }\r\n\r\n  \t\tif (this._containerId !== this._container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is being reused by another instance');\r\n  \t\t}\r\n\r\n  \t\ttry {\r\n  \t\t\t// throws error in IE6-8\r\n  \t\t\tdelete this._container._leaflet_id;\r\n  \t\t\tdelete this._containerId;\r\n  \t\t} catch (e) {\r\n  \t\t\t/*eslint-disable */\r\n  \t\t\tthis._container._leaflet_id = undefined;\r\n  \t\t\t/* eslint-enable */\r\n  \t\t\tthis._containerId = undefined;\r\n  \t\t}\r\n\r\n  \t\tif (this._locationWatchId !== undefined) {\r\n  \t\t\tthis.stopLocate();\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tremove(this._mapPane);\r\n\r\n  \t\tif (this._clearControlPos) {\r\n  \t\t\tthis._clearControlPos();\r\n  \t\t}\r\n  \t\tif (this._resizeRequest) {\r\n  \t\t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\t\tthis._resizeRequest = null;\r\n  \t\t}\r\n\r\n  \t\tthis._clearHandlers();\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\t// @section Map state change events\r\n  \t\t\t// @event unload: Event\r\n  \t\t\t// Fired when the map is destroyed with [remove](#map-remove) method.\r\n  \t\t\tthis.fire('unload');\r\n  \t\t}\r\n\r\n  \t\tvar i;\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tthis._layers[i].remove();\r\n  \t\t}\r\n  \t\tfor (i in this._panes) {\r\n  \t\t\tremove(this._panes[i]);\r\n  \t\t}\r\n\r\n  \t\tthis._layers = [];\r\n  \t\tthis._panes = [];\r\n  \t\tdelete this._mapPane;\r\n  \t\tdelete this._renderer;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n  \t// @method createPane(name: String, container?: HTMLElement): HTMLElement\r\n  \t// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\r\n  \t// then returns it. The pane is created as a child of `container`, or\r\n  \t// as a child of the main map pane if not set.\r\n  \tcreatePane: function (name, container) {\r\n  \t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n  \t\t    pane = create$1('div', className, container || this._mapPane);\r\n\r\n  \t\tif (name) {\r\n  \t\t\tthis._panes[name] = pane;\r\n  \t\t}\r\n  \t\treturn pane;\r\n  \t},\r\n\r\n  \t// @section Methods for Getting Map State\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the geographical center of the map view\r\n  \tgetCenter: function () {\r\n  \t\tthis._checkIfLoaded();\r\n\r\n  \t\tif (this._lastCenter && !this._moved()) {\r\n  \t\t\treturn this._lastCenter;\r\n  \t\t}\r\n  \t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// @method getZoom(): Number\r\n  \t// Returns the current zoom level of the map view\r\n  \tgetZoom: function () {\r\n  \t\treturn this._zoom;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the geographical bounds visible in the current map view\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = this.getPixelBounds(),\r\n  \t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n  \t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n  \t\treturn new LatLngBounds(sw, ne);\r\n  \t},\r\n\r\n  \t// @method getMinZoom(): Number\r\n  \t// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\r\n  \tgetMinZoom: function () {\r\n  \t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n  \t},\r\n\r\n  \t// @method getMaxZoom(): Number\r\n  \t// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\r\n  \tgetMaxZoom: function () {\r\n  \t\treturn this.options.maxZoom === undefined ?\r\n  \t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n  \t\t\tthis.options.maxZoom;\r\n  \t},\r\n\r\n  \t// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\r\n  \t// Returns the maximum zoom level on which the given bounds fit to the map\r\n  \t// view in its entirety. If `inside` (optional) is set to `true`, the method\r\n  \t// instead returns the minimum zoom level on which the map view fits into\r\n  \t// the given bounds in its entirety.\r\n  \tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n  \t\tpadding = toPoint(padding || [0, 0]);\r\n\r\n  \t\tvar zoom = this.getZoom() || 0,\r\n  \t\t    min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    nw = bounds.getNorthWest(),\r\n  \t\t    se = bounds.getSouthEast(),\r\n  \t\t    size = this.getSize().subtract(padding),\r\n  \t\t    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1,\r\n  \t\t    scalex = size.x / boundsSize.x,\r\n  \t\t    scaley = size.y / boundsSize.y,\r\n  \t\t    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n\r\n  \t\tzoom = this.getScaleZoom(scale, zoom);\r\n\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n  \t\t\tzoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n  \t\t}\r\n\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the current size of the map container (in pixels).\r\n  \tgetSize: function () {\r\n  \t\tif (!this._size || this._sizeChanged) {\r\n  \t\t\tthis._size = new Point(\r\n  \t\t\t\tthis._container.clientWidth || 0,\r\n  \t\t\t\tthis._container.clientHeight || 0);\r\n\r\n  \t\t\tthis._sizeChanged = false;\r\n  \t\t}\r\n  \t\treturn this._size.clone();\r\n  \t},\r\n\r\n  \t// @method getPixelBounds(): Bounds\r\n  \t// Returns the bounds of the current map view in projected pixel\r\n  \t// coordinates (sometimes useful in layer and overlay implementations).\r\n  \tgetPixelBounds: function (center, zoom) {\r\n  \t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n  \t\treturn new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n  \t},\r\n\r\n  \t// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\r\n  \t// the map pane? \"left point of the map layer\" can be confusing, specially\r\n  \t// since there can be negative offsets.\r\n  \t// @method getPixelOrigin(): Point\r\n  \t// Returns the projected pixel coordinates of the top left point of\r\n  \t// the map layer (useful in custom layer and overlay implementations).\r\n  \tgetPixelOrigin: function () {\r\n  \t\tthis._checkIfLoaded();\r\n  \t\treturn this._pixelOrigin;\r\n  \t},\r\n\r\n  \t// @method getPixelWorldBounds(zoom?: Number): Bounds\r\n  \t// Returns the world's bounds in pixel coordinates for zoom level `zoom`.\r\n  \t// If `zoom` is omitted, the map's current zoom level is used.\r\n  \tgetPixelWorldBounds: function (zoom) {\r\n  \t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method getPane(pane: String|HTMLElement): HTMLElement\r\n  \t// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\r\n  \tgetPane: function (pane) {\r\n  \t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n  \t},\r\n\r\n  \t// @method getPanes(): Object\r\n  \t// Returns a plain object containing the names of all [panes](#map-pane) as keys and\r\n  \t// the panes as values.\r\n  \tgetPanes: function () {\r\n  \t\treturn this._panes;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTML element that contains the map.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n\r\n  \t// @section Conversion Methods\r\n\r\n  \t// @method getZoomScale(toZoom: Number, fromZoom: Number): Number\r\n  \t// Returns the scale factor to be applied to a map transition from zoom level\r\n  \t// `fromZoom` to `toZoom`. Used internally to help with zoom animations.\r\n  \tgetZoomScale: function (toZoom, fromZoom) {\r\n  \t\t// TODO replace with universal implementation after refactoring projections\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n  \t},\r\n\r\n  \t// @method getScaleZoom(scale: Number, fromZoom: Number): Number\r\n  \t// Returns the zoom level that the map would end up at, if it is at `fromZoom`\r\n  \t// level and everything is scaled by a factor of `scale`. Inverse of\r\n  \t// [`getZoomScale`](#map-getZoomScale).\r\n  \tgetScaleZoom: function (scale, fromZoom) {\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\tvar zoom = crs.zoom(scale * crs.scale(fromZoom));\r\n  \t\treturn isNaN(zoom) ? Infinity : zoom;\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects a geographical coordinate `LatLng` according to the projection\r\n  \t// of the map's CRS, then scales it according to `zoom` and the CRS's\r\n  \t// `Transformation`. The result is pixel coordinate relative to\r\n  \t// the CRS origin.\r\n  \tproject: function (latlng, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point, zoom: Number): LatLng\r\n  \t// Inverse of [`project`](#map-project).\r\n  \tunproject: function (point, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.pointToLatLng(toPoint(point), zoom);\r\n  \t},\r\n\r\n  \t// @method layerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding geographical coordinate (for the current zoom level).\r\n  \tlayerPointToLatLng: function (point) {\r\n  \t\tvar projectedPoint = toPoint(point).add(this.getPixelOrigin());\r\n  \t\treturn this.unproject(projectedPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToLayerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the [origin pixel](#map-getpixelorigin).\r\n  \tlatLngToLayerPoint: function (latlng) {\r\n  \t\tvar projectedPoint = this.project(toLatLng(latlng))._round();\r\n  \t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n  \t},\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\r\n  \t// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\r\n  \t// CRS's bounds.\r\n  \t// By default this means longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLng(toLatLng(latlng));\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring that\r\n  \t// its center is within the CRS's bounds.\r\n  \t// By default this means the center longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees, and the majority of the bounds\r\n  \t// overlaps the CRS's bounds.\r\n  \twrapLatLngBounds: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates according to\r\n  \t// the map's CRS. By default this measures distance in meters.\r\n  \tdistance: function (latlng1, latlng2) {\r\n  \t\treturn this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\r\n  \t},\r\n\r\n  \t// @method containerPointToLayerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the map container, returns the corresponding\r\n  \t// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\r\n  \tcontainerPointToLayerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method layerPointToContainerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding pixel coordinate relative to the map container.\r\n  \tlayerPointToContainerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).add(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method containerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the map container, returns\r\n  \t// the corresponding geographical coordinate (for the current zoom level).\r\n  \tcontainerPointToLatLng: function (point) {\r\n  \t\tvar layerPoint = this.containerPointToLayerPoint(toPoint(point));\r\n  \t\treturn this.layerPointToLatLng(layerPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToContainerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the map container.\r\n  \tlatLngToContainerPoint: function (latlng) {\r\n  \t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\r\n  \t},\r\n\r\n  \t// @method mouseEventToContainerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to the\r\n  \t// map container where the event took place.\r\n  \tmouseEventToContainerPoint: function (e) {\r\n  \t\treturn getMousePosition(e, this._container);\r\n  \t},\r\n\r\n  \t// @method mouseEventToLayerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to\r\n  \t// the [origin pixel](#map-getpixelorigin) where the event took place.\r\n  \tmouseEventToLayerPoint: function (e) {\r\n  \t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n  \t},\r\n\r\n  \t// @method mouseEventToLatLng(ev: MouseEvent): LatLng\r\n  \t// Given a MouseEvent object, returns geographical coordinate where the\r\n  \t// event took place.\r\n  \tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n  \t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n  \t},\r\n\r\n\r\n  \t// map initialization methods\r\n\r\n  \t_initContainer: function (id) {\r\n  \t\tvar container = this._container = get(id);\r\n\r\n  \t\tif (!container) {\r\n  \t\t\tthrow new Error('Map container not found.');\r\n  \t\t} else if (container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is already initialized.');\r\n  \t\t}\r\n\r\n  \t\ton(container, 'scroll', this._onScroll, this);\r\n  \t\tthis._containerId = stamp(container);\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar container = this._container;\r\n\r\n  \t\tthis._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\r\n\r\n  \t\taddClass(container, 'leaflet-container' +\r\n  \t\t\t(Browser.touch ? ' leaflet-touch' : '') +\r\n  \t\t\t(Browser.retina ? ' leaflet-retina' : '') +\r\n  \t\t\t(Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n  \t\t\t(Browser.safari ? ' leaflet-safari' : '') +\r\n  \t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n  \t\tvar position = getStyle(container, 'position');\r\n\r\n  \t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n  \t\t\tcontainer.style.position = 'relative';\r\n  \t\t}\r\n\r\n  \t\tthis._initPanes();\r\n\r\n  \t\tif (this._initControlPos) {\r\n  \t\t\tthis._initControlPos();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_initPanes: function () {\r\n  \t\tvar panes = this._panes = {};\r\n  \t\tthis._paneRenderers = {};\r\n\r\n  \t\t// @section\r\n  \t\t//\r\n  \t\t// Panes are DOM elements used to control the ordering of layers on the map. You\r\n  \t\t// can access panes with [`map.getPane`](#map-getpane) or\r\n  \t\t// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\r\n  \t\t// [`map.createPane`](#map-createpane) method.\r\n  \t\t//\r\n  \t\t// Every map has the following default panes that differ only in zIndex.\r\n  \t\t//\r\n  \t\t// @pane mapPane: HTMLElement = 'auto'\r\n  \t\t// Pane that contains all other map panes\r\n\r\n  \t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\t// @pane tilePane: HTMLElement = 200\r\n  \t\t// Pane for `GridLayer`s and `TileLayer`s\r\n  \t\tthis.createPane('tilePane');\r\n  \t\t// @pane overlayPane: HTMLElement = 400\r\n  \t\t// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\r\n  \t\tthis.createPane('overlayPane');\r\n  \t\t// @pane shadowPane: HTMLElement = 500\r\n  \t\t// Pane for overlay shadows (e.g. `Marker` shadows)\r\n  \t\tthis.createPane('shadowPane');\r\n  \t\t// @pane markerPane: HTMLElement = 600\r\n  \t\t// Pane for `Icon`s of `Marker`s\r\n  \t\tthis.createPane('markerPane');\r\n  \t\t// @pane tooltipPane: HTMLElement = 650\r\n  \t\t// Pane for `Tooltip`s.\r\n  \t\tthis.createPane('tooltipPane');\r\n  \t\t// @pane popupPane: HTMLElement = 700\r\n  \t\t// Pane for `Popup`s.\r\n  \t\tthis.createPane('popupPane');\r\n\r\n  \t\tif (!this.options.markerZoomAnimation) {\r\n  \t\t\taddClass(panes.markerPane, 'leaflet-zoom-hide');\r\n  \t\t\taddClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n  \t\t}\r\n  \t},\r\n\r\n\r\n  \t// private methods that modify map state\r\n\r\n  \t// @section Map state change events\r\n  \t_resetView: function (center, zoom) {\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\tvar loading = !this._loaded;\r\n  \t\tthis._loaded = true;\r\n  \t\tzoom = this._limitZoom(zoom);\r\n\r\n  \t\tthis.fire('viewprereset');\r\n\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n  \t\tthis\r\n  \t\t\t._moveStart(zoomChanged, false)\r\n  \t\t\t._move(center, zoom)\r\n  \t\t\t._moveEnd(zoomChanged);\r\n\r\n  \t\t// @event viewreset: Event\r\n  \t\t// Fired when the map needs to redraw its content (this usually happens\r\n  \t\t// on map zoom or load). Very useful for creating custom overlays.\r\n  \t\tthis.fire('viewreset');\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the map is initialized (when its center and zoom are set\r\n  \t\t// for the first time).\r\n  \t\tif (loading) {\r\n  \t\t\tthis.fire('load');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_moveStart: function (zoomChanged, noMoveStart) {\r\n  \t\t// @event zoomstart: Event\r\n  \t\t// Fired when the map zoom is about to change (e.g. before zoom animation).\r\n  \t\t// @event movestart: Event\r\n  \t\t// Fired when the view of the map starts changing (e.g. user starts dragging the map).\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomstart');\r\n  \t\t}\r\n  \t\tif (!noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_move: function (center, zoom, data, supressEvent) {\r\n  \t\tif (zoom === undefined) {\r\n  \t\t\tzoom = this._zoom;\r\n  \t\t}\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n  \t\tthis._zoom = zoom;\r\n  \t\tthis._lastCenter = center;\r\n  \t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n  \t\tif (!supressEvent) {\r\n  \t\t\t// @event zoom: Event\r\n  \t\t\t// Fired repeatedly during any change in zoom level,\r\n  \t\t\t// including zoom and fly animations.\r\n  \t\t\tif (zoomChanged || (data && data.pinch)) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\t\tthis.fire('zoom', data);\r\n  \t\t\t}\r\n\r\n  \t\t\t// @event move: Event\r\n  \t\t\t// Fired repeatedly during any movement of the map,\r\n  \t\t\t// including pan and fly animations.\r\n  \t\t\tthis.fire('move', data);\r\n  \t\t} else if (data && data.pinch) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\tthis.fire('zoom', data);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_moveEnd: function (zoomChanged) {\r\n  \t\t// @event zoomend: Event\r\n  \t\t// Fired when the map zoom changed, after any animations.\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomend');\r\n  \t\t}\r\n\r\n  \t\t// @event moveend: Event\r\n  \t\t// Fired when the center of the map stops changing\r\n  \t\t// (e.g. user stopped dragging the map or after non-centered zoom).\r\n  \t\treturn this.fire('moveend');\r\n  \t},\r\n\r\n  \t_stop: function () {\r\n  \t\tcancelAnimFrame(this._flyToFrame);\r\n  \t\tif (this._panAnim) {\r\n  \t\t\tthis._panAnim.stop();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_rawPanBy: function (offset) {\r\n  \t\tsetPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n  \t},\r\n\r\n  \t_getZoomSpan: function () {\r\n  \t\treturn this.getMaxZoom() - this.getMinZoom();\r\n  \t},\r\n\r\n  \t_panInsideMaxBounds: function () {\r\n  \t\tif (!this._enforcingBounds) {\r\n  \t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_checkIfLoaded: function () {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthrow new Error('Set map center and zoom first.');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// DOM event handling\r\n\r\n  \t// @section Interaction events\r\n  \t_initEvents: function (remove) {\r\n  \t\tthis._targets = {};\r\n  \t\tthis._targets[stamp(this._container)] = this;\r\n\r\n  \t\tvar onOff = remove ? off : on;\r\n\r\n  \t\t// @event click: MouseEvent\r\n  \t\t// Fired when the user clicks (or taps) the map.\r\n  \t\t// @event dblclick: MouseEvent\r\n  \t\t// Fired when the user double-clicks (or double-taps) the map.\r\n  \t\t// @event mousedown: MouseEvent\r\n  \t\t// Fired when the user pushes the mouse button on the map.\r\n  \t\t// @event mouseup: MouseEvent\r\n  \t\t// Fired when the user releases the mouse button on the map.\r\n  \t\t// @event mouseover: MouseEvent\r\n  \t\t// Fired when the mouse enters the map.\r\n  \t\t// @event mouseout: MouseEvent\r\n  \t\t// Fired when the mouse leaves the map.\r\n  \t\t// @event mousemove: MouseEvent\r\n  \t\t// Fired while the mouse moves over the map.\r\n  \t\t// @event contextmenu: MouseEvent\r\n  \t\t// Fired when the user pushes the right mouse button on the map, prevents\r\n  \t\t// default browser context menu from showing if there are listeners on\r\n  \t\t// this event. Also fired on mobile when the user holds a single touch\r\n  \t\t// for a second (also called long press).\r\n  \t\t// @event keypress: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\r\n  \t\t// @event keydown: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\r\n  \t\t// the `keydown` event is fired for keys that produce a character value and for keys\r\n  \t\t// that do not produce a character value.\r\n  \t\t// @event keyup: KeyboardEvent\r\n  \t\t// Fired when the user releases a key from the keyboard while the map is focused.\r\n  \t\tonOff(this._container, 'click dblclick mousedown mouseup ' +\r\n  \t\t\t'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n\r\n  \t\tif (this.options.trackResize) {\r\n  \t\t\tonOff(window, 'resize', this._onResize, this);\r\n  \t\t}\r\n\r\n  \t\tif (Browser.any3d && this.options.transform3DLimit) {\r\n  \t\t\t(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_onResize: function () {\r\n  \t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\tthis._resizeRequest = requestAnimFrame(\r\n  \t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n  \t},\r\n\r\n  \t_onScroll: function () {\r\n  \t\tthis._container.scrollTop  = 0;\r\n  \t\tthis._container.scrollLeft = 0;\r\n  \t},\r\n\r\n  \t_onMoveEnd: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n  \t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n  \t\t\t// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\r\n  \t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_findEventTargets: function (e, type) {\r\n  \t\tvar targets = [],\r\n  \t\t    target,\r\n  \t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n  \t\t    src = e.target || e.srcElement,\r\n  \t\t    dragging = false;\r\n\r\n  \t\twhile (src) {\r\n  \t\t\ttarget = this._targets[stamp(src)];\r\n  \t\t\tif (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\r\n  \t\t\t\t// Prevent firing click after you just dragged an object.\r\n  \t\t\t\tdragging = true;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t\tif (target && target.listens(type, true)) {\r\n  \t\t\t\tif (isHover && !isExternalTarget(src, e)) { break; }\r\n  \t\t\t\ttargets.push(target);\r\n  \t\t\t\tif (isHover) { break; }\r\n  \t\t\t}\r\n  \t\t\tif (src === this._container) { break; }\r\n  \t\t\tsrc = src.parentNode;\r\n  \t\t}\r\n  \t\tif (!targets.length && !dragging && !isHover && this.listens(type, true)) {\r\n  \t\t\ttargets = [this];\r\n  \t\t}\r\n  \t\treturn targets;\r\n  \t},\r\n\r\n  \t_isClickDisabled: function (el) {\r\n  \t\twhile (el !== this._container) {\r\n  \t\t\tif (el['_leaflet_disable_click']) { return true; }\r\n  \t\t\tel = el.parentNode;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_handleDOMEvent: function (e) {\r\n  \t\tvar el = (e.target || e.srcElement);\r\n  \t\tif (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar type = e.type;\r\n\r\n  \t\tif (type === 'mousedown') {\r\n  \t\t\t// prevents outline when clicking on keyboard-focusable element\r\n  \t\t\tpreventOutline(el);\r\n  \t\t}\r\n\r\n  \t\tthis._fireDOMEvent(e, type);\r\n  \t},\r\n\r\n  \t_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n  \t_fireDOMEvent: function (e, type, canvasTargets) {\r\n\r\n  \t\tif (e.type === 'click') {\r\n  \t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n  \t\t\t// @event preclick: MouseEvent\r\n  \t\t\t// Fired before mouse click on the map (sometimes useful when you\r\n  \t\t\t// want something to happen on click before any existing click\r\n  \t\t\t// handlers start running).\r\n  \t\t\tvar synth = extend({}, e);\r\n  \t\t\tsynth.type = 'preclick';\r\n  \t\t\tthis._fireDOMEvent(synth, synth.type, canvasTargets);\r\n  \t\t}\r\n\r\n  \t\t// Find the layer the event is propagating from and its parents.\r\n  \t\tvar targets = this._findEventTargets(e, type);\r\n\r\n  \t\tif (canvasTargets) {\r\n  \t\t\tvar filtered = []; // pick only targets with listeners\r\n  \t\t\tfor (var i = 0; i < canvasTargets.length; i++) {\r\n  \t\t\t\tif (canvasTargets[i].listens(type, true)) {\r\n  \t\t\t\t\tfiltered.push(canvasTargets[i]);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\ttargets = filtered.concat(targets);\r\n  \t\t}\r\n\r\n  \t\tif (!targets.length) { return; }\r\n\r\n  \t\tif (type === 'contextmenu') {\r\n  \t\t\tpreventDefault(e);\r\n  \t\t}\r\n\r\n  \t\tvar target = targets[0];\r\n  \t\tvar data = {\r\n  \t\t\toriginalEvent: e\r\n  \t\t};\r\n\r\n  \t\tif (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\r\n  \t\t\tvar isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\r\n  \t\t\tdata.containerPoint = isMarker ?\r\n  \t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n  \t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n  \t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n  \t\t}\r\n\r\n  \t\tfor (i = 0; i < targets.length; i++) {\r\n  \t\t\ttargets[i].fire(type, data, true);\r\n  \t\t\tif (data.originalEvent._stopped ||\r\n  \t\t\t\t(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_draggableMoved: function (obj) {\r\n  \t\tobj = obj.dragging && obj.dragging.enabled() ? obj : this;\r\n  \t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n  \t},\r\n\r\n  \t_clearHandlers: function () {\r\n  \t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n  \t\t\tthis._handlers[i].disable();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method whenReady(fn: Function, context?: Object): this\r\n  \t// Runs the given function `fn` when the map gets initialized with\r\n  \t// a view (center and zoom) and at least one layer, or immediately\r\n  \t// if it's already initialized, optionally passing a function context.\r\n  \twhenReady: function (callback, context) {\r\n  \t\tif (this._loaded) {\r\n  \t\t\tcallback.call(context || this, {target: this});\r\n  \t\t} else {\r\n  \t\t\tthis.on('load', callback, context);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n\r\n  \t// private methods for getting map state\r\n\r\n  \t_getMapPanePos: function () {\r\n  \t\treturn getPosition(this._mapPane) || new Point(0, 0);\r\n  \t},\r\n\r\n  \t_moved: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\treturn pos && !pos.equals([0, 0]);\r\n  \t},\r\n\r\n  \t_getTopLeftPoint: function (center, zoom) {\r\n  \t\tvar pixelOrigin = center && zoom !== undefined ?\r\n  \t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n  \t\t\tthis.getPixelOrigin();\r\n  \t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t_getNewPixelOrigin: function (center, zoom) {\r\n  \t\tvar viewHalf = this.getSize()._divideBy(2);\r\n  \t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n  \t},\r\n\r\n  \t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n  \t},\r\n\r\n  \t_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn toBounds([\r\n  \t\t\tthis.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\r\n  \t\t]);\r\n  \t},\r\n\r\n  \t// layer point of the current center\r\n  \t_getCenterLayerPoint: function () {\r\n  \t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n  \t},\r\n\r\n  \t// offset of the specified place to the current center in pixels\r\n  \t_getCenterOffset: function (latlng) {\r\n  \t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// adjust center for view to get inside bounds\r\n  \t_limitCenter: function (center, zoom, bounds) {\r\n\r\n  \t\tif (!bounds) { return center; }\r\n\r\n  \t\tvar centerPoint = this.project(center, zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n  \t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n  \t\t// If offset is less than a pixel, ignore.\r\n  \t\t// This prevents unstable projections from getting into\r\n  \t\t// an infinite loop of tiny offsets.\r\n  \t\tif (offset.round().equals([0, 0])) {\r\n  \t\t\treturn center;\r\n  \t\t}\r\n\r\n  \t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n  \t},\r\n\r\n  \t// adjust offset for view to get inside bounds\r\n  \t_limitOffset: function (offset, bounds) {\r\n  \t\tif (!bounds) { return offset; }\r\n\r\n  \t\tvar viewBounds = this.getPixelBounds(),\r\n  \t\t    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n  \t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n  \t},\r\n\r\n  \t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n  \t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n  \t\tvar projectedMaxBounds = toBounds(\r\n  \t\t        this.project(maxBounds.getNorthEast(), zoom),\r\n  \t\t        this.project(maxBounds.getSouthWest(), zoom)\r\n  \t\t    ),\r\n  \t\t    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\r\n  \t\t    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\r\n\r\n  \t\t    dx = this._rebound(minOffset.x, -maxOffset.x),\r\n  \t\t    dy = this._rebound(minOffset.y, -maxOffset.y);\r\n\r\n  \t\treturn new Point(dx, dy);\r\n  \t},\r\n\r\n  \t_rebound: function (left, right) {\r\n  \t\treturn left + right > 0 ?\r\n  \t\t\tMath.round(left - right) / 2 :\r\n  \t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n  \t},\r\n\r\n  \t_limitZoom: function (zoom) {\r\n  \t\tvar min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1;\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / snap) * snap;\r\n  \t\t}\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t_onPanTransitionStep: function () {\r\n  \t\tthis.fire('move');\r\n  \t},\r\n\r\n  \t_onPanTransitionEnd: function () {\r\n  \t\tremoveClass(this._mapPane, 'leaflet-pan-anim');\r\n  \t\tthis.fire('moveend');\r\n  \t},\r\n\r\n  \t_tryAnimatedPan: function (center, options) {\r\n  \t\t// difference between the new and current centers in pixels\r\n  \t\tvar offset = this._getCenterOffset(center)._trunc();\r\n\r\n  \t\t// don't animate too far unless animate: true specified in options\r\n  \t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\tthis.panBy(offset, options);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_createAnimProxy: function () {\r\n\r\n  \t\tvar proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\r\n  \t\tthis._panes.mapPane.appendChild(proxy);\r\n\r\n  \t\tthis.on('zoomanim', function (e) {\r\n  \t\t\tvar prop = TRANSFORM,\r\n  \t\t\t    transform = this._proxy.style[prop];\r\n\r\n  \t\t\tsetTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\r\n\r\n  \t\t\t// workaround for case when transform is the same and so transitionend event is not fired\r\n  \t\t\tif (transform === this._proxy.style[prop] && this._animatingZoom) {\r\n  \t\t\t\tthis._onZoomTransitionEnd();\r\n  \t\t\t}\r\n  \t\t}, this);\r\n\r\n  \t\tthis.on('load moveend', this._animMoveEnd, this);\r\n\r\n  \t\tthis._on('unload', this._destroyAnimProxy, this);\r\n  \t},\r\n\r\n  \t_destroyAnimProxy: function () {\r\n  \t\tremove(this._proxy);\r\n  \t\tthis.off('load moveend', this._animMoveEnd, this);\r\n  \t\tdelete this._proxy;\r\n  \t},\r\n\r\n  \t_animMoveEnd: function () {\r\n  \t\tvar c = this.getCenter(),\r\n  \t\t    z = this.getZoom();\r\n  \t\tsetTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\r\n  \t},\r\n\r\n  \t_catchTransitionEnd: function (e) {\r\n  \t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\r\n  \t\t\tthis._onZoomTransitionEnd();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_nothingToAnimate: function () {\r\n  \t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\r\n  \t},\r\n\r\n  \t_tryAnimatedZoom: function (center, zoom, options) {\r\n\r\n  \t\tif (this._animatingZoom) { return true; }\r\n\r\n  \t\toptions = options || {};\r\n\r\n  \t\t// don't animate if disabled, not supported or zoom difference is too large\r\n  \t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\r\n  \t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\r\n\r\n  \t\t// offset is the pixel coords of the zoom origin relative to the current center\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\r\n\r\n  \t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\trequestAnimFrame(function () {\r\n  \t\t\tthis\r\n  \t\t\t    ._moveStart(true, false)\r\n  \t\t\t    ._animateZoom(center, zoom, true);\r\n  \t\t}, this);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_animateZoom: function (center, zoom, startAnim, noUpdate) {\r\n  \t\tif (!this._mapPane) { return; }\r\n\r\n  \t\tif (startAnim) {\r\n  \t\t\tthis._animatingZoom = true;\r\n\r\n  \t\t\t// remember what center/zoom to set after animation\r\n  \t\t\tthis._animateToCenter = center;\r\n  \t\t\tthis._animateToZoom = zoom;\r\n\r\n  \t\t\taddClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\t// @section Other Events\r\n  \t\t// @event zoomanim: ZoomAnimEvent\r\n  \t\t// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\r\n  \t\tthis.fire('zoomanim', {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom,\r\n  \t\t\tnoUpdate: noUpdate\r\n  \t\t});\r\n\r\n  \t\tif (!this._tempFireZoomEvent) {\r\n  \t\t\tthis._tempFireZoomEvent = this._zoom !== this._animateToZoom;\r\n  \t\t}\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\r\n  \t\tsetTimeout(bind(this._onZoomTransitionEnd, this), 250);\r\n  \t},\r\n\r\n  \t_onZoomTransitionEnd: function () {\r\n  \t\tif (!this._animatingZoom) { return; }\r\n\r\n  \t\tif (this._mapPane) {\r\n  \t\t\tremoveClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\tthis._animatingZoom = false;\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\tif (this._tempFireZoomEvent) {\r\n  \t\t\tthis.fire('zoom');\r\n  \t\t}\r\n  \t\tdelete this._tempFireZoomEvent;\r\n\r\n  \t\tthis.fire('move');\r\n\r\n  \t\tthis._moveEnd(true);\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n\r\n  // @factory L.map(id: String, options?: Map options)\r\n  // Instantiates a map object given the DOM ID of a `<div>` element\r\n  // and optionally an object literal with `Map options`.\r\n  //\r\n  // @alternative\r\n  // @factory L.map(el: HTMLElement, options?: Map options)\r\n  // Instantiates a map object given an instance of a `<div>` HTML element\r\n  // and optionally an object literal with `Map options`.\r\n  function createMap(id, options) {\r\n  \treturn new Map(id, options);\r\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\r\n\r\n  var Control = Class.extend({\r\n  \t// @section\r\n  \t// @aka Control Options\r\n  \toptions: {\r\n  \t\t// @option position: String = 'topright'\r\n  \t\t// The position of the control (one of the map corners). Possible values are `'topleft'`,\r\n  \t\t// `'topright'`, `'bottomleft'` or `'bottomright'`\r\n  \t\tposition: 'topright'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t * Classes extending L.Control will inherit the following methods:\r\n  \t *\r\n  \t * @method getPosition: string\r\n  \t * Returns the position of the control.\r\n  \t */\r\n  \tgetPosition: function () {\r\n  \t\treturn this.options.position;\r\n  \t},\r\n\r\n  \t// @method setPosition(position: string): this\r\n  \t// Sets the position of the control.\r\n  \tsetPosition: function (position) {\r\n  \t\tvar map = this._map;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.removeControl(this);\r\n  \t\t}\r\n\r\n  \t\tthis.options.position = position;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.addControl(this);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTMLElement that contains the control.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method addTo(map: Map): this\r\n  \t// Adds the control to the given map.\r\n  \taddTo: function (map) {\r\n  \t\tthis.remove();\r\n  \t\tthis._map = map;\r\n\r\n  \t\tvar container = this._container = this.onAdd(map),\r\n  \t\t    pos = this.getPosition(),\r\n  \t\t    corner = map._controlCorners[pos];\r\n\r\n  \t\taddClass(container, 'leaflet-control');\r\n\r\n  \t\tif (pos.indexOf('bottom') !== -1) {\r\n  \t\t\tcorner.insertBefore(container, corner.firstChild);\r\n  \t\t} else {\r\n  \t\t\tcorner.appendChild(container);\r\n  \t\t}\r\n\r\n  \t\tthis._map.on('unload', this.remove, this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove: this\r\n  \t// Removes the control from the map it is currently active on.\r\n  \tremove: function () {\r\n  \t\tif (!this._map) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tremove(this._container);\r\n\r\n  \t\tif (this.onRemove) {\r\n  \t\t\tthis.onRemove(this._map);\r\n  \t\t}\r\n\r\n  \t\tthis._map.off('unload', this.remove, this);\r\n  \t\tthis._map = null;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_refocusOnMap: function (e) {\r\n  \t\t// if map exists and event is not a keyboard event\r\n  \t\tif (this._map && e && e.screenX > 0 && e.screenY > 0) {\r\n  \t\t\tthis._map.getContainer().focus();\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  var control = function (options) {\r\n  \treturn new Control(options);\r\n  };\r\n\r\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\r\n\r\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\r\n  Map.include({\r\n  \t// @method addControl(control: Control): this\r\n  \t// Adds the given control to the map\r\n  \taddControl: function (control) {\r\n  \t\tcontrol.addTo(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeControl(control: Control): this\r\n  \t// Removes the given control from the map\r\n  \tremoveControl: function (control) {\r\n  \t\tcontrol.remove();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initControlPos: function () {\r\n  \t\tvar corners = this._controlCorners = {},\r\n  \t\t    l = 'leaflet-',\r\n  \t\t    container = this._controlContainer =\r\n  \t\t            create$1('div', l + 'control-container', this._container);\r\n\r\n  \t\tfunction createCorner(vSide, hSide) {\r\n  \t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n  \t\t\tcorners[vSide + hSide] = create$1('div', className, container);\r\n  \t\t}\r\n\r\n  \t\tcreateCorner('top', 'left');\r\n  \t\tcreateCorner('top', 'right');\r\n  \t\tcreateCorner('bottom', 'left');\r\n  \t\tcreateCorner('bottom', 'right');\r\n  \t},\r\n\r\n  \t_clearControlPos: function () {\r\n  \t\tfor (var i in this._controlCorners) {\r\n  \t\t\tremove(this._controlCorners[i]);\r\n  \t\t}\r\n  \t\tremove(this._controlContainer);\r\n  \t\tdelete this._controlCorners;\r\n  \t\tdelete this._controlContainer;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\r\n\r\n  var Layers = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Layers options\r\n  \toptions: {\r\n  \t\t// @option collapsed: Boolean = true\r\n  \t\t// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\r\n  \t\tcollapsed: true,\r\n  \t\tposition: 'topright',\r\n\r\n  \t\t// @option autoZIndex: Boolean = true\r\n  \t\t// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\r\n  \t\tautoZIndex: true,\r\n\r\n  \t\t// @option hideSingleBase: Boolean = false\r\n  \t\t// If `true`, the base layers in the control will be hidden when there is only one.\r\n  \t\thideSingleBase: false,\r\n\r\n  \t\t// @option sortLayers: Boolean = false\r\n  \t\t// Whether to sort the layers. When `false`, layers will keep the order\r\n  \t\t// in which they were added to the control.\r\n  \t\tsortLayers: false,\r\n\r\n  \t\t// @option sortFunction: Function = *\r\n  \t\t// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\r\n  \t\t// that will be used for sorting the layers, when `sortLayers` is `true`.\r\n  \t\t// The function receives both the `L.Layer` instances and their names, as in\r\n  \t\t// `sortFunction(layerA, layerB, nameA, nameB)`.\r\n  \t\t// By default, it sorts layers alphabetically by their name.\r\n  \t\tsortFunction: function (layerA, layerB, nameA, nameB) {\r\n  \t\t\treturn nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tinitialize: function (baseLayers, overlays, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tthis._layers = [];\r\n  \t\tthis._lastZIndex = 0;\r\n  \t\tthis._handlingClick = false;\r\n\r\n  \t\tfor (var i in baseLayers) {\r\n  \t\t\tthis._addLayer(baseLayers[i], i);\r\n  \t\t}\r\n\r\n  \t\tfor (i in overlays) {\r\n  \t\t\tthis._addLayer(overlays[i], i, true);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._initLayout();\r\n  \t\tthis._update();\r\n\r\n  \t\tthis._map = map;\r\n  \t\tmap.on('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \taddTo: function (map) {\r\n  \t\tControl.prototype.addTo.call(this, map);\r\n  \t\t// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\r\n  \t\treturn this._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tthis._map.off('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.off('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addBaseLayer(layer: Layer, name: String): this\r\n  \t// Adds a base layer (radio button entry) with the given name to the control.\r\n  \taddBaseLayer: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method addOverlay(layer: Layer, name: String): this\r\n  \t// Adds an overlay (checkbox entry) with the given name to the control.\r\n  \taddOverlay: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name, true);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Remove the given layer from the control.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tlayer.off('add remove', this._onLayerChange, this);\r\n\r\n  \t\tvar obj = this._getLayer(stamp(layer));\r\n  \t\tif (obj) {\r\n  \t\t\tthis._layers.splice(this._layers.indexOf(obj), 1);\r\n  \t\t}\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method expand(): this\r\n  \t// Expand the control container if collapsed.\r\n  \texpand: function () {\r\n  \t\taddClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\tthis._section.style.height = null;\r\n  \t\tvar acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\r\n  \t\tif (acceptableHeight < this._section.clientHeight) {\r\n  \t\t\taddClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t\tthis._section.style.height = acceptableHeight + 'px';\r\n  \t\t} else {\r\n  \t\t\tremoveClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t}\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method collapse(): this\r\n  \t// Collapse the control container if expanded.\r\n  \tcollapse: function () {\r\n  \t\tremoveClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar className = 'leaflet-control-layers',\r\n  \t\t    container = this._container = create$1('div', className),\r\n  \t\t    collapsed = this.options.collapsed;\r\n\r\n  \t\t// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\r\n  \t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(container);\r\n\r\n  \t\tvar section = this._section = create$1('section', className + '-list');\r\n\r\n  \t\tif (collapsed) {\r\n  \t\t\tthis._map.on('click', this.collapse, this);\r\n\r\n  \t\t\ton(container, {\r\n  \t\t\t\tmouseenter: function () {\r\n  \t\t\t\t\ton(section, 'click', preventDefault);\r\n  \t\t\t\t\tthis.expand();\r\n  \t\t\t\t\tsetTimeout(function () {\r\n  \t\t\t\t\t\toff(section, 'click', preventDefault);\r\n  \t\t\t\t\t});\r\n  \t\t\t\t},\r\n  \t\t\t\tmouseleave: this.collapse\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\tvar link = this._layersLink = create$1('a', className + '-toggle', container);\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = 'Layers';\r\n  \t\tlink.setAttribute('role', 'button');\r\n\r\n  \t\ton(link, 'click', preventDefault); // prevent link function\r\n  \t\ton(link, 'focus', this.expand, this);\r\n\r\n  \t\tif (!collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n\r\n  \t\tthis._baseLayersList = create$1('div', className + '-base', section);\r\n  \t\tthis._separator = create$1('div', className + '-separator', section);\r\n  \t\tthis._overlaysList = create$1('div', className + '-overlays', section);\r\n\r\n  \t\tcontainer.appendChild(section);\r\n  \t},\r\n\r\n  \t_getLayer: function (id) {\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n\r\n  \t\t\tif (this._layers[i] && stamp(this._layers[i].layer) === id) {\r\n  \t\t\t\treturn this._layers[i];\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_addLayer: function (layer, name, overlay) {\r\n  \t\tif (this._map) {\r\n  \t\t\tlayer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\tthis._layers.push({\r\n  \t\t\tlayer: layer,\r\n  \t\t\tname: name,\r\n  \t\t\toverlay: overlay\r\n  \t\t});\r\n\r\n  \t\tif (this.options.sortLayers) {\r\n  \t\t\tthis._layers.sort(bind(function (a, b) {\r\n  \t\t\t\treturn this.options.sortFunction(a.layer, b.layer, a.name, b.name);\r\n  \t\t\t}, this));\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n  \t\t\tthis._lastZIndex++;\r\n  \t\t\tlayer.setZIndex(this._lastZIndex);\r\n  \t\t}\r\n\r\n  \t\tthis._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._container) { return this; }\r\n\r\n  \t\tempty(this._baseLayersList);\r\n  \t\tempty(this._overlaysList);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tvar baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\r\n\r\n  \t\tfor (i = 0; i < this._layers.length; i++) {\r\n  \t\t\tobj = this._layers[i];\r\n  \t\t\tthis._addItem(obj);\r\n  \t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n  \t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n  \t\t\tbaseLayersCount += !obj.overlay ? 1 : 0;\r\n  \t\t}\r\n\r\n  \t\t// Hide base layers section if there's only one layer.\r\n  \t\tif (this.options.hideSingleBase) {\r\n  \t\t\tbaseLayersPresent = baseLayersPresent && baseLayersCount > 1;\r\n  \t\t\tthis._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\r\n  \t\t}\r\n\r\n  \t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_onLayerChange: function (e) {\r\n  \t\tif (!this._handlingClick) {\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\tvar obj = this._getLayer(stamp(e.target));\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Layer events\r\n  \t\t// @event baselayerchange: LayersControlEvent\r\n  \t\t// Fired when the base layer is changed through the [layers control](#control-layers).\r\n  \t\t// @event overlayadd: LayersControlEvent\r\n  \t\t// Fired when an overlay is selected through the [layers control](#control-layers).\r\n  \t\t// @event overlayremove: LayersControlEvent\r\n  \t\t// Fired when an overlay is deselected through the [layers control](#control-layers).\r\n  \t\t// @namespace Control.Layers\r\n  \t\tvar type = obj.overlay ?\r\n  \t\t\t(e.type === 'add' ? 'overlayadd' : 'overlayremove') :\r\n  \t\t\t(e.type === 'add' ? 'baselayerchange' : null);\r\n\r\n  \t\tif (type) {\r\n  \t\t\tthis._map.fire(type, obj);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\r\n  \t_createRadioElement: function (name, checked) {\r\n\r\n  \t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' +\r\n  \t\t\t\tname + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\r\n\r\n  \t\tvar radioFragment = document.createElement('div');\r\n  \t\tradioFragment.innerHTML = radioHtml;\r\n\r\n  \t\treturn radioFragment.firstChild;\r\n  \t},\r\n\r\n  \t_addItem: function (obj) {\r\n  \t\tvar label = document.createElement('label'),\r\n  \t\t    checked = this._map.hasLayer(obj.layer),\r\n  \t\t    input;\r\n\r\n  \t\tif (obj.overlay) {\r\n  \t\t\tinput = document.createElement('input');\r\n  \t\t\tinput.type = 'checkbox';\r\n  \t\t\tinput.className = 'leaflet-control-layers-selector';\r\n  \t\t\tinput.defaultChecked = checked;\r\n  \t\t} else {\r\n  \t\t\tinput = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\r\n  \t\t}\r\n\r\n  \t\tthis._layerControlInputs.push(input);\r\n  \t\tinput.layerId = stamp(obj.layer);\r\n\r\n  \t\ton(input, 'click', this._onInputClick, this);\r\n\r\n  \t\tvar name = document.createElement('span');\r\n  \t\tname.innerHTML = ' ' + obj.name;\r\n\r\n  \t\t// Helps from preventing layer control flicker when checkboxes are disabled\r\n  \t\t// https://github.com/Leaflet/Leaflet/issues/2771\r\n  \t\tvar holder = document.createElement('span');\r\n\r\n  \t\tlabel.appendChild(holder);\r\n  \t\tholder.appendChild(input);\r\n  \t\tholder.appendChild(name);\r\n\r\n  \t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n  \t\tcontainer.appendChild(label);\r\n\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn label;\r\n  \t},\r\n\r\n  \t_onInputClick: function () {\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input, layer;\r\n  \t\tvar addedLayers = [],\r\n  \t\t    removedLayers = [];\r\n\r\n  \t\tthis._handlingClick = true;\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n\r\n  \t\t\tif (input.checked) {\r\n  \t\t\t\taddedLayers.push(layer);\r\n  \t\t\t} else if (!input.checked) {\r\n  \t\t\t\tremovedLayers.push(layer);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// Bugfix issue 2318: Should remove all old layers before readding new ones\r\n  \t\tfor (i = 0; i < removedLayers.length; i++) {\r\n  \t\t\tif (this._map.hasLayer(removedLayers[i])) {\r\n  \t\t\t\tthis._map.removeLayer(removedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tfor (i = 0; i < addedLayers.length; i++) {\r\n  \t\t\tif (!this._map.hasLayer(addedLayers[i])) {\r\n  \t\t\t\tthis._map.addLayer(addedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._handlingClick = false;\r\n\r\n  \t\tthis._refocusOnMap();\r\n  \t},\r\n\r\n  \t_checkDisabledLayers: function () {\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input,\r\n  \t\t    layer,\r\n  \t\t    zoom = this._map.getZoom();\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n  \t\t\tinput.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||\r\n  \t\t\t                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);\r\n\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_expandIfNotCollapsed: function () {\r\n  \t\tif (this._map && !this.options.collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t}\r\n\r\n  });\r\n\r\n\r\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\r\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\r\n  var layers = function (baseLayers, overlays, options) {\r\n  \treturn new Layers(baseLayers, overlays, options);\r\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\r\n\r\n  var Zoom = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Zoom options\r\n  \toptions: {\r\n  \t\tposition: 'topleft',\r\n\r\n  \t\t// @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\r\n  \t\t// The text set on the 'zoom in' button.\r\n  \t\tzoomInText: '<span aria-hidden=\"true\">+</span>',\r\n\r\n  \t\t// @option zoomInTitle: String = 'Zoom in'\r\n  \t\t// The title set on the 'zoom in' button.\r\n  \t\tzoomInTitle: 'Zoom in',\r\n\r\n  \t\t// @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\r\n  \t\t// The text set on the 'zoom out' button.\r\n  \t\tzoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\r\n\r\n  \t\t// @option zoomOutTitle: String = 'Zoom out'\r\n  \t\t// The title set on the 'zoom out' button.\r\n  \t\tzoomOutTitle: 'Zoom out'\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tvar zoomName = 'leaflet-control-zoom',\r\n  \t\t    container = create$1('div', zoomName + ' leaflet-bar'),\r\n  \t\t    options = this.options;\r\n\r\n  \t\tthis._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,\r\n  \t\t        zoomName + '-in',  container, this._zoomIn);\r\n  \t\tthis._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,\r\n  \t\t        zoomName + '-out', container, this._zoomOut);\r\n\r\n  \t\tthis._updateDisabled();\r\n  \t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n  \t\treturn container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n  \t},\r\n\r\n  \tdisable: function () {\r\n  \t\tthis._disabled = true;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tenable: function () {\r\n  \t\tthis._disabled = false;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_zoomIn: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\r\n  \t\t\tthis._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_zoomOut: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\r\n  \t\t\tthis._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createButton: function (html, title, className, container, fn) {\r\n  \t\tvar link = create$1('a', className, container);\r\n  \t\tlink.innerHTML = html;\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = title;\r\n\r\n  \t\t/*\r\n  \t\t * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n  \t\t */\r\n  \t\tlink.setAttribute('role', 'button');\r\n  \t\tlink.setAttribute('aria-label', title);\r\n\r\n  \t\tdisableClickPropagation(link);\r\n  \t\ton(link, 'click', stop);\r\n  \t\ton(link, 'click', fn, this);\r\n  \t\ton(link, 'click', this._refocusOnMap, this);\r\n\r\n  \t\treturn link;\r\n  \t},\r\n\r\n  \t_updateDisabled: function () {\r\n  \t\tvar map = this._map,\r\n  \t\t    className = 'leaflet-disabled';\r\n\r\n  \t\tremoveClass(this._zoomInButton, className);\r\n  \t\tremoveClass(this._zoomOutButton, className);\r\n  \t\tthis._zoomInButton.setAttribute('aria-disabled', 'false');\r\n  \t\tthis._zoomOutButton.setAttribute('aria-disabled', 'false');\r\n\r\n  \t\tif (this._disabled || map._zoom === map.getMinZoom()) {\r\n  \t\t\taddClass(this._zoomOutButton, className);\r\n  \t\t\tthis._zoomOutButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t\tif (this._disabled || map._zoom === map.getMaxZoom()) {\r\n  \t\t\taddClass(this._zoomInButton, className);\r\n  \t\t\tthis._zoomInButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option zoomControl: Boolean = true\r\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tzoomControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.zoomControl) {\r\n  \t\t// @section Controls\r\n  \t\t// @property zoomControl: Control.Zoom\r\n  \t\t// The default zoom control (only available if the\r\n  \t\t// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\r\n  \t\tthis.zoomControl = new Zoom();\r\n  \t\tthis.addControl(this.zoomControl);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Zoom\r\n  // @factory L.control.zoom(options: Control.Zoom options)\r\n  // Creates a zoom control\r\n  var zoom = function (options) {\r\n  \treturn new Zoom(options);\r\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n  \t// @section\n  \t// @aka Control.Scale options\n  \toptions: {\n  \t\tposition: 'bottomleft',\n\n  \t\t// @option maxWidth: Number = 100\n  \t\t// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n  \t\tmaxWidth: 100,\n\n  \t\t// @option metric: Boolean = True\n  \t\t// Whether to show the metric scale line (m/km).\n  \t\tmetric: true,\n\n  \t\t// @option imperial: Boolean = True\n  \t\t// Whether to show the imperial scale line (mi/ft).\n  \t\timperial: true\n\n  \t\t// @option updateWhenIdle: Boolean = false\n  \t\t// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tvar className = 'leaflet-control-scale',\n  \t\t    container = create$1('div', className),\n  \t\t    options = this.options;\n\n  \t\tthis._addScales(options, className + '-line', container);\n\n  \t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t\tmap.whenReady(this._update, this);\n\n  \t\treturn container;\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t},\n\n  \t_addScales: function (options, className, container) {\n  \t\tif (options.metric) {\n  \t\t\tthis._mScale = create$1('div', className, container);\n  \t\t}\n  \t\tif (options.imperial) {\n  \t\t\tthis._iScale = create$1('div', className, container);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tvar map = this._map,\n  \t\t    y = map.getSize().y / 2;\n\n  \t\tvar maxMeters = map.distance(\n  \t\t\tmap.containerPointToLatLng([0, y]),\n  \t\t\tmap.containerPointToLatLng([this.options.maxWidth, y]));\n\n  \t\tthis._updateScales(maxMeters);\n  \t},\n\n  \t_updateScales: function (maxMeters) {\n  \t\tif (this.options.metric && maxMeters) {\n  \t\t\tthis._updateMetric(maxMeters);\n  \t\t}\n  \t\tif (this.options.imperial && maxMeters) {\n  \t\t\tthis._updateImperial(maxMeters);\n  \t\t}\n  \t},\n\n  \t_updateMetric: function (maxMeters) {\n  \t\tvar meters = this._getRoundNum(maxMeters),\n  \t\t    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\n  \t\tthis._updateScale(this._mScale, label, meters / maxMeters);\n  \t},\n\n  \t_updateImperial: function (maxMeters) {\n  \t\tvar maxFeet = maxMeters * 3.2808399,\n  \t\t    maxMiles, miles, feet;\n\n  \t\tif (maxFeet > 5280) {\n  \t\t\tmaxMiles = maxFeet / 5280;\n  \t\t\tmiles = this._getRoundNum(maxMiles);\n  \t\t\tthis._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n\n  \t\t} else {\n  \t\t\tfeet = this._getRoundNum(maxFeet);\n  \t\t\tthis._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n  \t\t}\n  \t},\n\n  \t_updateScale: function (scale, text, ratio) {\n  \t\tscale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n  \t\tscale.innerHTML = text;\n  \t},\n\n  \t_getRoundNum: function (num) {\n  \t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n  \t\t    d = num / pow10;\n\n  \t\td = d >= 10 ? 10 :\n  \t\t    d >= 5 ? 5 :\n  \t\t    d >= 3 ? 3 :\n  \t\t    d >= 2 ? 2 : 1;\n\n  \t\treturn pow10 * d;\n  \t}\n  });\n\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function (options) {\n  \treturn new Scale(options);\n  };\n\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\r\n\r\n\r\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\r\n\r\n  var Attribution = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Attribution options\r\n  \toptions: {\r\n  \t\tposition: 'bottomright',\r\n\r\n  \t\t// @option prefix: String|false = 'Leaflet'\r\n  \t\t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \t\tprefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._attributions = {};\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tmap.attributionControl = this;\r\n  \t\tthis._container = create$1('div', 'leaflet-control-attribution');\r\n  \t\tdisableClickPropagation(this._container);\r\n\r\n  \t\t// TODO ugly, refactor\r\n  \t\tfor (var i in map._layers) {\r\n  \t\t\tif (map._layers[i].getAttribution) {\r\n  \t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\tmap.on('layeradd', this._addAttribution, this);\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('layeradd', this._addAttribution, this);\r\n  \t},\r\n\r\n  \t_addAttribution: function (ev) {\r\n  \t\tif (ev.layer.getAttribution) {\r\n  \t\t\tthis.addAttribution(ev.layer.getAttribution());\r\n  \t\t\tev.layer.once('remove', function () {\r\n  \t\t\t\tthis.removeAttribution(ev.layer.getAttribution());\r\n  \t\t\t}, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setPrefix(prefix: String|false): this\r\n  \t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \tsetPrefix: function (prefix) {\r\n  \t\tthis.options.prefix = prefix;\r\n  \t\tthis._update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method addAttribution(text: String): this\r\n  \t// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\r\n  \taddAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (!this._attributions[text]) {\r\n  \t\t\tthis._attributions[text] = 0;\r\n  \t\t}\r\n  \t\tthis._attributions[text]++;\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeAttribution(text: String): this\r\n  \t// Removes an attribution text.\r\n  \tremoveAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (this._attributions[text]) {\r\n  \t\t\tthis._attributions[text]--;\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar attribs = [];\r\n\r\n  \t\tfor (var i in this._attributions) {\r\n  \t\t\tif (this._attributions[i]) {\r\n  \t\t\t\tattribs.push(i);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tvar prefixAndAttribs = [];\r\n\r\n  \t\tif (this.options.prefix) {\r\n  \t\t\tprefixAndAttribs.push(this.options.prefix);\r\n  \t\t}\r\n  \t\tif (attribs.length) {\r\n  \t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n  \t\t}\r\n\r\n  \t\tthis._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option attributionControl: Boolean = true\r\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tattributionControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.attributionControl) {\r\n  \t\tnew Attribution().addTo(this);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Attribution\r\n  // @factory L.control.attribution(options: Control.Attribution options)\r\n  // Creates an attribution control.\r\n  var attribution = function (options) {\r\n  \treturn new Attribution(options);\r\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t},\n\n  \t// @method enable(): this\n  \t// Enables the handler\n  \tenable: function () {\n  \t\tif (this._enabled) { return this; }\n\n  \t\tthis._enabled = true;\n  \t\tthis.addHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method disable(): this\n  \t// Disables the handler\n  \tdisable: function () {\n  \t\tif (!this._enabled) { return this; }\n\n  \t\tthis._enabled = false;\n  \t\tthis.removeHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method enabled(): Boolean\n  \t// Returns `true` if the handler is enabled\n  \tenabled: function () {\n  \t\treturn !!this._enabled;\n  \t}\n\n  \t// @section Extension methods\n  \t// Classes inheriting from `Handler` must implement the two following methods:\n  \t// @method addHooks()\n  \t// Called when the handler is enabled, should add event hooks.\n  \t// @method removeHooks()\n  \t// Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n  \tmap.addHandler(name, this);\n  \treturn this;\n  };\n\n  var Mixin = {Events: Events};\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\r\n\r\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\r\n\r\n  var Draggable = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section\r\n  \t\t// @aka Draggable options\r\n  \t\t// @option clickTolerance: Number = 3\r\n  \t\t// The max number of pixels a user can shift the mouse pointer during a click\r\n  \t\t// for it to be considered a valid click (as opposed to a mouse drag).\r\n  \t\tclickTolerance: 3\r\n  \t},\r\n\r\n  \t// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\r\n  \t// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\r\n  \tinitialize: function (element, dragStartTarget, preventOutline, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._element = element;\r\n  \t\tthis._dragStartTarget = dragStartTarget || element;\r\n  \t\tthis._preventOutline = preventOutline;\r\n  \t},\r\n\r\n  \t// @method enable()\r\n  \t// Enables the dragging ability\r\n  \tenable: function () {\r\n  \t\tif (this._enabled) { return; }\r\n\r\n  \t\ton(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = true;\r\n  \t},\r\n\r\n  \t// @method disable()\r\n  \t// Disables the dragging ability\r\n  \tdisable: function () {\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\t// If we're currently dragging this draggable,\r\n  \t\t// disabling it counts as first ending the drag.\r\n  \t\tif (Draggable._dragging === this) {\r\n  \t\t\tthis.finishDrag(true);\r\n  \t\t}\r\n\r\n  \t\toff(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = false;\r\n  \t\tthis._moved = false;\r\n  \t},\r\n\r\n  \t_onDown: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tthis._moved = false;\r\n\r\n  \t\tif (hasClass(this._element, 'leaflet-zoom-anim')) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length !== 1) {\r\n  \t\t\t// Finish dragging to avoid conflict with touchZoom\r\n  \t\t\tif (Draggable._dragging === this) {\r\n  \t\t\t\tthis.finishDrag();\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n  \t\tDraggable._dragging = this;  // Prevent dragging multiple objects at once.\r\n\r\n  \t\tif (this._preventOutline) {\r\n  \t\t\tpreventOutline(this._element);\r\n  \t\t}\r\n\r\n  \t\tdisableImageDrag();\r\n  \t\tdisableTextSelection();\r\n\r\n  \t\tif (this._moving) { return; }\r\n\r\n  \t\t// @event down: Event\r\n  \t\t// Fired when a drag is about to start.\r\n  \t\tthis.fire('down');\r\n\r\n  \t\tvar first = e.touches ? e.touches[0] : e,\r\n  \t\t    sizedParent = getSizedParentNode(this._element);\r\n\r\n  \t\tthis._startPoint = new Point(first.clientX, first.clientY);\r\n  \t\tthis._startPos = getPosition(this._element);\r\n\r\n  \t\t// Cache the scale, so that we can continuously compensate for it during drag (_onMove).\r\n  \t\tthis._parentScale = getScale(sizedParent);\r\n\r\n  \t\tvar mouseevent = e.type === 'mousedown';\r\n  \t\ton(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\r\n  \t\ton(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\r\n  \t},\r\n\r\n  \t_onMove: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length > 1) {\r\n  \t\t\tthis._moved = true;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n  \t\t    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return; }\r\n  \t\tif (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }\r\n\r\n  \t\t// We assume that the parent container's position, border and scale do not change for the duration of the drag.\r\n  \t\t// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\r\n  \t\t// and we can use the cached value for the scale.\r\n  \t\toffset.x /= this._parentScale.x;\r\n  \t\toffset.y /= this._parentScale.y;\r\n\r\n  \t\tpreventDefault(e);\r\n\r\n  \t\tif (!this._moved) {\r\n  \t\t\t// @event dragstart: Event\r\n  \t\t\t// Fired when a drag starts\r\n  \t\t\tthis.fire('dragstart');\r\n\r\n  \t\t\tthis._moved = true;\r\n\r\n  \t\t\taddClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\t\tthis._lastTarget = e.target || e.srcElement;\r\n  \t\t\t// IE and Edge do not give the <use> element, so fetch it\r\n  \t\t\t// if necessary\r\n  \t\t\tif (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\r\n  \t\t\t\tthis._lastTarget = this._lastTarget.correspondingUseElement;\r\n  \t\t\t}\r\n  \t\t\taddClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t}\r\n\r\n  \t\tthis._newPos = this._startPos.add(offset);\r\n  \t\tthis._moving = true;\r\n\r\n  \t\tthis._lastEvent = e;\r\n  \t\tthis._updatePosition();\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tvar e = {originalEvent: this._lastEvent};\r\n\r\n  \t\t// @event predrag: Event\r\n  \t\t// Fired continuously during dragging *before* each corresponding\r\n  \t\t// update of the element's position.\r\n  \t\tthis.fire('predrag', e);\r\n  \t\tsetPosition(this._element, this._newPos);\r\n\r\n  \t\t// @event drag: Event\r\n  \t\t// Fired continuously during dragging.\r\n  \t\tthis.fire('drag', e);\r\n  \t},\r\n\r\n  \t_onUp: function () {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n  \t\tthis.finishDrag();\r\n  \t},\r\n\r\n  \tfinishDrag: function (noInertia) {\r\n  \t\tremoveClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\tif (this._lastTarget) {\r\n  \t\t\tremoveClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t\tthis._lastTarget = null;\r\n  \t\t}\r\n\r\n  \t\toff(document, 'mousemove touchmove', this._onMove, this);\r\n  \t\toff(document, 'mouseup touchend touchcancel', this._onUp, this);\r\n\r\n  \t\tenableImageDrag();\r\n  \t\tenableTextSelection();\r\n\r\n  \t\tif (this._moved && this._moving) {\r\n\r\n  \t\t\t// @event dragend: DragEndEvent\r\n  \t\t\t// Fired when the drag ends.\r\n  \t\t\tthis.fire('dragend', {\r\n  \t\t\t\tnoInertia: noInertia,\r\n  \t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tthis._moving = false;\r\n  \t\tDraggable._dragging = false;\r\n  \t}\r\n\r\n  });\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\r\n\r\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n  // Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n  // @function simplify(points: Point[], tolerance: Number): Point[]\r\n  // Dramatically reduces the number of points in a polyline while retaining\r\n  // its shape and returns a new array of simplified points, using the\r\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\r\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\r\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\r\n  // simplification (lesser value means higher quality but slower and with more points).\r\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\r\n  function simplify(points, tolerance) {\r\n  \tif (!tolerance || !points.length) {\r\n  \t\treturn points.slice();\r\n  \t}\r\n\r\n  \tvar sqTolerance = tolerance * tolerance;\r\n\r\n  \t    // stage 1: vertex reduction\r\n  \t    points = _reducePoints(points, sqTolerance);\r\n\r\n  \t    // stage 2: Douglas-Peucker simplification\r\n  \t    points = _simplifyDP(points, sqTolerance);\r\n\r\n  \treturn points;\r\n  }\r\n\r\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the distance between point `p` and segment `p1` to `p2`.\r\n  function pointToSegmentDistance(p, p1, p2) {\r\n  \treturn Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\r\n  }\r\n\r\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\r\n  function closestPointOnSegment(p, p1, p2) {\r\n  \treturn _sqClosestPointOnSegment(p, p1, p2);\r\n  }\r\n\r\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\r\n  function _simplifyDP(points, sqTolerance) {\r\n\r\n  \tvar len = points.length,\r\n  \t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n  \t    markers = new ArrayConstructor(len);\r\n\r\n  \t    markers[0] = markers[len - 1] = 1;\r\n\r\n  \t_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n  \tvar i,\r\n  \t    newPoints = [];\r\n\r\n  \tfor (i = 0; i < len; i++) {\r\n  \t\tif (markers[i]) {\r\n  \t\t\tnewPoints.push(points[i]);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn newPoints;\r\n  }\r\n\r\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\r\n\r\n  \tvar maxSqDist = 0,\r\n  \tindex, i, sqDist;\r\n\r\n  \tfor (i = first + 1; i <= last - 1; i++) {\r\n  \t\tsqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n  \t\tif (sqDist > maxSqDist) {\r\n  \t\t\tindex = i;\r\n  \t\t\tmaxSqDist = sqDist;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tif (maxSqDist > sqTolerance) {\r\n  \t\tmarkers[index] = 1;\r\n\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, first, index);\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, index, last);\r\n  \t}\r\n  }\r\n\r\n  // reduce points that are too close to each other to a single point\r\n  function _reducePoints(points, sqTolerance) {\r\n  \tvar reducedPoints = [points[0]];\r\n\r\n  \tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n  \t\tif (_sqDist(points[i], points[prev]) > sqTolerance) {\r\n  \t\t\treducedPoints.push(points[i]);\r\n  \t\t\tprev = i;\r\n  \t\t}\r\n  \t}\r\n  \tif (prev < len - 1) {\r\n  \t\treducedPoints.push(points[len - 1]);\r\n  \t}\r\n  \treturn reducedPoints;\r\n  }\r\n\r\n  var _lastCode;\r\n\r\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\r\n  // Clips the segment a to b by rectangular bounds with the\r\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\r\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\r\n  // points that are on the screen or near, increasing performance.\r\n  function clipSegment(a, b, bounds, useLastCode, round) {\r\n  \tvar codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\r\n  \t    codeB = _getBitCode(b, bounds),\r\n\r\n  \t    codeOut, p, newCode;\r\n\r\n  \t    // save 2nd code to avoid calculating it on the next segment\r\n  \t    _lastCode = codeB;\r\n\r\n  \twhile (true) {\r\n  \t\t// if a,b is inside the clip window (trivial accept)\r\n  \t\tif (!(codeA | codeB)) {\r\n  \t\t\treturn [a, b];\r\n  \t\t}\r\n\r\n  \t\t// if a,b is outside the clip window (trivial reject)\r\n  \t\tif (codeA & codeB) {\r\n  \t\t\treturn false;\r\n  \t\t}\r\n\r\n  \t\t// other cases\r\n  \t\tcodeOut = codeA || codeB;\r\n  \t\tp = _getEdgeIntersection(a, b, codeOut, bounds, round);\r\n  \t\tnewCode = _getBitCode(p, bounds);\r\n\r\n  \t\tif (codeOut === codeA) {\r\n  \t\t\ta = p;\r\n  \t\t\tcodeA = newCode;\r\n  \t\t} else {\r\n  \t\t\tb = p;\r\n  \t\t\tcodeB = newCode;\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  function _getEdgeIntersection(a, b, code, bounds, round) {\r\n  \tvar dx = b.x - a.x,\r\n  \t    dy = b.y - a.y,\r\n  \t    min = bounds.min,\r\n  \t    max = bounds.max,\r\n  \t    x, y;\r\n\r\n  \tif (code & 8) { // top\r\n  \t\tx = a.x + dx * (max.y - a.y) / dy;\r\n  \t\ty = max.y;\r\n\r\n  \t} else if (code & 4) { // bottom\r\n  \t\tx = a.x + dx * (min.y - a.y) / dy;\r\n  \t\ty = min.y;\r\n\r\n  \t} else if (code & 2) { // right\r\n  \t\tx = max.x;\r\n  \t\ty = a.y + dy * (max.x - a.x) / dx;\r\n\r\n  \t} else if (code & 1) { // left\r\n  \t\tx = min.x;\r\n  \t\ty = a.y + dy * (min.x - a.x) / dx;\r\n  \t}\r\n\r\n  \treturn new Point(x, y, round);\r\n  }\r\n\r\n  function _getBitCode(p, bounds) {\r\n  \tvar code = 0;\r\n\r\n  \tif (p.x < bounds.min.x) { // left\r\n  \t\tcode |= 1;\r\n  \t} else if (p.x > bounds.max.x) { // right\r\n  \t\tcode |= 2;\r\n  \t}\r\n\r\n  \tif (p.y < bounds.min.y) { // bottom\r\n  \t\tcode |= 4;\r\n  \t} else if (p.y > bounds.max.y) { // top\r\n  \t\tcode |= 8;\r\n  \t}\r\n\r\n  \treturn code;\r\n  }\r\n\r\n  // square distance (to avoid unnecessary Math.sqrt calls)\r\n  function _sqDist(p1, p2) {\r\n  \tvar dx = p2.x - p1.x,\r\n  \t    dy = p2.y - p1.y;\r\n  \treturn dx * dx + dy * dy;\r\n  }\r\n\r\n  // return closest point on segment or distance to that point\r\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\r\n  \tvar x = p1.x,\r\n  \t    y = p1.y,\r\n  \t    dx = p2.x - x,\r\n  \t    dy = p2.y - y,\r\n  \t    dot = dx * dx + dy * dy,\r\n  \t    t;\r\n\r\n  \tif (dot > 0) {\r\n  \t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n  \t\tif (t > 1) {\r\n  \t\t\tx = p2.x;\r\n  \t\t\ty = p2.y;\r\n  \t\t} else if (t > 0) {\r\n  \t\t\tx += dx * t;\r\n  \t\t\ty += dy * t;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tdx = p.x - x;\r\n  \tdy = p.y - y;\r\n\r\n  \treturn sqDist ? dx * dx + dy * dy : new Point(x, y);\r\n  }\r\n\r\n\r\n  // @function isFlat(latlngs: LatLng[]): Boolean\r\n  // Returns true if `latlngs` is a flat array, false is nested.\r\n  function isFlat(latlngs) {\r\n  \treturn !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\r\n  }\r\n\r\n  function _flat(latlngs) {\r\n  \tconsole.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\r\n  \treturn isFlat(latlngs);\r\n  }\n\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  };\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\r\n\r\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\r\n  function clipPolygon(points, bounds, round) {\r\n  \tvar clippedPoints,\r\n  \t    edges = [1, 4, 2, 8],\r\n  \t    i, j, k,\r\n  \t    a, b,\r\n  \t    len, edge, p;\r\n\r\n  \tfor (i = 0, len = points.length; i < len; i++) {\r\n  \t\tpoints[i]._code = _getBitCode(points[i], bounds);\r\n  \t}\r\n\r\n  \t// for each edge (left, bottom, right, top)\r\n  \tfor (k = 0; k < 4; k++) {\r\n  \t\tedge = edges[k];\r\n  \t\tclippedPoints = [];\r\n\r\n  \t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n  \t\t\ta = points[i];\r\n  \t\t\tb = points[j];\r\n\r\n  \t\t\t// if a is inside the clip window\r\n  \t\t\tif (!(a._code & edge)) {\r\n  \t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n  \t\t\t\tif (b._code & edge) {\r\n  \t\t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\t\tclippedPoints.push(p);\r\n  \t\t\t\t}\r\n  \t\t\t\tclippedPoints.push(a);\r\n\r\n  \t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n  \t\t\t} else if (!(b._code & edge)) {\r\n  \t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\tclippedPoints.push(p);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tpoints = clippedPoints;\r\n  \t}\r\n\r\n  \treturn points;\r\n  }\n\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\r\n\r\n  var LonLat = {\r\n  \tproject: function (latlng) {\r\n  \t\treturn new Point(latlng.lng, latlng.lat);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\treturn new LatLng(point.y, point.x);\r\n  \t},\r\n\r\n  \tbounds: new Bounds([-180, -90], [180, 90])\r\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\r\n\r\n  var Mercator = {\r\n  \tR: 6378137,\r\n  \tR_MINOR: 6356752.314245179,\r\n\r\n  \tbounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    r = this.R,\r\n  \t\t    y = latlng.lat * d,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    con = e * Math.sin(y);\r\n\r\n  \t\tvar ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\ty = -r * Math.log(Math.max(ts, 1E-10));\r\n\r\n  \t\treturn new Point(latlng.lng * d * r, y);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI,\r\n  \t\t    r = this.R,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    ts = Math.exp(-point.y / r),\r\n  \t\t    phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n\r\n  \t\tfor (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n  \t\t\tcon = e * Math.sin(phi);\r\n  \t\t\tcon = Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\t\tdphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n  \t\t\tphi += dphi;\r\n  \t\t}\r\n\r\n  \t\treturn new LatLng(phi * d, point.x * d / r);\r\n  \t}\r\n  };\n\n  /*\n   * @class Projection\n\n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n\n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n\n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n\n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n\n   * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n\n   */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\r\n  var EPSG3395 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3395',\r\n  \tprojection: Mercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * Mercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\r\n\r\n  var EPSG4326 = extend({}, Earth, {\r\n  \tcode: 'EPSG:4326',\r\n  \tprojection: LonLat,\r\n  \ttransformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\r\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n  \tprojection: LonLat,\n  \ttransformation: toTransformation(1, 0, -1, 0),\n\n  \tscale: function (zoom) {\n  \t\treturn Math.pow(2, zoom);\n  \t},\n\n  \tzoom: function (scale) {\n  \t\treturn Math.log(scale) / Math.LN2;\n  \t},\n\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar dx = latlng2.lng - latlng1.lng,\n  \t\t    dy = latlng2.lat - latlng1.lat;\n\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n\n  \tinfinite: true\n  });\n\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n\n  var Layer = Evented.extend({\n\n  \t// Classes extending `L.Layer` will inherit the following options:\n  \toptions: {\n  \t\t// @option pane: String = 'overlayPane'\n  \t\t// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n  \t\tpane: 'overlayPane',\n\n  \t\t// @option attribution: String = null\n  \t\t// String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n  \t\tattribution: null,\n\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \t/* @section\n  \t * Classes extending `L.Layer` will inherit the following methods:\n  \t *\n  \t * @method addTo(map: Map|LayerGroup): this\n  \t * Adds the layer to the given map or layer group.\n  \t */\n  \taddTo: function (map) {\n  \t\tmap.addLayer(this);\n  \t\treturn this;\n  \t},\n\n  \t// @method remove: this\n  \t// Removes the layer from the map it is currently active on.\n  \tremove: function () {\n  \t\treturn this.removeFrom(this._map || this._mapToAdd);\n  \t},\n\n  \t// @method removeFrom(map: Map): this\n  \t// Removes the layer from the given map\n  \t//\n  \t// @alternative\n  \t// @method removeFrom(group: LayerGroup): this\n  \t// Removes the layer from the given `LayerGroup`\n  \tremoveFrom: function (obj) {\n  \t\tif (obj) {\n  \t\t\tobj.removeLayer(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getPane(name? : String): HTMLElement\n  \t// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n  \tgetPane: function (name) {\n  \t\treturn this._map.getPane(name ? (this.options[name] || name) : this.options.pane);\n  \t},\n\n  \taddInteractiveTarget: function (targetEl) {\n  \t\tthis._map._targets[stamp(targetEl)] = this;\n  \t\treturn this;\n  \t},\n\n  \tremoveInteractiveTarget: function (targetEl) {\n  \t\tdelete this._map._targets[stamp(targetEl)];\n  \t\treturn this;\n  \t},\n\n  \t// @method getAttribution: String\n  \t// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n  \tgetAttribution: function () {\n  \t\treturn this.options.attribution;\n  \t},\n\n  \t_layerAdd: function (e) {\n  \t\tvar map = e.target;\n\n  \t\t// check in case layer gets added and then removed before the map is ready\n  \t\tif (!map.hasLayer(this)) { return; }\n\n  \t\tthis._map = map;\n  \t\tthis._zoomAnimated = map._zoomAnimated;\n\n  \t\tif (this.getEvents) {\n  \t\t\tvar events = this.getEvents();\n  \t\t\tmap.on(events, this);\n  \t\t\tthis.once('remove', function () {\n  \t\t\t\tmap.off(events, this);\n  \t\t\t}, this);\n  \t\t}\n\n  \t\tthis.onAdd(map);\n\n  \t\tthis.fire('add');\n  \t\tmap.fire('layeradd', {layer: this});\n  \t}\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n  \t// @method addLayer(layer: Layer): this\n  \t// Adds the given layer to the map\n  \taddLayer: function (layer) {\n  \t\tif (!layer._layerAdd) {\n  \t\t\tthrow new Error('The provided object is not a Layer.');\n  \t\t}\n\n  \t\tvar id = stamp(layer);\n  \t\tif (this._layers[id]) { return this; }\n  \t\tthis._layers[id] = layer;\n\n  \t\tlayer._mapToAdd = this;\n\n  \t\tif (layer.beforeAdd) {\n  \t\t\tlayer.beforeAdd(this);\n  \t\t}\n\n  \t\tthis.whenReady(layer._layerAdd, layer);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method removeLayer(layer: Layer): this\n  \t// Removes the given layer from the map.\n  \tremoveLayer: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (!this._layers[id]) { return this; }\n\n  \t\tif (this._loaded) {\n  \t\t\tlayer.onRemove(this);\n  \t\t}\n\n  \t\tdelete this._layers[id];\n\n  \t\tif (this._loaded) {\n  \t\t\tthis.fire('layerremove', {layer: layer});\n  \t\t\tlayer.fire('remove');\n  \t\t}\n\n  \t\tlayer._map = layer._mapToAdd = null;\n\n  \t\treturn this;\n  \t},\n\n  \t// @method hasLayer(layer: Layer): Boolean\n  \t// Returns `true` if the given layer is currently added to the map\n  \thasLayer: function (layer) {\n  \t\treturn stamp(layer) in this._layers;\n  \t},\n\n  \t/* @method eachLayer(fn: Function, context?: Object): this\n  \t * Iterates over the layers of the map, optionally specifying context of the iterator function.\n  \t * ```\n  \t * map.eachLayer(function(layer){\n  \t *     layer.bindPopup('Hello');\n  \t * });\n  \t * ```\n  \t */\n  \teachLayer: function (method, context) {\n  \t\tfor (var i in this._layers) {\n  \t\t\tmethod.call(context, this._layers[i]);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_addLayers: function (layers) {\n  \t\tlayers = layers ? (isArray(layers) ? layers : [layers]) : [];\n\n  \t\tfor (var i = 0, len = layers.length; i < len; i++) {\n  \t\t\tthis.addLayer(layers[i]);\n  \t\t}\n  \t},\n\n  \t_addZoomLimit: function (layer) {\n  \t\tif (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n  \t\t\tthis._zoomBoundLayers[stamp(layer)] = layer;\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_removeZoomLimit: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (this._zoomBoundLayers[id]) {\n  \t\t\tdelete this._zoomBoundLayers[id];\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_updateZoomLevels: function () {\n  \t\tvar minZoom = Infinity,\n  \t\t    maxZoom = -Infinity,\n  \t\t    oldZoomSpan = this._getZoomSpan();\n\n  \t\tfor (var i in this._zoomBoundLayers) {\n  \t\t\tvar options = this._zoomBoundLayers[i].options;\n\n  \t\t\tminZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n  \t\t\tmaxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n  \t\t}\n\n  \t\tthis._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n  \t\tthis._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n  \t\t// @section Map state change events\n  \t\t// @event zoomlevelschange: Event\n  \t\t// Fired when the number of zoomlevels on the map is changed due\n  \t\t// to adding or removing a layer.\n  \t\tif (oldZoomSpan !== this._getZoomSpan()) {\n  \t\t\tthis.fire('zoomlevelschange');\n  \t\t}\n\n  \t\tif (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n  \t\t\tthis.setZoom(this._layersMaxZoom);\n  \t\t}\n  \t\tif (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n  \t\t\tthis.setZoom(this._layersMinZoom);\n  \t\t}\n  \t}\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var LayerGroup = Layer.extend({\r\n\r\n  \tinitialize: function (layers, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tvar i, len;\r\n\r\n  \t\tif (layers) {\r\n  \t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n  \t\t\t\tthis.addLayer(layers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addLayer(layer: Layer): this\r\n  \t// Adds the given layer to the group.\r\n  \taddLayer: function (layer) {\r\n  \t\tvar id = this.getLayerId(layer);\r\n\r\n  \t\tthis._layers[id] = layer;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.addLayer(layer);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Removes the given layer from the group.\r\n  \t// @alternative\r\n  \t// @method removeLayer(id: Number): this\r\n  \t// Removes the layer with the given internal ID from the group.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n  \t\tif (this._map && this._layers[id]) {\r\n  \t\t\tthis._map.removeLayer(this._layers[id]);\r\n  \t\t}\r\n\r\n  \t\tdelete this._layers[id];\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method hasLayer(layer: Layer): Boolean\r\n  \t// Returns `true` if the given layer is currently added to the group.\r\n  \t// @alternative\r\n  \t// @method hasLayer(id: Number): Boolean\r\n  \t// Returns `true` if the given internal ID is currently added to the group.\r\n  \thasLayer: function (layer) {\r\n  \t\tvar layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\r\n  \t\treturn layerId in this._layers;\r\n  \t},\r\n\r\n  \t// @method clearLayers(): this\r\n  \t// Removes all the layers from the group.\r\n  \tclearLayers: function () {\r\n  \t\treturn this.eachLayer(this.removeLayer, this);\r\n  \t},\r\n\r\n  \t// @method invoke(methodName: String, …): this\r\n  \t// Calls `methodName` on every layer contained in this group, passing any\r\n  \t// additional parameters. Has no effect if the layers contained do not\r\n  \t// implement `methodName`.\r\n  \tinvoke: function (methodName) {\r\n  \t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n  \t\t    i, layer;\r\n\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tlayer = this._layers[i];\r\n\r\n  \t\t\tif (layer[methodName]) {\r\n  \t\t\t\tlayer[methodName].apply(layer, args);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis.eachLayer(map.addLayer, map);\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tthis.eachLayer(map.removeLayer, map);\r\n  \t},\r\n\r\n  \t// @method eachLayer(fn: Function, context?: Object): this\r\n  \t// Iterates over the layers of the group, optionally specifying context of the iterator function.\r\n  \t// ```js\r\n  \t// group.eachLayer(function (layer) {\r\n  \t// \tlayer.bindPopup('Hello');\r\n  \t// });\r\n  \t// ```\r\n  \teachLayer: function (method, context) {\r\n  \t\tfor (var i in this._layers) {\r\n  \t\t\tmethod.call(context, this._layers[i]);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getLayer(id: Number): Layer\r\n  \t// Returns the layer with the given internal ID.\r\n  \tgetLayer: function (id) {\r\n  \t\treturn this._layers[id];\r\n  \t},\r\n\r\n  \t// @method getLayers(): Layer[]\r\n  \t// Returns an array of all the layers added to the group.\r\n  \tgetLayers: function () {\r\n  \t\tvar layers = [];\r\n  \t\tthis.eachLayer(layers.push, layers);\r\n  \t\treturn layers;\r\n  \t},\r\n\r\n  \t// @method setZIndex(zIndex: Number): this\r\n  \t// Calls `setZIndex` on every layer contained in this group, passing the z-index.\r\n  \tsetZIndex: function (zIndex) {\r\n  \t\treturn this.invoke('setZIndex', zIndex);\r\n  \t},\r\n\r\n  \t// @method getLayerId(layer: Layer): Number\r\n  \t// Returns the internal ID for a layer\r\n  \tgetLayerId: function (layer) {\r\n  \t\treturn stamp(layer);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\r\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\r\n  var layerGroup = function (layers, options) {\r\n  \treturn new LayerGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var FeatureGroup = LayerGroup.extend({\r\n\r\n  \taddLayer: function (layer) {\r\n  \t\tif (this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tlayer.addEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n  \t\t// @event layeradd: LayerEvent\r\n  \t\t// Fired when a layer is added to this `FeatureGroup`\r\n  \t\treturn this.fire('layeradd', {layer: layer});\r\n  \t},\r\n\r\n  \tremoveLayer: function (layer) {\r\n  \t\tif (!this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tif (layer in this._layers) {\r\n  \t\t\tlayer = this._layers[layer];\r\n  \t\t}\r\n\r\n  \t\tlayer.removeEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n  \t\t// @event layerremove: LayerEvent\r\n  \t\t// Fired when a layer is removed from this `FeatureGroup`\r\n  \t\treturn this.fire('layerremove', {layer: layer});\r\n  \t},\r\n\r\n  \t// @method setStyle(style: Path options): this\r\n  \t// Sets the given path options to each layer of the group that has a `setStyle` method.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.invoke('setStyle', style);\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer group to the top of all other layers\r\n  \tbringToFront: function () {\r\n  \t\treturn this.invoke('bringToFront');\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer group to the back of all other layers\r\n  \tbringToBack: function () {\r\n  \t\treturn this.invoke('bringToBack');\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = new LatLngBounds();\r\n\r\n  \t\tfor (var id in this._layers) {\r\n  \t\t\tvar layer = this._layers[id];\r\n  \t\t\tbounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\r\n  \t\t}\r\n  \t\treturn bounds;\r\n  \t}\r\n  });\r\n\r\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\r\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\r\n  var featureGroup = function (layers, options) {\r\n  \treturn new FeatureGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\r\n\r\n  var Icon = Class.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka Icon options\r\n  \t *\r\n  \t * @option iconUrl: String = null\r\n  \t * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n  \t *\r\n  \t * @option iconRetinaUrl: String = null\r\n  \t * The URL to a retina sized version of the icon image (absolute or relative to your\r\n  \t * script path). Used for Retina screen devices.\r\n  \t *\r\n  \t * @option iconSize: Point = null\r\n  \t * Size of the icon image in pixels.\r\n  \t *\r\n  \t * @option iconAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n  \t * will be aligned so that this point is at the marker's geographical location. Centered\r\n  \t * by default if size is specified, also can be set in CSS with negative margins.\r\n  \t *\r\n  \t * @option popupAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option tooltipAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option shadowUrl: String = null\r\n  \t * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n  \t *\r\n  \t * @option shadowRetinaUrl: String = null\r\n  \t *\r\n  \t * @option shadowSize: Point = null\r\n  \t * Size of the shadow image in pixels.\r\n  \t *\r\n  \t * @option shadowAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n  \t * as iconAnchor if not specified).\r\n  \t *\r\n  \t * @option className: String = ''\r\n  \t * A custom class name to assign to both icon and shadow images. Empty by default.\r\n  \t */\r\n\r\n  \toptions: {\r\n  \t\tpopupAnchor: [0, 0],\r\n  \t\ttooltipAnchor: [0, 0],\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t// @method createIcon(oldIcon?: HTMLElement): HTMLElement\r\n  \t// Called internally when the icon has to be shown, returns a `<img>` HTML element\r\n  \t// styled according to the options.\r\n  \tcreateIcon: function (oldIcon) {\r\n  \t\treturn this._createIcon('icon', oldIcon);\r\n  \t},\r\n\r\n  \t// @method createShadow(oldIcon?: HTMLElement): HTMLElement\r\n  \t// As `createIcon`, but for the shadow beneath it.\r\n  \tcreateShadow: function (oldIcon) {\r\n  \t\treturn this._createIcon('shadow', oldIcon);\r\n  \t},\r\n\r\n  \t_createIcon: function (name, oldIcon) {\r\n  \t\tvar src = this._getIconUrl(name);\r\n\r\n  \t\tif (!src) {\r\n  \t\t\tif (name === 'icon') {\r\n  \t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n  \t\t\t}\r\n  \t\t\treturn null;\r\n  \t\t}\r\n\r\n  \t\tvar img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\r\n  \t\tthis._setIconStyles(img, name);\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\treturn img;\r\n  \t},\r\n\r\n  \t_setIconStyles: function (img, name) {\r\n  \t\tvar options = this.options;\r\n  \t\tvar sizeOption = options[name + 'Size'];\r\n\r\n  \t\tif (typeof sizeOption === 'number') {\r\n  \t\t\tsizeOption = [sizeOption, sizeOption];\r\n  \t\t}\r\n\r\n  \t\tvar size = toPoint(sizeOption),\r\n  \t\t    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n  \t\t            size && size.divideBy(2, true));\r\n\r\n  \t\timg.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n  \t\tif (anchor) {\r\n  \t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n  \t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n  \t\t}\r\n\r\n  \t\tif (size) {\r\n  \t\t\timg.style.width  = size.x + 'px';\r\n  \t\t\timg.style.height = size.y + 'px';\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createImg: function (src, el) {\r\n  \t\tel = el || document.createElement('img');\r\n  \t\tel.src = src;\r\n  \t\treturn el;\r\n  \t},\r\n\r\n  \t_getIconUrl: function (name) {\r\n  \t\treturn Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.icon(options: Icon options)\r\n  // Creates an icon instance with the given options.\r\n  function icon(options) {\r\n  \treturn new Icon(options);\r\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n\n  \toptions: {\n  \t\ticonUrl:       'marker-icon.png',\n  \t\ticonRetinaUrl: 'marker-icon-2x.png',\n  \t\tshadowUrl:     'marker-shadow.png',\n  \t\ticonSize:    [25, 41],\n  \t\ticonAnchor:  [12, 41],\n  \t\tpopupAnchor: [1, -34],\n  \t\ttooltipAnchor: [16, -28],\n  \t\tshadowSize:  [41, 41]\n  \t},\n\n  \t_getIconUrl: function (name) {\n  \t\tif (typeof IconDefault.imagePath !== 'string') {\t// Deprecated, backwards-compatibility only\n  \t\t\tIconDefault.imagePath = this._detectIconPath();\n  \t\t}\n\n  \t\t// @option imagePath: String\n  \t\t// `Icon.Default` will try to auto-detect the location of the\n  \t\t// blue icon images. If you are placing these images in a non-standard\n  \t\t// way, set this option to point to the right path.\n  \t\treturn (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n  \t},\n\n  \t_stripUrl: function (path) {\t// separate function to use in tests\n  \t\tvar strip = function (str, re, idx) {\n  \t\t\tvar match = re.exec(str);\n  \t\t\treturn match && match[idx];\n  \t\t};\n  \t\tpath = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n  \t\treturn path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n  \t},\n\n  \t_detectIconPath: function () {\n  \t\tvar el = create$1('div',  'leaflet-default-icon-path', document.body);\n  \t\tvar path = getStyle(el, 'background-image') ||\n  \t\t           getStyle(el, 'backgroundImage');\t// IE8\n\n  \t\tdocument.body.removeChild(el);\n  \t\tpath = this._stripUrl(path);\n  \t\tif (path) { return path; }\n  \t\tvar link = document.querySelector('link[href$=\"leaflet.css\"]');\n  \t\tif (!link) { return ''; }\n  \t\treturn link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n  \t}\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n  \tinitialize: function (marker) {\n  \t\tthis._marker = marker;\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar icon = this._marker._icon;\n\n  \t\tif (!this._draggable) {\n  \t\t\tthis._draggable = new Draggable(icon, icon, true);\n  \t\t}\n\n  \t\tthis._draggable.on({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).enable();\n\n  \t\taddClass(icon, 'leaflet-marker-draggable');\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._draggable.off({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).disable();\n\n  \t\tif (this._marker._icon) {\n  \t\t\tremoveClass(this._marker._icon, 'leaflet-marker-draggable');\n  \t\t}\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \t_adjustPan: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    map = marker._map,\n  \t\t    speed = this._marker.options.autoPanSpeed,\n  \t\t    padding = this._marker.options.autoPanPadding,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    bounds = map.getPixelBounds(),\n  \t\t    origin = map.getPixelOrigin();\n\n  \t\tvar panBounds = toBounds(\n  \t\t\tbounds.min._subtract(origin).add(padding),\n  \t\t\tbounds.max._subtract(origin).subtract(padding)\n  \t\t);\n\n  \t\tif (!panBounds.contains(iconPos)) {\n  \t\t\t// Compute incremental movement\n  \t\t\tvar movement = toPoint(\n  \t\t\t\t(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -\n  \t\t\t\t(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),\n\n  \t\t\t\t(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -\n  \t\t\t\t(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)\n  \t\t\t).multiplyBy(speed);\n\n  \t\t\tmap.panBy(movement, {animate: false});\n\n  \t\t\tthis._draggable._newPos._add(movement);\n  \t\t\tthis._draggable._startPos._add(movement);\n\n  \t\t\tsetPosition(marker._icon, this._draggable._newPos);\n  \t\t\tthis._onDrag(e);\n\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDragStart: function () {\n  \t\t// @section Dragging events\n  \t\t// @event dragstart: Event\n  \t\t// Fired when the user starts dragging the marker.\n\n  \t\t// @event movestart: Event\n  \t\t// Fired when the marker starts moving (because of dragging).\n\n  \t\tthis._oldLatLng = this._marker.getLatLng();\n\n  \t\t// When using ES6 imports it could not be set when `Popup` was not imported as well\n  \t\tthis._marker.closePopup && this._marker.closePopup();\n\n  \t\tthis._marker\n  \t\t\t.fire('movestart')\n  \t\t\t.fire('dragstart');\n  \t},\n\n  \t_onPreDrag: function (e) {\n  \t\tif (this._marker.options.autoPan) {\n  \t\t\tcancelAnimFrame(this._panRequest);\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    shadow = marker._shadow,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n  \t\t// update shadow position\n  \t\tif (shadow) {\n  \t\t\tsetPosition(shadow, iconPos);\n  \t\t}\n\n  \t\tmarker._latlng = latlng;\n  \t\te.latlng = latlng;\n  \t\te.oldLatLng = this._oldLatLng;\n\n  \t\t// @event drag: Event\n  \t\t// Fired repeatedly while the user drags the marker.\n  \t\tmarker\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\t// @event dragend: DragEndEvent\n  \t\t// Fired when the user stops dragging the marker.\n\n  \t\t cancelAnimFrame(this._panRequest);\n\n  \t\t// @event moveend: Event\n  \t\t// Fired when the marker stops moving (because of dragging).\n  \t\tdelete this._oldLatLng;\n  \t\tthis._marker\n  \t\t    .fire('moveend')\n  \t\t    .fire('dragend', e);\n  \t}\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var Marker = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Marker options\r\n  \toptions: {\r\n  \t\t// @option icon: Icon = *\r\n  \t\t// Icon instance to use for rendering the marker.\r\n  \t\t// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\r\n  \t\t// If not specified, a common instance of `L.Icon.Default` is used.\r\n  \t\ticon: new IconDefault(),\r\n\r\n  \t\t// Option inherited from \"Interactive layer\" abstract class\r\n  \t\tinteractive: true,\r\n\r\n  \t\t// @option keyboard: Boolean = true\r\n  \t\t// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\r\n  \t\tkeyboard: true,\r\n\r\n  \t\t// @option title: String = ''\r\n  \t\t// Text for the browser tooltip that appear on marker hover (no tooltip by default).\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\ttitle: '',\r\n\r\n  \t\t// @option alt: String = 'Marker'\r\n  \t\t// Text for the `alt` attribute of the icon image.\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\talt: 'Marker',\r\n\r\n  \t\t// @option zIndexOffset: Number = 0\r\n  \t\t// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\r\n  \t\tzIndexOffset: 0,\r\n\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the marker.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option riseOnHover: Boolean = false\r\n  \t\t// If `true`, the marker will get on top of others when you hover the mouse over it.\r\n  \t\triseOnHover: false,\r\n\r\n  \t\t// @option riseOffset: Number = 250\r\n  \t\t// The z-index offset used for the `riseOnHover` feature.\r\n  \t\triseOffset: 250,\r\n\r\n  \t\t// @option pane: String = 'markerPane'\r\n  \t\t// `Map pane` where the markers icon will be added.\r\n  \t\tpane: 'markerPane',\r\n\r\n  \t\t// @option shadowPane: String = 'shadowPane'\r\n  \t\t// `Map pane` where the markers shadow will be added.\r\n  \t\tshadowPane: 'shadowPane',\r\n\r\n  \t\t// @option bubblingMouseEvents: Boolean = false\r\n  \t\t// When `true`, a mouse event on this marker will trigger the same event on the map\r\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\r\n  \t\tbubblingMouseEvents: false,\r\n\r\n  \t\t// @option autoPanOnFocus: Boolean = true\r\n  \t\t// When `true`, the map will pan whenever the marker is focused (via\r\n  \t\t// e.g. pressing `tab` on the keyboard) to ensure the marker is\r\n  \t\t// visible within the map's bounds\r\n  \t\tautoPanOnFocus: true,\r\n\r\n  \t\t// @section Draggable marker options\r\n  \t\t// @option draggable: Boolean = false\r\n  \t\t// Whether the marker is draggable with mouse/touch or not.\r\n  \t\tdraggable: false,\r\n\r\n  \t\t// @option autoPan: Boolean = false\r\n  \t\t// Whether to pan the map when dragging this marker near its edge or not.\r\n  \t\tautoPan: false,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(50, 50)\r\n  \t\t// Distance (in pixels to the left/right and to the top/bottom) of the\r\n  \t\t// map edge to start panning the map.\r\n  \t\tautoPanPadding: [50, 50],\r\n\r\n  \t\t// @option autoPanSpeed: Number = 10\r\n  \t\t// Number of pixels the map should pan by.\r\n  \t\tautoPanSpeed: 10\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t *\r\n  \t * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n  \t */\r\n\r\n  \tinitialize: function (latlng, options) {\r\n  \t\tsetOptions(this, options);\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._initIcon();\r\n  \t\tthis.update();\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (this.dragging && this.dragging.enabled()) {\r\n  \t\t\tthis.options.draggable = true;\r\n  \t\t\tthis.dragging.removeHooks();\r\n  \t\t}\r\n  \t\tdelete this.dragging;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._removeIcon();\r\n  \t\tthis._removeShadow();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\treturn {\r\n  \t\t\tzoom: this.update,\r\n  \t\t\tviewreset: this.update\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the current geographical position of the marker.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Changes the marker position to the given point.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tvar oldLatLng = this._latlng;\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tthis.update();\r\n\r\n  \t\t// @event move: Event\r\n  \t\t// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\r\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\r\n  \t},\r\n\r\n  \t// @method setZIndexOffset(offset: Number): this\r\n  \t// Changes the [zIndex offset](#marker-zindexoffset) of the marker.\r\n  \tsetZIndexOffset: function (offset) {\r\n  \t\tthis.options.zIndexOffset = offset;\r\n  \t\treturn this.update();\r\n  \t},\r\n\r\n  \t// @method getIcon: Icon\r\n  \t// Returns the current icon used by the marker\r\n  \tgetIcon: function () {\r\n  \t\treturn this.options.icon;\r\n  \t},\r\n\r\n  \t// @method setIcon(icon: Icon): this\r\n  \t// Changes the marker icon.\r\n  \tsetIcon: function (icon) {\r\n\r\n  \t\tthis.options.icon = icon;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._initIcon();\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.bindPopup(this._popup, this._popup.options);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetElement: function () {\r\n  \t\treturn this._icon;\r\n  \t},\r\n\r\n  \tupdate: function () {\r\n\r\n  \t\tif (this._icon && this._map) {\r\n  \t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n  \t\t\tthis._setPos(pos);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initIcon: function () {\r\n  \t\tvar options = this.options,\r\n  \t\t    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\r\n\r\n  \t\tvar icon = options.icon.createIcon(this._icon),\r\n  \t\t    addIcon = false;\r\n\r\n  \t\t// if we're not reusing the icon, remove the old one and init new one\r\n  \t\tif (icon !== this._icon) {\r\n  \t\t\tif (this._icon) {\r\n  \t\t\t\tthis._removeIcon();\r\n  \t\t\t}\r\n  \t\t\taddIcon = true;\r\n\r\n  \t\t\tif (options.title) {\r\n  \t\t\t\ticon.title = options.title;\r\n  \t\t\t}\r\n\r\n  \t\t\tif (icon.tagName === 'IMG') {\r\n  \t\t\t\ticon.alt = options.alt || '';\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\taddClass(icon, classToAdd);\r\n\r\n  \t\tif (options.keyboard) {\r\n  \t\t\ticon.tabIndex = '0';\r\n  \t\t\ticon.setAttribute('role', 'button');\r\n  \t\t}\r\n\r\n  \t\tthis._icon = icon;\r\n\r\n  \t\tif (options.riseOnHover) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\ton(icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n  \t\t    addShadow = false;\r\n\r\n  \t\tif (newShadow !== this._shadow) {\r\n  \t\t\tthis._removeShadow();\r\n  \t\t\taddShadow = true;\r\n  \t\t}\r\n\r\n  \t\tif (newShadow) {\r\n  \t\t\taddClass(newShadow, classToAdd);\r\n  \t\t\tnewShadow.alt = '';\r\n  \t\t}\r\n  \t\tthis._shadow = newShadow;\r\n\r\n\r\n  \t\tif (options.opacity < 1) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n\r\n  \t\tif (addIcon) {\r\n  \t\t\tthis.getPane().appendChild(this._icon);\r\n  \t\t}\r\n  \t\tthis._initInteraction();\r\n  \t\tif (newShadow && addShadow) {\r\n  \t\t\tthis.getPane(options.shadowPane).appendChild(this._shadow);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeIcon: function () {\r\n  \t\tif (this.options.riseOnHover) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\toff(this._icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tremove(this._icon);\r\n  \t\tthis.removeInteractiveTarget(this._icon);\r\n\r\n  \t\tthis._icon = null;\r\n  \t},\r\n\r\n  \t_removeShadow: function () {\r\n  \t\tif (this._shadow) {\r\n  \t\t\tremove(this._shadow);\r\n  \t\t}\r\n  \t\tthis._shadow = null;\r\n  \t},\r\n\r\n  \t_setPos: function (pos) {\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetPosition(this._icon, pos);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetPosition(this._shadow, pos);\r\n  \t\t}\r\n\r\n  \t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n  \t\tthis._resetZIndex();\r\n  \t},\r\n\r\n  \t_updateZIndex: function (offset) {\r\n  \t\tif (this._icon) {\r\n  \t\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_animateZoom: function (opt) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n  \t\tthis._setPos(pos);\r\n  \t},\r\n\r\n  \t_initInteraction: function () {\r\n\r\n  \t\tif (!this.options.interactive) { return; }\r\n\r\n  \t\taddClass(this._icon, 'leaflet-interactive');\r\n\r\n  \t\tthis.addInteractiveTarget(this._icon);\r\n\r\n  \t\tif (MarkerDrag) {\r\n  \t\t\tvar draggable = this.options.draggable;\r\n  \t\t\tif (this.dragging) {\r\n  \t\t\t\tdraggable = this.dragging.enabled();\r\n  \t\t\t\tthis.dragging.disable();\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.dragging = new MarkerDrag(this);\r\n\r\n  \t\t\tif (draggable) {\r\n  \t\t\t\tthis.dragging.enable();\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Changes the opacity of the marker.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tvar opacity = this.options.opacity;\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetOpacity(this._icon, opacity);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetOpacity(this._shadow, opacity);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_bringToFront: function () {\r\n  \t\tthis._updateZIndex(this.options.riseOffset);\r\n  \t},\r\n\r\n  \t_resetZIndex: function () {\r\n  \t\tthis._updateZIndex(0);\r\n  \t},\r\n\r\n  \t_panOnFocus: function () {\r\n  \t\tvar map = this._map;\r\n  \t\tif (!map) { return; }\r\n\r\n  \t\tvar iconOpts = this.options.icon.options;\r\n  \t\tvar size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\r\n  \t\tvar anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\r\n\r\n  \t\tmap.panInside(this._latlng, {\r\n  \t\t\tpaddingTopLeft: anchor,\r\n  \t\t\tpaddingBottomRight: size.subtract(anchor)\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_getPopupAnchor: function () {\r\n  \t\treturn this.options.icon.options.popupAnchor;\r\n  \t},\r\n\r\n  \t_getTooltipAnchor: function () {\r\n  \t\treturn this.options.icon.options.tooltipAnchor;\r\n  \t}\r\n  });\r\n\r\n\r\n  // factory L.marker(latlng: LatLng, options? : Marker options)\r\n\r\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\r\n  // Instantiates a Marker object given a geographical point and optionally an options object.\r\n  function marker(latlng, options) {\r\n  \treturn new Marker(latlng, options);\r\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n\n  \t// @section\n  \t// @aka Path options\n  \toptions: {\n  \t\t// @option stroke: Boolean = true\n  \t\t// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n  \t\tstroke: true,\n\n  \t\t// @option color: String = '#3388ff'\n  \t\t// Stroke color\n  \t\tcolor: '#3388ff',\n\n  \t\t// @option weight: Number = 3\n  \t\t// Stroke width in pixels\n  \t\tweight: 3,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Stroke opacity\n  \t\topacity: 1,\n\n  \t\t// @option lineCap: String= 'round'\n  \t\t// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n  \t\tlineCap: 'round',\n\n  \t\t// @option lineJoin: String = 'round'\n  \t\t// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n  \t\tlineJoin: 'round',\n\n  \t\t// @option dashArray: String = null\n  \t\t// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashArray: null,\n\n  \t\t// @option dashOffset: String = null\n  \t\t// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashOffset: null,\n\n  \t\t// @option fill: Boolean = depends\n  \t\t// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n  \t\tfill: false,\n\n  \t\t// @option fillColor: String = *\n  \t\t// Fill color. Defaults to the value of the [`color`](#path-color) option\n  \t\tfillColor: null,\n\n  \t\t// @option fillOpacity: Number = 0.2\n  \t\t// Fill opacity.\n  \t\tfillOpacity: 0.2,\n\n  \t\t// @option fillRule: String = 'evenodd'\n  \t\t// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n  \t\tfillRule: 'evenodd',\n\n  \t\t// className: '',\n\n  \t\t// Option inherited from \"Interactive layer\" abstract class\n  \t\tinteractive: true,\n\n  \t\t// @option bubblingMouseEvents: Boolean = true\n  \t\t// When `true`, a mouse event on this path will trigger the same event on the map\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\t// Renderer is set here because we need to call renderer.getEvents\n  \t\t// before this.getEvents.\n  \t\tthis._renderer = map.getRenderer(this);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._renderer._initPath(this);\n  \t\tthis._reset();\n  \t\tthis._renderer._addPath(this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis._renderer._removePath(this);\n  \t},\n\n  \t// @method redraw(): this\n  \t// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._renderer._updatePath(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method setStyle(style: Path options): this\n  \t// Changes the appearance of a Path based on the options in the `Path options` object.\n  \tsetStyle: function (style) {\n  \t\tsetOptions(this, style);\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._updateStyle(this);\n  \t\t\tif (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n  \t\t\t\tthis._updateBounds();\n  \t\t\t}\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToFront(): this\n  \t// Brings the layer to the top of all path layers.\n  \tbringToFront: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToFront(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack(): this\n  \t// Brings the layer to the bottom of all path layers.\n  \tbringToBack: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToBack(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetElement: function () {\n  \t\treturn this._path;\n  \t},\n\n  \t_reset: function () {\n  \t\t// defined in child classes\n  \t\tthis._project();\n  \t\tthis._update();\n  \t},\n\n  \t_clickTolerance: function () {\n  \t\t// used when doing hit detection for Canvas layers\n  \t\treturn (this.options.stroke ? this.options.weight / 2 : 0) +\n  \t\t  (this._renderer.options.tolerance || 0);\n  \t}\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n\n  \t// @section\n  \t// @aka CircleMarker options\n  \toptions: {\n  \t\tfill: true,\n\n  \t\t// @option radius: Number = 10\n  \t\t// Radius of the circle marker, in pixels\n  \t\tradius: 10\n  \t},\n\n  \tinitialize: function (latlng, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis._radius = this.options.radius;\n  \t},\n\n  \t// @method setLatLng(latLng: LatLng): this\n  \t// Sets the position of a circle marker to a new location.\n  \tsetLatLng: function (latlng) {\n  \t\tvar oldLatLng = this._latlng;\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis.redraw();\n\n  \t\t// @event move: Event\n  \t\t// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\n  \t},\n\n  \t// @method getLatLng(): LatLng\n  \t// Returns the current geographical position of the circle marker\n  \tgetLatLng: function () {\n  \t\treturn this._latlng;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle marker. Units are in pixels.\n  \tsetRadius: function (radius) {\n  \t\tthis.options.radius = this._radius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of the circle\n  \tgetRadius: function () {\n  \t\treturn this._radius;\n  \t},\n\n  \tsetStyle : function (options) {\n  \t\tvar radius = options && options.radius || this._radius;\n  \t\tPath.prototype.setStyle.call(this, options);\n  \t\tthis.setRadius(radius);\n  \t\treturn this;\n  \t},\n\n  \t_project: function () {\n  \t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._updateBounds();\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar r = this._radius,\n  \t\t    r2 = this._radiusY || r,\n  \t\t    w = this._clickTolerance(),\n  \t\t    p = [r + w, r2 + w];\n  \t\tthis._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._updatePath();\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updateCircle(this);\n  \t},\n\n  \t_empty: function () {\n  \t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n  \t}\n  });\n\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n  \treturn new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n\n  \tinitialize: function (latlng, options, legacyOptions) {\n  \t\tif (typeof options === 'number') {\n  \t\t\t// Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n  \t\t\toptions = extend({}, legacyOptions, {radius: options});\n  \t\t}\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n\n  \t\tif (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }\n\n  \t\t// @section\n  \t\t// @aka Circle options\n  \t\t// @option radius: Number; Radius of the circle, in meters.\n  \t\tthis._mRadius = this.options.radius;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle. Units are in meters.\n  \tsetRadius: function (radius) {\n  \t\tthis._mRadius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of a circle. Units are in meters.\n  \tgetRadius: function () {\n  \t\treturn this._mRadius;\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\tvar half = [this._radius, this._radiusY || this._radius];\n\n  \t\treturn new LatLngBounds(\n  \t\t\tthis._map.layerPointToLatLng(this._point.subtract(half)),\n  \t\t\tthis._map.layerPointToLatLng(this._point.add(half)));\n  \t},\n\n  \tsetStyle: Path.prototype.setStyle,\n\n  \t_project: function () {\n\n  \t\tvar lng = this._latlng.lng,\n  \t\t    lat = this._latlng.lat,\n  \t\t    map = this._map,\n  \t\t    crs = map.options.crs;\n\n  \t\tif (crs.distance === Earth.distance) {\n  \t\t\tvar d = Math.PI / 180,\n  \t\t\t    latR = (this._mRadius / Earth.R) / d,\n  \t\t\t    top = map.project([lat + latR, lng]),\n  \t\t\t    bottom = map.project([lat - latR, lng]),\n  \t\t\t    p = top.add(bottom).divideBy(2),\n  \t\t\t    lat2 = map.unproject(p).lat,\n  \t\t\t    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\n  \t\t\t            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n  \t\t\tif (isNaN(lngR) || lngR === 0) {\n  \t\t\t\tlngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n  \t\t\t}\n\n  \t\t\tthis._point = p.subtract(map.getPixelOrigin());\n  \t\t\tthis._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n  \t\t\tthis._radiusY = p.y - top.y;\n\n  \t\t} else {\n  \t\t\tvar latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n\n  \t\t\tthis._point = map.latLngToLayerPoint(this._latlng);\n  \t\t\tthis._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n  \t\t}\n\n  \t\tthis._updateBounds();\n  \t}\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n  \treturn new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n\n  \t// @section\n  \t// @aka Polyline options\n  \toptions: {\n  \t\t// @option smoothFactor: Number = 1.0\n  \t\t// How much to simplify the polyline on each zoom level. More means\n  \t\t// better performance and smoother look, and less means more accurate representation.\n  \t\tsmoothFactor: 1.0,\n\n  \t\t// @option noClip: Boolean = false\n  \t\t// Disable polyline clipping.\n  \t\tnoClip: false\n  \t},\n\n  \tinitialize: function (latlngs, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._setLatLngs(latlngs);\n  \t},\n\n  \t// @method getLatLngs(): LatLng[]\n  \t// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n  \tgetLatLngs: function () {\n  \t\treturn this._latlngs;\n  \t},\n\n  \t// @method setLatLngs(latlngs: LatLng[]): this\n  \t// Replaces all the points in the polyline with the given array of geographical points.\n  \tsetLatLngs: function (latlngs) {\n  \t\tthis._setLatLngs(latlngs);\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method isEmpty(): Boolean\n  \t// Returns `true` if the Polyline has no LatLngs.\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length;\n  \t},\n\n  \t// @method closestLayerPoint(p: Point): Point\n  \t// Returns the point closest to `p` on the Polyline.\n  \tclosestLayerPoint: function (p) {\n  \t\tvar minDistance = Infinity,\n  \t\t    minPoint = null,\n  \t\t    closest = _sqClosestPointOnSegment,\n  \t\t    p1, p2;\n\n  \t\tfor (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n  \t\t\tvar points = this._parts[j];\n\n  \t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n  \t\t\t\tp1 = points[i - 1];\n  \t\t\t\tp2 = points[i];\n\n  \t\t\t\tvar sqDist = closest(p, p1, p2, true);\n\n  \t\t\t\tif (sqDist < minDistance) {\n  \t\t\t\t\tminDistance = sqDist;\n  \t\t\t\t\tminPoint = closest(p, p1, p2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (minPoint) {\n  \t\t\tminPoint.distance = Math.sqrt(minDistance);\n  \t\t}\n  \t\treturn minPoint;\n  \t},\n\n  \t// @method getCenter(): LatLng\n  \t// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n\n  \t\tvar i, halfDist, segDist, dist, p1, p2, ratio,\n  \t\t    points = this._rings[0],\n  \t\t    len = points.length;\n\n  \t\tif (!len) { return null; }\n\n  \t\t// polyline centroid algorithm; only uses the first ring if there are multiple\n\n  \t\tfor (i = 0, halfDist = 0; i < len - 1; i++) {\n  \t\t\thalfDist += points[i].distanceTo(points[i + 1]) / 2;\n  \t\t}\n\n  \t\t// The line is so small in the current view that all points are on the same pixel.\n  \t\tif (halfDist === 0) {\n  \t\t\treturn this._map.layerPointToLatLng(points[0]);\n  \t\t}\n\n  \t\tfor (i = 0, dist = 0; i < len - 1; i++) {\n  \t\t\tp1 = points[i];\n  \t\t\tp2 = points[i + 1];\n  \t\t\tsegDist = p1.distanceTo(p2);\n  \t\t\tdist += segDist;\n\n  \t\t\tif (dist > halfDist) {\n  \t\t\t\tratio = (dist - halfDist) / segDist;\n  \t\t\t\treturn this._map.layerPointToLatLng([\n  \t\t\t\t\tp2.x - ratio * (p2.x - p1.x),\n  \t\t\t\t\tp2.y - ratio * (p2.y - p1.y)\n  \t\t\t\t]);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\treturn this._bounds;\n  \t},\n\n  \t// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n  \t// Adds a given point to the polyline. By default, adds to the first ring of\n  \t// the polyline in case of a multi-polyline, but can be overridden by passing\n  \t// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n  \taddLatLng: function (latlng, latlngs) {\n  \t\tlatlngs = latlngs || this._defaultShape();\n  \t\tlatlng = toLatLng(latlng);\n  \t\tlatlngs.push(latlng);\n  \t\tthis._bounds.extend(latlng);\n  \t\treturn this.redraw();\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tthis._bounds = new LatLngBounds();\n  \t\tthis._latlngs = this._convertLatLngs(latlngs);\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n  \t},\n\n  \t// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = [],\n  \t\t    flat = isFlat(latlngs);\n\n  \t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n  \t\t\tif (flat) {\n  \t\t\t\tresult[i] = toLatLng(latlngs[i]);\n  \t\t\t\tthis._bounds.extend(result[i]);\n  \t\t\t} else {\n  \t\t\t\tresult[i] = this._convertLatLngs(latlngs[i]);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn result;\n  \t},\n\n  \t_project: function () {\n  \t\tvar pxBounds = new Bounds();\n  \t\tthis._rings = [];\n  \t\tthis._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n  \t\tif (this._bounds.isValid() && pxBounds.isValid()) {\n  \t\t\tthis._rawPxBounds = pxBounds;\n  \t\t\tthis._updateBounds();\n  \t\t}\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar w = this._clickTolerance(),\n  \t\t    p = new Point(w, w);\n\n  \t\tif (!this._rawPxBounds) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._pxBounds = new Bounds([\n  \t\t\tthis._rawPxBounds.min.subtract(p),\n  \t\t\tthis._rawPxBounds.max.add(p)\n  \t\t]);\n  \t},\n\n  \t// recursively turns latlngs into a set of rings with projected coordinates\n  \t_projectLatlngs: function (latlngs, result, projectedBounds) {\n  \t\tvar flat = latlngs[0] instanceof LatLng,\n  \t\t    len = latlngs.length,\n  \t\t    i, ring;\n\n  \t\tif (flat) {\n  \t\t\tring = [];\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n  \t\t\t\tprojectedBounds.extend(ring[i]);\n  \t\t\t}\n  \t\t\tresult.push(ring);\n  \t\t} else {\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tthis._projectLatlngs(latlngs[i], result, projectedBounds);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// clip polyline by renderer bounds so that we have less to render for performance\n  \t_clipPoints: function () {\n  \t\tvar bounds = this._renderer._bounds;\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar parts = this._parts,\n  \t\t    i, j, k, len, len2, segment, points;\n\n  \t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n  \t\t\tpoints = this._rings[i];\n\n  \t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n  \t\t\t\tsegment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n  \t\t\t\tif (!segment) { continue; }\n\n  \t\t\t\tparts[k] = parts[k] || [];\n  \t\t\t\tparts[k].push(segment[0]);\n\n  \t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n  \t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n  \t\t\t\t\tparts[k].push(segment[1]);\n  \t\t\t\t\tk++;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// simplify each clipped part of the polyline for performance\n  \t_simplifyPoints: function () {\n  \t\tvar parts = this._parts,\n  \t\t    tolerance = this.options.smoothFactor;\n\n  \t\tfor (var i = 0, len = parts.length; i < len; i++) {\n  \t\t\tparts[i] = simplify(parts[i], tolerance);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._clipPoints();\n  \t\tthis._simplifyPoints();\n  \t\tthis._updatePath();\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p, closed) {\n  \t\tvar i, j, k, len, len2, part,\n  \t\t    w = this._clickTolerance();\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// hit detection for polylines\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tif (!closed && (j === 0)) { continue; }\n\n  \t\t\t\tif (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t}\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n  \treturn new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n\n  \toptions: {\n  \t\tfill: true\n  \t},\n\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length || !this._latlngs[0].length;\n  \t},\n\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n\n  \t\tvar i, j, p1, p2, f, area, x, y, center,\n  \t\t    points = this._rings[0],\n  \t\t    len = points.length;\n\n  \t\tif (!len) { return null; }\n\n  \t\t// polygon centroid algorithm; only uses the first ring if there are multiple\n\n  \t\tarea = x = y = 0;\n\n  \t\tfor (i = 0, j = len - 1; i < len; j = i++) {\n  \t\t\tp1 = points[i];\n  \t\t\tp2 = points[j];\n\n  \t\t\tf = p1.y * p2.x - p2.y * p1.x;\n  \t\t\tx += (p1.x + p2.x) * f;\n  \t\t\ty += (p1.y + p2.y) * f;\n  \t\t\tarea += f * 3;\n  \t\t}\n\n  \t\tif (area === 0) {\n  \t\t\t// Polygon is so small that all points are on same pixel.\n  \t\t\tcenter = points[0];\n  \t\t} else {\n  \t\t\tcenter = [x / area, y / area];\n  \t\t}\n  \t\treturn this._map.layerPointToLatLng(center);\n  \t},\n\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n  \t\t    len = result.length;\n\n  \t\t// remove last point if it equals first one\n  \t\tif (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n  \t\t\tresult.pop();\n  \t\t}\n  \t\treturn result;\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tPolyline.prototype._setLatLngs.call(this, latlngs);\n  \t\tif (isFlat(this._latlngs)) {\n  \t\t\tthis._latlngs = [this._latlngs];\n  \t\t}\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n  \t},\n\n  \t_clipPoints: function () {\n  \t\t// polygons need a different clipping algorithm so we redefine that\n\n  \t\tvar bounds = this._renderer._bounds,\n  \t\t    w = this.options.weight,\n  \t\t    p = new Point(w, w);\n\n  \t\t// increase clip padding by stroke width to avoid stroke on clip edges\n  \t\tbounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n  \t\t\tclipped = clipPolygon(this._rings[i], bounds, true);\n  \t\t\tif (clipped.length) {\n  \t\t\t\tthis._parts.push(clipped);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this, true);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\tvar inside = false,\n  \t\t    part, p1, p2, i, j, k, len, len2;\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// ray casting algorithm for detecting if point is in polygon\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tp1 = part[j];\n  \t\t\t\tp2 = part[k];\n\n  \t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n  \t\t\t\t\tinside = !inside;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// also check if it's on polygon stroke\n  \t\treturn inside || Polyline.prototype._containsPoint.call(this, p, true);\n  \t}\n\n  });\n\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n  \treturn new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var GeoJSON = FeatureGroup.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka GeoJSON options\r\n  \t *\r\n  \t * @option pointToLayer: Function = *\r\n  \t * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n  \t * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n  \t * The default is to spawn a default `Marker`:\r\n  \t * ```js\r\n  \t * function(geoJsonPoint, latlng) {\r\n  \t * \treturn L.marker(latlng);\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option style: Function = *\r\n  \t * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n  \t * called internally when data is added.\r\n  \t * The default value is to not override any defaults:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn {}\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option onEachFeature: Function = *\r\n  \t * A `Function` that will be called once for each created `Feature`, after it has\r\n  \t * been created and styled. Useful for attaching events and popups to features.\r\n  \t * The default is to do nothing with the newly created layers:\r\n  \t * ```js\r\n  \t * function (feature, layer) {}\r\n  \t * ```\r\n  \t *\r\n  \t * @option filter: Function = *\r\n  \t * A `Function` that will be used to decide whether to include a feature or not.\r\n  \t * The default is to include all features:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn true;\r\n  \t * }\r\n  \t * ```\r\n  \t * Note: dynamically changing the `filter` option will have effect only on newly\r\n  \t * added data. It will _not_ re-evaluate already included features.\r\n  \t *\r\n  \t * @option coordsToLatLng: Function = *\r\n  \t * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n  \t * The default is the `coordsToLatLng` static method.\r\n  \t *\r\n  \t * @option markersInheritOptions: Boolean = false\r\n  \t * Whether default Markers for \"Point\" type Features inherit from group options.\r\n  \t */\r\n\r\n  \tinitialize: function (geojson, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tif (geojson) {\r\n  \t\t\tthis.addData(geojson);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addData( <GeoJSON> data ): this\r\n  \t// Adds a GeoJSON object to the layer.\r\n  \taddData: function (geojson) {\r\n  \t\tvar features = isArray(geojson) ? geojson : geojson.features,\r\n  \t\t    i, len, feature;\r\n\r\n  \t\tif (features) {\r\n  \t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n  \t\t\t\t// only add this if geometry or geometries are set and not null\r\n  \t\t\t\tfeature = features[i];\r\n  \t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n  \t\t\t\t\tthis.addData(feature);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar options = this.options;\r\n\r\n  \t\tif (options.filter && !options.filter(geojson)) { return this; }\r\n\r\n  \t\tvar layer = geometryToLayer(geojson, options);\r\n  \t\tif (!layer) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tlayer.feature = asFeature(geojson);\r\n\r\n  \t\tlayer.defaultOptions = layer.options;\r\n  \t\tthis.resetStyle(layer);\r\n\r\n  \t\tif (options.onEachFeature) {\r\n  \t\t\toptions.onEachFeature(geojson, layer);\r\n  \t\t}\r\n\r\n  \t\treturn this.addLayer(layer);\r\n  \t},\r\n\r\n  \t// @method resetStyle( <Path> layer? ): this\r\n  \t// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\r\n  \t// If `layer` is omitted, the style of all features in the current layer is reset.\r\n  \tresetStyle: function (layer) {\r\n  \t\tif (layer === undefined) {\r\n  \t\t\treturn this.eachLayer(this.resetStyle, this);\r\n  \t\t}\r\n  \t\t// reset any custom styles\r\n  \t\tlayer.options = extend({}, layer.defaultOptions);\r\n  \t\tthis._setLayerStyle(layer, this.options.style);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setStyle( <Function> style ): this\r\n  \t// Changes styles of GeoJSON vector layers with the given style function.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.eachLayer(function (layer) {\r\n  \t\t\tthis._setLayerStyle(layer, style);\r\n  \t\t}, this);\r\n  \t},\r\n\r\n  \t_setLayerStyle: function (layer, style) {\r\n  \t\tif (layer.setStyle) {\r\n  \t\t\tif (typeof style === 'function') {\r\n  \t\t\t\tstyle = style(layer.feature);\r\n  \t\t\t}\r\n  \t\t\tlayer.setStyle(style);\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n  // There are several static functions which can be called without instantiating L.GeoJSON:\r\n\r\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\r\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\r\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // functions if provided as options.\r\n  function geometryToLayer(geojson, options) {\r\n\r\n  \tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n  \t    coords = geometry ? geometry.coordinates : null,\r\n  \t    layers = [],\r\n  \t    pointToLayer = options && options.pointToLayer,\r\n  \t    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\r\n  \t    latlng, latlngs, i, len;\r\n\r\n  \tif (!coords && !geometry) {\r\n  \t\treturn null;\r\n  \t}\r\n\r\n  \tswitch (geometry.type) {\r\n  \tcase 'Point':\r\n  \t\tlatlng = _coordsToLatLng(coords);\r\n  \t\treturn _pointToLayer(pointToLayer, geojson, latlng, options);\r\n\r\n  \tcase 'MultiPoint':\r\n  \t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n  \t\t\tlatlng = _coordsToLatLng(coords[i]);\r\n  \t\t\tlayers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tcase 'LineString':\r\n  \tcase 'MultiLineString':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\r\n  \t\treturn new Polyline(latlngs, options);\r\n\r\n  \tcase 'Polygon':\r\n  \tcase 'MultiPolygon':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\r\n  \t\treturn new Polygon(latlngs, options);\r\n\r\n  \tcase 'GeometryCollection':\r\n  \t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n  \t\t\tvar layer = geometryToLayer({\r\n  \t\t\t\tgeometry: geometry.geometries[i],\r\n  \t\t\t\ttype: 'Feature',\r\n  \t\t\t\tproperties: geojson.properties\r\n  \t\t\t}, options);\r\n\r\n  \t\t\tif (layer) {\r\n  \t\t\t\tlayers.push(layer);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tdefault:\r\n  \t\tthrow new Error('Invalid GeoJSON object.');\r\n  \t}\r\n  }\r\n\r\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\r\n  \treturn pointToLayerFn ?\r\n  \t\tpointToLayerFn(geojson, latlng) :\r\n  \t\tnew Marker(latlng, options && options.markersInheritOptions && options);\r\n  }\r\n\r\n  // @function coordsToLatLng(coords: Array): LatLng\r\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\r\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\r\n  function coordsToLatLng(coords) {\r\n  \treturn new LatLng(coords[1], coords[0], coords[2]);\r\n  }\r\n\r\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\r\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\r\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\r\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\r\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\r\n  \tvar latlngs = [];\r\n\r\n  \tfor (var i = 0, len = coords.length, latlng; i < len; i++) {\r\n  \t\tlatlng = levelsDeep ?\r\n  \t\t\tcoordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :\r\n  \t\t\t(_coordsToLatLng || coordsToLatLng)(coords[i]);\r\n\r\n  \t\tlatlngs.push(latlng);\r\n  \t}\r\n\r\n  \treturn latlngs;\r\n  }\r\n\r\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngToCoords(latlng, precision) {\r\n  \tlatlng = toLatLng(latlng);\r\n  \treturn latlng.alt !== undefined ?\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\r\n  }\r\n\r\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\r\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\r\n  \tvar coords = [];\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\tcoords.push(levelsDeep ?\r\n  \t\t\tlatLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :\r\n  \t\t\tlatLngToCoords(latlngs[i], precision));\r\n  \t}\r\n\r\n  \tif (!levelsDeep && closed) {\r\n  \t\tcoords.push(coords[0]);\r\n  \t}\r\n\r\n  \treturn coords;\r\n  }\r\n\r\n  function getFeature(layer, newGeometry) {\r\n  \treturn layer.feature ?\r\n  \t\textend({}, layer.feature, {geometry: newGeometry}) :\r\n  \t\tasFeature(newGeometry);\r\n  }\r\n\r\n  // @function asFeature(geojson: Object): Object\r\n  // Normalize GeoJSON geometries/features into GeoJSON features.\r\n  function asFeature(geojson) {\r\n  \tif (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\r\n  \t\treturn geojson;\r\n  \t}\r\n\r\n  \treturn {\r\n  \t\ttype: 'Feature',\r\n  \t\tproperties: {},\r\n  \t\tgeometry: geojson\r\n  \t};\r\n  }\r\n\r\n  var PointToGeoJSON = {\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'Point',\r\n  \t\t\tcoordinates: latLngToCoords(this.getLatLng(), precision)\r\n  \t\t});\r\n  \t}\r\n  };\r\n\r\n  // @namespace Marker\r\n  // @section Other methods\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\r\n  Marker.include(PointToGeoJSON);\r\n\r\n  // @namespace CircleMarker\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\r\n  Circle.include(PointToGeoJSON);\r\n  CircleMarker.include(PointToGeoJSON);\r\n\r\n\r\n  // @namespace Polyline\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\r\n  Polyline.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar multi = !isFlat(this._latlngs);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'LineString',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n  // @namespace Polygon\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\r\n  Polygon.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar holes = !isFlat(this._latlngs),\r\n  \t\t    multi = holes && !isFlat(this._latlngs[0]);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\r\n\r\n  \t\tif (!holes) {\r\n  \t\t\tcoords = [coords];\r\n  \t\t}\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'Polygon',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n\r\n  // @namespace LayerGroup\r\n  LayerGroup.include({\r\n  \ttoMultiPoint: function (precision) {\r\n  \t\tvar coords = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tcoords.push(layer.toGeoJSON(precision).geometry.coordinates);\r\n  \t\t});\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'MultiPoint',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @method toGeoJSON(precision?: Number|false): Object\r\n  \t// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  \t// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\r\n  \ttoGeoJSON: function (precision) {\r\n\r\n  \t\tvar type = this.feature && this.feature.geometry && this.feature.geometry.type;\r\n\r\n  \t\tif (type === 'MultiPoint') {\r\n  \t\t\treturn this.toMultiPoint(precision);\r\n  \t\t}\r\n\r\n  \t\tvar isGeometryCollection = type === 'GeometryCollection',\r\n  \t\t    jsons = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tif (layer.toGeoJSON) {\r\n  \t\t\t\tvar json = layer.toGeoJSON(precision);\r\n  \t\t\t\tif (isGeometryCollection) {\r\n  \t\t\t\t\tjsons.push(json.geometry);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tvar feature = asFeature(json);\r\n  \t\t\t\t\t// Squash nested feature collections\r\n  \t\t\t\t\tif (feature.type === 'FeatureCollection') {\r\n  \t\t\t\t\t\tjsons.push.apply(jsons, feature.features);\r\n  \t\t\t\t\t} else {\r\n  \t\t\t\t\t\tjsons.push(feature);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t});\r\n\r\n  \t\tif (isGeometryCollection) {\r\n  \t\t\treturn getFeature(this, {\r\n  \t\t\t\tgeometries: jsons,\r\n  \t\t\t\ttype: 'GeometryCollection'\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\treturn {\r\n  \t\t\ttype: 'FeatureCollection',\r\n  \t\t\tfeatures: jsons\r\n  \t\t};\r\n  \t}\r\n  });\r\n\r\n  // @namespace GeoJSON\r\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\r\n  // Creates a GeoJSON layer. Optionally accepts an object in\r\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\r\n  // (you can alternatively add it later with `addData` method) and an `options` object.\r\n  function geoJSON(geojson, options) {\r\n  \treturn new GeoJSON(geojson, options);\r\n  }\r\n\r\n  // Backward compatibility.\r\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var ImageOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka ImageOverlay options\r\n  \toptions: {\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the image overlay.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option alt: String = ''\r\n  \t\t// Text for the `alt` attribute of the image (useful for accessibility).\r\n  \t\talt: '',\r\n\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the image.\r\n  \t\t// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option errorOverlayUrl: String = ''\r\n  \t\t// URL to the overlay image to show in place of the overlay that failed to load.\r\n  \t\terrorOverlayUrl: '',\r\n\r\n  \t\t// @option zIndex: Number = 1\r\n  \t\t// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\r\n  \t\tzIndex: 1,\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom class name to assign to the image. Empty by default.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n  \t\tthis._url = url;\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \tonAdd: function () {\r\n  \t\tif (!this._image) {\r\n  \t\t\tthis._initImage();\r\n\r\n  \t\t\tif (this.options.opacity < 1) {\r\n  \t\t\t\tthis._updateOpacity();\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._image, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._image);\r\n  \t\t}\r\n\r\n  \t\tthis.getPane().appendChild(this._image);\r\n  \t\tthis._reset();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tremove(this._image);\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tthis.removeInteractiveTarget(this._image);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Sets the opacity of the overlay.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tsetStyle: function (styleOpts) {\r\n  \t\tif (styleOpts.opacity) {\r\n  \t\t\tthis.setOpacity(styleOpts.opacity);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer to the top of all overlays.\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer to the bottom of all overlays.\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String): this\r\n  \t// Changes the URL of the image.\r\n  \tsetUrl: function (url) {\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._image.src = url;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setBounds(bounds: LatLngBounds): this\r\n  \t// Update the bounds that this ImageOverlay covers\r\n  \tsetBounds: function (bounds) {\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._reset();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._reset,\r\n  \t\t\tviewreset: this._reset\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method setZIndex(value: Number): this\r\n  \t// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\r\n  \tsetZIndex: function (value) {\r\n  \t\tthis.options.zIndex = value;\r\n  \t\tthis._updateZIndex();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Get the bounds that this ImageOverlay covers\r\n  \tgetBounds: function () {\r\n  \t\treturn this._bounds;\r\n  \t},\r\n\r\n  \t// @method getElement(): HTMLElement\r\n  \t// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\r\n  \t// used by this overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._image;\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'IMG';\r\n  \t\tvar img = this._image = wasElementSupplied ? this._url : create$1('img');\r\n\r\n  \t\taddClass(img, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(img, this.options.className); }\r\n\r\n  \t\timg.onselectstart = falseFn;\r\n  \t\timg.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the ImageOverlay layer has loaded its image\r\n  \t\timg.onload = bind(this.fire, this, 'load');\r\n  \t\timg.onerror = bind(this._overlayOnError, this, 'error');\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.zIndex) {\r\n  \t\t\tthis._updateZIndex();\r\n  \t\t}\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tthis._url = img.src;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\timg.src = this._url;\r\n  \t\timg.alt = this.options.alt;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar scale = this._map.getZoomScale(e.zoom),\r\n  \t\t    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\r\n\r\n  \t\tsetTransform(this._image, offset, scale);\r\n  \t},\r\n\r\n  \t_reset: function () {\r\n  \t\tvar image = this._image,\r\n  \t\t    bounds = new Bounds(\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\r\n  \t\t    size = bounds.getSize();\r\n\r\n  \t\tsetPosition(image, bounds.min);\r\n\r\n  \t\timage.style.width  = size.x + 'px';\r\n  \t\timage.style.height = size.y + 'px';\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tsetOpacity(this._image, this.options.opacity);\r\n  \t},\r\n\r\n  \t_updateZIndex: function () {\r\n  \t\tif (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\r\n  \t\t\tthis._image.style.zIndex = this.options.zIndex;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_overlayOnError: function () {\r\n  \t\t// @event error: Event\r\n  \t\t// Fired when the ImageOverlay layer fails to load its image\r\n  \t\tthis.fire('error');\r\n\r\n  \t\tvar errorUrl = this.options.errorOverlayUrl;\r\n  \t\tif (errorUrl && this._url !== errorUrl) {\r\n  \t\t\tthis._url = errorUrl;\r\n  \t\t\tthis._image.src = errorUrl;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center of the ImageOverlay.\r\n  \tgetCenter: function () {\r\n  \t\treturn this._bounds.getCenter();\r\n  \t}\r\n  });\r\n\r\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\r\n  // Instantiates an image overlay object given the URL of the image and the\r\n  // geographical bounds it is tied to.\r\n  var imageOverlay = function (url, bounds, options) {\r\n  \treturn new ImageOverlay(url, bounds, options);\r\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var VideoOverlay = ImageOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka VideoOverlay options\r\n  \toptions: {\r\n  \t\t// @option autoplay: Boolean = true\r\n  \t\t// Whether the video starts playing automatically when loaded.\r\n  \t\t// On some browsers autoplay will only work with `muted: true`\r\n  \t\tautoplay: true,\r\n\r\n  \t\t// @option loop: Boolean = true\r\n  \t\t// Whether the video will loop back to the beginning when played.\r\n  \t\tloop: true,\r\n\r\n  \t\t// @option keepAspectRatio: Boolean = true\r\n  \t\t// Whether the video will save aspect ratio after the projection.\r\n  \t\t// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\r\n  \t\tkeepAspectRatio: true,\r\n\r\n  \t\t// @option muted: Boolean = false\r\n  \t\t// Whether the video starts on mute when loaded.\r\n  \t\tmuted: false,\r\n\r\n  \t\t// @option playsInline: Boolean = true\r\n  \t\t// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\r\n  \t\tplaysInline: true\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'VIDEO';\r\n  \t\tvar vid = this._image = wasElementSupplied ? this._url : create$1('video');\r\n\r\n  \t\taddClass(vid, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(vid, this.options.className); }\r\n\r\n  \t\tvid.onselectstart = falseFn;\r\n  \t\tvid.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the video has finished loading the first frame\r\n  \t\tvid.onloadeddata = bind(this.fire, this, 'load');\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tvar sourceElements = vid.getElementsByTagName('source');\r\n  \t\t\tvar sources = [];\r\n  \t\t\tfor (var j = 0; j < sourceElements.length; j++) {\r\n  \t\t\t\tsources.push(sourceElements[j].src);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis._url = (sourceElements.length > 0) ? sources : [vid.src];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (!isArray(this._url)) { this._url = [this._url]; }\r\n\r\n  \t\tif (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\r\n  \t\t\tvid.style['objectFit'] = 'fill';\r\n  \t\t}\r\n  \t\tvid.autoplay = !!this.options.autoplay;\r\n  \t\tvid.loop = !!this.options.loop;\r\n  \t\tvid.muted = !!this.options.muted;\r\n  \t\tvid.playsInline = !!this.options.playsInline;\r\n  \t\tfor (var i = 0; i < this._url.length; i++) {\r\n  \t\t\tvar source = create$1('source');\r\n  \t\t\tsource.src = this._url[i];\r\n  \t\t\tvid.appendChild(source);\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// @method getElement(): HTMLVideoElement\r\n  \t// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\r\n  \t// used by this overlay.\r\n  });\r\n\r\n\r\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\r\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\r\n  // geographical bounds it is tied to.\r\n\r\n  function videoOverlay(video, bounds, options) {\r\n  \treturn new VideoOverlay(video, bounds, options);\r\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n  \t_initImage: function () {\n  \t\tvar el = this._image = this._url;\n\n  \t\taddClass(el, 'leaflet-image-layer');\n  \t\tif (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }\n  \t\tif (this.options.className) { addClass(el, this.options.className); }\n\n  \t\tel.onselectstart = falseFn;\n  \t\tel.onmousemove = falseFn;\n  \t}\n\n  \t// @method getElement(): SVGElement\n  \t// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n  \t// used by this overlay.\n  });\n\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n  \treturn new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\r\n\r\n  // @namespace DivOverlay\r\n  var DivOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka DivOverlay options\r\n  \toptions: {\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If true, the popup/tooltip will listen to the mouse events.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option offset: Point = Point(0, 0)\r\n  \t\t// The offset of the overlay position.\r\n  \t\toffset: [0, 0],\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the overlay.\r\n  \t\tclassName: '',\r\n\r\n  \t\t// @option pane: String = undefined\r\n  \t\t// `Map pane` where the overlay will be added.\r\n  \t\tpane: undefined\r\n  \t},\r\n\r\n  \tinitialize: function (options, source) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._source = source;\r\n  \t},\r\n\r\n  \t// @method openOn(map: Map): this\r\n  \t// Adds the overlay to the map.\r\n  \t// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n  \t\tif (!map.hasLayer(this)) {\r\n  \t\t\tmap.addLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method close(): this\r\n  \t// Closes the overlay.\r\n  \t// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\r\n  \t// and `layer.closePopup()`/`.closeTooltip()`.\r\n  \tclose: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.removeLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method toggle(layer?: Layer): this\r\n  \t// Opens or closes the overlay bound to layer depending on its current state.\r\n  \t// Argument may be omitted only for overlay bound to layer.\r\n  \t// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\r\n  \ttoggle: function (layer) {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis.close();\r\n  \t\t} else {\r\n  \t\t\tif (arguments.length) {\r\n  \t\t\t\tthis._source = layer;\r\n  \t\t\t} else {\r\n  \t\t\t\tlayer = this._source;\r\n  \t\t\t}\r\n  \t\t\tthis._prepareOpen();\r\n\r\n  \t\t\t// open the overlay on the map\r\n  \t\t\tthis.openOn(layer._map);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = map._zoomAnimated;\r\n\r\n  \t\tif (!this._container) {\r\n  \t\t\tthis._initLayout();\r\n  \t\t}\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t}\r\n\r\n  \t\tclearTimeout(this._removeTimeout);\r\n  \t\tthis.getPane().appendChild(this._container);\r\n  \t\tthis.update();\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 1);\r\n  \t\t}\r\n\r\n  \t\tthis.bringToFront();\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t\tthis._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\r\n  \t\t} else {\r\n  \t\t\tremove(this._container);\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.removeInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @namespace DivOverlay\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the geographical point of the overlay.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Sets the geographical point where the overlay will open.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updatePosition();\r\n  \t\t\tthis._adjustPan();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContent: String|HTMLElement\r\n  \t// Returns the content of the overlay.\r\n  \tgetContent: function () {\r\n  \t\treturn this._content;\r\n  \t},\r\n\r\n  \t// @method setContent(htmlContent: String|HTMLElement|Function): this\r\n  \t// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\r\n  \t// The function should return a `String` or `HTMLElement` to be used in the overlay.\r\n  \tsetContent: function (content) {\r\n  \t\tthis._content = content;\r\n  \t\tthis.update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getElement: String|HTMLElement\r\n  \t// Returns the HTML container of the overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method update: null\r\n  \t// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\r\n  \tupdate: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tthis._container.style.visibility = 'hidden';\r\n\r\n  \t\tthis._updateContent();\r\n  \t\tthis._updateLayout();\r\n  \t\tthis._updatePosition();\r\n\r\n  \t\tthis._container.style.visibility = '';\r\n\r\n  \t\tthis._adjustPan();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._updatePosition,\r\n  \t\t\tviewreset: this._updatePosition\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method isOpen: Boolean\r\n  \t// Returns `true` when the overlay is visible on the map.\r\n  \tisOpen: function () {\r\n  \t\treturn !!this._map && this._map.hasLayer(this);\r\n  \t},\r\n\r\n  \t// @method bringToFront: this\r\n  \t// Brings this overlay in front of other overlays (in the same map pane).\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack: this\r\n  \t// Brings this overlay to the back of other overlays (in the same map pane).\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\r\n  \t_prepareOpen: function (latlng) {\r\n  \t\tvar source = this._source;\r\n  \t\tif (!source._map) { return false; }\r\n\r\n  \t\tif (source instanceof FeatureGroup) {\r\n  \t\t\tsource = null;\r\n  \t\t\tvar layers = this._source._layers;\r\n  \t\t\tfor (var id in layers) {\r\n  \t\t\t\tif (layers[id]._map) {\r\n  \t\t\t\t\tsource = layers[id];\r\n  \t\t\t\t\tbreak;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\tif (!source) { return false; } // Unable to get source layer.\r\n\r\n  \t\t\t// set overlay source to this layer\r\n  \t\t\tthis._source = source;\r\n  \t\t}\r\n\r\n  \t\tif (!latlng) {\r\n  \t\t\tif (source.getCenter) {\r\n  \t\t\t\tlatlng = source.getCenter();\r\n  \t\t\t} else if (source.getLatLng) {\r\n  \t\t\t\tlatlng = source.getLatLng();\r\n  \t\t\t} else if (source.getBounds) {\r\n  \t\t\t\tlatlng = source.getBounds().getCenter();\r\n  \t\t\t} else {\r\n  \t\t\t\tthrow new Error('Unable to get source layer LatLng.');\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthis.setLatLng(latlng);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\t// update the overlay (content, layout, etc...)\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_updateContent: function () {\r\n  \t\tif (!this._content) { return; }\r\n\r\n  \t\tvar node = this._contentNode;\r\n  \t\tvar content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;\r\n\r\n  \t\tif (typeof content === 'string') {\r\n  \t\t\tnode.innerHTML = content;\r\n  \t\t} else {\r\n  \t\t\twhile (node.hasChildNodes()) {\r\n  \t\t\t\tnode.removeChild(node.firstChild);\r\n  \t\t\t}\r\n  \t\t\tnode.appendChild(content);\r\n  \t\t}\r\n\r\n  \t\t// @namespace DivOverlay\r\n  \t\t// @section DivOverlay events\r\n  \t\t// @event contentupdate: Event\r\n  \t\t// Fired when the content of the overlay is updated\r\n  \t\tthis.fire('contentupdate');\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n  \t\t    offset = toPoint(this.options.offset),\r\n  \t\t    anchor = this._getAnchor();\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tsetPosition(this._container, pos.add(anchor));\r\n  \t\t} else {\r\n  \t\t\toffset = offset.add(pos).add(anchor);\r\n  \t\t}\r\n\r\n  \t\tvar bottom = this._containerBottom = -offset.y,\r\n  \t\t    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\r\n\r\n  \t\t// bottom position the overlay in case the height of the overlay changes (images loading etc)\r\n  \t\tthis._container.style.bottom = bottom + 'px';\r\n  \t\tthis._container.style.left = left + 'px';\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\treturn [0, 0];\r\n  \t}\r\n\r\n  });\r\n\r\n  Map.include({\r\n  \t_initOverlay: function (OverlayClass, content, latlng, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (!(overlay instanceof OverlayClass)) {\r\n  \t\t\toverlay = new OverlayClass(options).setContent(content);\r\n  \t\t}\r\n  \t\tif (latlng) {\r\n  \t\t\toverlay.setLatLng(latlng);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\r\n\r\n\r\n  Layer.include({\r\n  \t_initOverlay: function (OverlayClass, old, content, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (overlay instanceof OverlayClass) {\r\n  \t\t\tsetOptions(overlay, options);\r\n  \t\t\toverlay._source = this;\r\n  \t\t} else {\r\n  \t\t\toverlay = (old && !options) ? old : new OverlayClass(options, this);\r\n  \t\t\toverlay.setContent(content);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\r\n\r\n\r\n  // @namespace Popup\r\n  var Popup = DivOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Popup options\r\n  \toptions: {\r\n  \t\t// @option pane: String = 'popupPane'\r\n  \t\t// `Map pane` where the popup will be added.\r\n  \t\tpane: 'popupPane',\r\n\r\n  \t\t// @option offset: Point = Point(0, 7)\r\n  \t\t// The offset of the popup position.\r\n  \t\toffset: [0, 7],\r\n\r\n  \t\t// @option maxWidth: Number = 300\r\n  \t\t// Max width of the popup, in pixels.\r\n  \t\tmaxWidth: 300,\r\n\r\n  \t\t// @option minWidth: Number = 50\r\n  \t\t// Min width of the popup, in pixels.\r\n  \t\tminWidth: 50,\r\n\r\n  \t\t// @option maxHeight: Number = null\r\n  \t\t// If set, creates a scrollable container of the given height\r\n  \t\t// inside a popup if its content exceeds it.\r\n  \t\tmaxHeight: null,\r\n\r\n  \t\t// @option autoPan: Boolean = true\r\n  \t\t// Set it to `false` if you don't want the map to do panning animation\r\n  \t\t// to fit the opened popup.\r\n  \t\tautoPan: true,\r\n\r\n  \t\t// @option autoPanPaddingTopLeft: Point = null\r\n  \t\t// The margin between the popup and the top left corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingTopLeft: null,\r\n\r\n  \t\t// @option autoPanPaddingBottomRight: Point = null\r\n  \t\t// The margin between the popup and the bottom right corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingBottomRight: null,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(5, 5)\r\n  \t\t// Equivalent of setting both top left and bottom right autopan padding to the same value.\r\n  \t\tautoPanPadding: [5, 5],\r\n\r\n  \t\t// @option keepInView: Boolean = false\r\n  \t\t// Set it to `true` if you want to prevent users from panning the popup\r\n  \t\t// off of the screen while it is open.\r\n  \t\tkeepInView: false,\r\n\r\n  \t\t// @option closeButton: Boolean = true\r\n  \t\t// Controls the presence of a close button in the popup.\r\n  \t\tcloseButton: true,\r\n\r\n  \t\t// @option autoClose: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the popup closing when another popup is opened.\r\n  \t\tautoClose: true,\r\n\r\n  \t\t// @option closeOnEscapeKey: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the ESC key for closing of the popup.\r\n  \t\tcloseOnEscapeKey: true,\r\n\r\n  \t\t// @option closeOnClick: Boolean = *\r\n  \t\t// Set it if you want to override the default behavior of the popup closing when user clicks\r\n  \t\t// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the popup.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \t// @namespace Popup\r\n  \t// @method openOn(map: Map): this\r\n  \t// Alternative to `map.openPopup(popup)`.\r\n  \t// Adds the popup to the map and closes the previous one.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n\r\n  \t\tif (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\r\n  \t\t\tmap.removeLayer(map._popup);\r\n  \t\t}\r\n  \t\tmap._popup = this;\r\n\r\n  \t\treturn DivOverlay.prototype.openOn.call(this, map);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupopen: PopupEvent\r\n  \t\t// Fired when a popup is opened in the map\r\n  \t\tmap.fire('popupopen', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupopen: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is opened\r\n  \t\t\tthis._source.fire('popupopen', {popup: this}, true);\r\n  \t\t\t// For non-path layers, we toggle the popup when clicking\r\n  \t\t\t// again the layer, so prevent the map to reopen it.\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.on('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupclose: PopupEvent\r\n  \t\t// Fired when a popup in the map is closed\r\n  \t\tmap.fire('popupclose', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupclose: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is closed\r\n  \t\t\tthis._source.fire('popupclose', {popup: this}, true);\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.off('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\r\n\r\n  \t\tif (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n  \t\t\tevents.preclick = this.close;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.keepInView) {\r\n  \t\t\tevents.moveend = this._adjustPan;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar prefix = 'leaflet-popup',\r\n  \t\t    container = this._container = create$1('div',\r\n  \t\t\tprefix + ' ' + (this.options.className || '') +\r\n  \t\t\t' leaflet-zoom-animated');\r\n\r\n  \t\tvar wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\r\n  \t\tthis._contentNode = create$1('div', prefix + '-content', wrapper);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(this._contentNode);\r\n  \t\ton(container, 'contextmenu', stopPropagation);\r\n\r\n  \t\tthis._tipContainer = create$1('div', prefix + '-tip-container', container);\r\n  \t\tthis._tip = create$1('div', prefix + '-tip', this._tipContainer);\r\n\r\n  \t\tif (this.options.closeButton) {\r\n  \t\t\tvar closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\r\n  \t\t\tcloseButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\r\n  \t\t\tcloseButton.setAttribute('aria-label', 'Close popup');\r\n  \t\t\tcloseButton.href = '#close';\r\n  \t\t\tcloseButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\r\n\r\n  \t\t\ton(closeButton, 'click', this.close, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_updateLayout: function () {\r\n  \t\tvar container = this._contentNode,\r\n  \t\t    style = container.style;\r\n\r\n  \t\tstyle.width = '';\r\n  \t\tstyle.whiteSpace = 'nowrap';\r\n\r\n  \t\tvar width = container.offsetWidth;\r\n  \t\twidth = Math.min(width, this.options.maxWidth);\r\n  \t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n  \t\tstyle.width = (width + 1) + 'px';\r\n  \t\tstyle.whiteSpace = '';\r\n\r\n  \t\tstyle.height = '';\r\n\r\n  \t\tvar height = container.offsetHeight,\r\n  \t\t    maxHeight = this.options.maxHeight,\r\n  \t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n  \t\tif (maxHeight && height > maxHeight) {\r\n  \t\t\tstyle.height = maxHeight + 'px';\r\n  \t\t\taddClass(container, scrolledClass);\r\n  \t\t} else {\r\n  \t\t\tremoveClass(container, scrolledClass);\r\n  \t\t}\r\n\r\n  \t\tthis._containerWidth = this._container.offsetWidth;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\r\n  \t\t    anchor = this._getAnchor();\r\n  \t\tsetPosition(this._container, pos.add(anchor));\r\n  \t},\r\n\r\n  \t_adjustPan: function (e) {\r\n  \t\tif (!this.options.autoPan) { return; }\r\n  \t\tif (this._map._panAnim) { this._map._panAnim.stop(); }\r\n\r\n  \t\tvar map = this._map,\r\n  \t\t    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\r\n  \t\t    containerHeight = this._container.offsetHeight + marginBottom,\r\n  \t\t    containerWidth = this._containerWidth,\r\n  \t\t    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n  \t\tlayerPos._add(getPosition(this._container));\r\n\r\n  \t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n  \t\t    padding = toPoint(this.options.autoPanPadding),\r\n  \t\t    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\r\n  \t\t    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\r\n  \t\t    size = map.getSize(),\r\n  \t\t    dx = 0,\r\n  \t\t    dy = 0;\r\n\r\n  \t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n  \t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n  \t\t}\r\n  \t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n  \t\t\tdx = containerPos.x - paddingTL.x;\r\n  \t\t}\r\n  \t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n  \t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n  \t\t}\r\n  \t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n  \t\t\tdy = containerPos.y - paddingTL.y;\r\n  \t\t}\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event autopanstart: Event\r\n  \t\t// Fired when the map starts autopanning when opening a popup.\r\n  \t\tif (dx || dy) {\r\n  \t\t\tmap\r\n  \t\t\t    .fire('autopanstart')\r\n  \t\t\t    .panBy([dx, dy], {animate: e && e.type === 'moveend'});\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\t// Where should we anchor the popup on the source layer?\r\n  \t\treturn toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\r\n  \t}\r\n\r\n  });\r\n\r\n  // @namespace Popup\r\n  // @factory L.popup(options?: Popup options, source?: Layer)\r\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\r\n  var popup = function (options, source) {\r\n  \treturn new Popup(options, source);\r\n  };\r\n\r\n\r\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\r\n  Map.mergeOptions({\r\n  \tclosePopupOnClick: true\r\n  });\r\n\r\n\r\n  // @namespace Map\r\n  // @section Methods for Layers and Controls\r\n  Map.include({\r\n  \t// @method openPopup(popup: Popup): this\r\n  \t// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\r\n  \t// @alternative\r\n  \t// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\r\n  \t// Creates a popup with the specified content and options and opens it in the given point on a map.\r\n  \topenPopup: function (popup, latlng, options) {\r\n  \t\tthis._initOverlay(Popup, popup, latlng, options)\r\n  \t\t  .openOn(this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(popup?: Popup): this\r\n  \t// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\r\n  \tclosePopup: function (popup) {\r\n  \t\tpopup = arguments.length ? popup : this._popup;\r\n  \t\tif (popup) {\r\n  \t\t\tpopup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\r\n\r\n  // @section Popup methods\r\n  Layer.include({\r\n\r\n  \t// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\r\n  \t// Binds a popup to the layer with the passed `content` and sets up the\r\n  \t// necessary event listeners. If a `Function` is passed it will receive\r\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\r\n  \tbindPopup: function (content, options) {\r\n  \t\tthis._popup = this._initOverlay(Popup, this._popup, content, options);\r\n  \t\tif (!this._popupHandlersAdded) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = true;\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method unbindPopup(): this\r\n  \t// Removes the popup previously bound with `bindPopup`.\r\n  \tunbindPopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = false;\r\n  \t\t\tthis._popup = null;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method openPopup(latlng?: LatLng): this\r\n  \t// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\r\n  \topenPopup: function (latlng) {\r\n  \t\tif (this._popup && this._popup._prepareOpen(latlng)) {\r\n  \t\t\t// open the popup on the map\r\n  \t\t\tthis._popup.openOn(this._map);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(): this\r\n  \t// Closes the popup bound to this layer if it is open.\r\n  \tclosePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method togglePopup(): this\r\n  \t// Opens or closes the popup bound to this layer depending on its current state.\r\n  \ttogglePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.toggle(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method isPopupOpen(): boolean\r\n  \t// Returns `true` if the popup bound to this layer is currently open.\r\n  \tisPopupOpen: function () {\r\n  \t\treturn (this._popup ? this._popup.isOpen() : false);\r\n  \t},\r\n\r\n  \t// @method setPopupContent(content: String|HTMLElement|Popup): this\r\n  \t// Sets the content of the popup bound to this layer.\r\n  \tsetPopupContent: function (content) {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.setContent(content);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getPopup(): Popup\r\n  \t// Returns the popup bound to this layer.\r\n  \tgetPopup: function () {\r\n  \t\treturn this._popup;\r\n  \t},\r\n\r\n  \t_openPopup: function (e) {\r\n  \t\tif (!this._popup || !this._map) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\t// prevent map click\r\n  \t\tstop(e);\r\n\r\n  \t\tvar target = e.layer || e.target;\r\n  \t\tif (this._popup._source === target && !(target instanceof Path)) {\r\n  \t\t\t// treat it like a marker and figure out\r\n  \t\t\t// if we should toggle it open/closed\r\n  \t\t\tif (this._map.hasLayer(this._popup)) {\r\n  \t\t\t\tthis.closePopup();\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.openPopup(e.latlng);\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tthis._popup._source = target;\r\n  \t\tthis.openPopup(e.latlng);\r\n  \t},\r\n\r\n  \t_movePopup: function (e) {\r\n  \t\tthis._popup.setLatLng(e.latlng);\r\n  \t},\r\n\r\n  \t_onKeyPress: function (e) {\r\n  \t\tif (e.originalEvent.keyCode === 13) {\r\n  \t\t\tthis._openPopup(e);\r\n  \t\t}\r\n  \t}\r\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n\n  \t// @section\n  \t// @aka Tooltip options\n  \toptions: {\n  \t\t// @option pane: String = 'tooltipPane'\n  \t\t// `Map pane` where the tooltip will be added.\n  \t\tpane: 'tooltipPane',\n\n  \t\t// @option offset: Point = Point(0, 0)\n  \t\t// Optional offset of the tooltip position.\n  \t\toffset: [0, 0],\n\n  \t\t// @option direction: String = 'auto'\n  \t\t// Direction where to open the tooltip. Possible values are: `right`, `left`,\n  \t\t// `top`, `bottom`, `center`, `auto`.\n  \t\t// `auto` will dynamically switch between `right` and `left` according to the tooltip\n  \t\t// position on the map.\n  \t\tdirection: 'auto',\n\n  \t\t// @option permanent: Boolean = false\n  \t\t// Whether to open the tooltip permanently or only on mouseover.\n  \t\tpermanent: false,\n\n  \t\t// @option sticky: Boolean = false\n  \t\t// If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n  \t\tsticky: false,\n\n  \t\t// @option opacity: Number = 0.9\n  \t\t// Tooltip container opacity.\n  \t\topacity: 0.9\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\n  \t\tthis.setOpacity(this.options.opacity);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipopen: TooltipEvent\n  \t\t// Fired when a tooltip is opened in the map.\n  \t\tmap.fire('tooltipopen', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.addEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipopen: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is opened.\n  \t\t\tthis._source.fire('tooltipopen', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipclose: TooltipEvent\n  \t\t// Fired when a tooltip in the map is closed.\n  \t\tmap.fire('tooltipclose', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.removeEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipclose: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is closed.\n  \t\t\tthis._source.fire('tooltipclose', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\n\n  \t\tif (!this.options.permanent) {\n  \t\t\tevents.preclick = this.close;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t_initLayout: function () {\n  \t\tvar prefix = 'leaflet-tooltip',\n  \t\t    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n\n  \t\tthis._contentNode = this._container = create$1('div', className);\n  \t},\n\n  \t_updateLayout: function () {},\n\n  \t_adjustPan: function () {},\n\n  \t_setPosition: function (pos) {\n  \t\tvar subX, subY,\n  \t\t    map = this._map,\n  \t\t    container = this._container,\n  \t\t    centerPoint = map.latLngToContainerPoint(map.getCenter()),\n  \t\t    tooltipPoint = map.layerPointToContainerPoint(pos),\n  \t\t    direction = this.options.direction,\n  \t\t    tooltipWidth = container.offsetWidth,\n  \t\t    tooltipHeight = container.offsetHeight,\n  \t\t    offset = toPoint(this.options.offset),\n  \t\t    anchor = this._getAnchor();\n\n  \t\tif (direction === 'top') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight;\n  \t\t} else if (direction === 'bottom') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = 0;\n  \t\t} else if (direction === 'center') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'right') {\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'left') {\n  \t\t\tsubX = tooltipWidth;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (tooltipPoint.x < centerPoint.x) {\n  \t\t\tdirection = 'right';\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else {\n  \t\t\tdirection = 'left';\n  \t\t\tsubX = tooltipWidth + (offset.x + anchor.x) * 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t}\n\n  \t\tpos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n\n  \t\tremoveClass(container, 'leaflet-tooltip-right');\n  \t\tremoveClass(container, 'leaflet-tooltip-left');\n  \t\tremoveClass(container, 'leaflet-tooltip-top');\n  \t\tremoveClass(container, 'leaflet-tooltip-bottom');\n  \t\taddClass(container, 'leaflet-tooltip-' + direction);\n  \t\tsetPosition(container, pos);\n  \t},\n\n  \t_updatePosition: function () {\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n\n  \t\tif (this._container) {\n  \t\t\tsetOpacity(this._container, opacity);\n  \t\t}\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \t_getAnchor: function () {\n  \t\t// Where should we anchor the tooltip on the source layer?\n  \t\treturn toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n  \t}\n\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  var tooltip = function (options, source) {\n  \treturn new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n\n  \t// @method openTooltip(tooltip: Tooltip): this\n  \t// Opens the specified tooltip.\n  \t// @alternative\n  \t// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n  \t// Creates a tooltip with the specified content and options and open it.\n  \topenTooltip: function (tooltip, latlng, options) {\n  \t\tthis._initOverlay(Tooltip, tooltip, latlng, options)\n  \t\t  .openOn(this);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(tooltip: Tooltip): this\n  \t// Closes the tooltip given as parameter.\n  \tcloseTooltip: function (tooltip) {\n  \t\ttooltip.close();\n  \t\treturn this;\n  \t}\n\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n\n  \t// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n  \t// Binds a tooltip to the layer with the passed `content` and sets up the\n  \t// necessary event listeners. If a `Function` is passed it will receive\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\n  \tbindTooltip: function (content, options) {\n\n  \t\tif (this._tooltip && this.isTooltipOpen()) {\n  \t\t\tthis.unbindTooltip();\n  \t\t}\n\n  \t\tthis._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n  \t\tthis._initTooltipInteractions();\n\n  \t\tif (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n  \t\t\tthis.openTooltip();\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \t// @method unbindTooltip(): this\n  \t// Removes the tooltip previously bound with `bindTooltip`.\n  \tunbindTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._initTooltipInteractions(true);\n  \t\t\tthis.closeTooltip();\n  \t\t\tthis._tooltip = null;\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_initTooltipInteractions: function (remove) {\n  \t\tif (!remove && this._tooltipHandlersAdded) { return; }\n  \t\tvar onOff = remove ? 'off' : 'on',\n  \t\t    events = {\n  \t\t\tremove: this.closeTooltip,\n  \t\t\tmove: this._moveTooltip\n  \t\t    };\n  \t\tif (!this._tooltip.options.permanent) {\n  \t\t\tevents.mouseover = this._openTooltip;\n  \t\t\tevents.mouseout = this.closeTooltip;\n  \t\t\tevents.click = this._openTooltip;\n  \t\t} else {\n  \t\t\tevents.add = this._openTooltip;\n  \t\t}\n  \t\tif (this._tooltip.options.sticky) {\n  \t\t\tevents.mousemove = this._moveTooltip;\n  \t\t}\n  \t\tthis[onOff](events);\n  \t\tthis._tooltipHandlersAdded = !remove;\n  \t},\n\n  \t// @method openTooltip(latlng?: LatLng): this\n  \t// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n  \topenTooltip: function (latlng) {\n  \t\tif (this._tooltip && this._tooltip._prepareOpen(latlng)) {\n  \t\t\t// open the tooltip on the map\n  \t\t\tthis._tooltip.openOn(this._map);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(): this\n  \t// Closes the tooltip bound to this layer if it is open.\n  \tcloseTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\treturn this._tooltip.close();\n  \t\t}\n  \t},\n\n  \t// @method toggleTooltip(): this\n  \t// Opens or closes the tooltip bound to this layer depending on its current state.\n  \ttoggleTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.toggle(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method isTooltipOpen(): boolean\n  \t// Returns `true` if the tooltip bound to this layer is currently open.\n  \tisTooltipOpen: function () {\n  \t\treturn this._tooltip.isOpen();\n  \t},\n\n  \t// @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n  \t// Sets the content of the tooltip bound to this layer.\n  \tsetTooltipContent: function (content) {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.setContent(content);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getTooltip(): Tooltip\n  \t// Returns the tooltip bound to this layer.\n  \tgetTooltip: function () {\n  \t\treturn this._tooltip;\n  \t},\n\n  \t_openTooltip: function (e) {\n  \t\tif (!this._tooltip || !this._map || (this._map.dragging && this._map.dragging.moving())) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthis._tooltip._source = e.layer || e.target;\n\n  \t\tthis.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n  \t},\n\n  \t_moveTooltip: function (e) {\n  \t\tvar latlng = e.latlng, containerPoint, layerPoint;\n  \t\tif (this._tooltip.options.sticky && e.originalEvent) {\n  \t\t\tcontainerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n  \t\t\tlayerPoint = this._map.containerPointToLayerPoint(containerPoint);\n  \t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n  \t\t}\n  \t\tthis._tooltip.setLatLng(latlng);\n  \t}\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n  \toptions: {\n  \t\t// @section\n  \t\t// @aka DivIcon options\n  \t\ticonSize: [12, 12], // also can be set through CSS\n\n  \t\t// iconAnchor: (Point),\n  \t\t// popupAnchor: (Point),\n\n  \t\t// @option html: String|HTMLElement = ''\n  \t\t// Custom HTML code to put inside the div element, empty by default. Alternatively,\n  \t\t// an instance of `HTMLElement`.\n  \t\thtml: false,\n\n  \t\t// @option bgPos: Point = [0, 0]\n  \t\t// Optional relative position of the background, in pixels\n  \t\tbgPos: null,\n\n  \t\tclassName: 'leaflet-div-icon'\n  \t},\n\n  \tcreateIcon: function (oldIcon) {\n  \t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n  \t\t    options = this.options;\n\n  \t\tif (options.html instanceof Element) {\n  \t\t\tempty(div);\n  \t\t\tdiv.appendChild(options.html);\n  \t\t} else {\n  \t\t\tdiv.innerHTML = options.html !== false ? options.html : '';\n  \t\t}\n\n  \t\tif (options.bgPos) {\n  \t\t\tvar bgPos = toPoint(options.bgPos);\n  \t\t\tdiv.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';\n  \t\t}\n  \t\tthis._setIconStyles(div, 'icon');\n\n  \t\treturn div;\n  \t},\n\n  \tcreateShadow: function () {\n  \t\treturn null;\n  \t}\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n  \treturn new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n\n  var GridLayer = Layer.extend({\n\n  \t// @section\n  \t// @aka GridLayer options\n  \toptions: {\n  \t\t// @option tileSize: Number|Point = 256\n  \t\t// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n  \t\ttileSize: 256,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Opacity of the tiles. Can be used in the `createTile()` function.\n  \t\topacity: 1,\n\n  \t\t// @option updateWhenIdle: Boolean = (depends)\n  \t\t// Load new tiles only when panning ends.\n  \t\t// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n  \t\t// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n  \t\t// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n  \t\tupdateWhenIdle: Browser.mobile,\n\n  \t\t// @option updateWhenZooming: Boolean = true\n  \t\t// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n  \t\tupdateWhenZooming: true,\n\n  \t\t// @option updateInterval: Number = 200\n  \t\t// Tiles will not update more than once every `updateInterval` milliseconds when panning.\n  \t\tupdateInterval: 200,\n\n  \t\t// @option zIndex: Number = 1\n  \t\t// The explicit zIndex of the tile layer.\n  \t\tzIndex: 1,\n\n  \t\t// @option bounds: LatLngBounds = undefined\n  \t\t// If set, tiles will only be loaded inside the set `LatLngBounds`.\n  \t\tbounds: null,\n\n  \t\t// @option minZoom: Number = 0\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\n  \t\tminZoom: 0,\n\n  \t\t// @option maxZoom: Number = undefined\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\n  \t\tmaxZoom: undefined,\n\n  \t\t// @option maxNativeZoom: Number = undefined\n  \t\t// Maximum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n  \t\t// from `maxNativeZoom` level and auto-scaled.\n  \t\tmaxNativeZoom: undefined,\n\n  \t\t// @option minNativeZoom: Number = undefined\n  \t\t// Minimum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n  \t\t// from `minNativeZoom` level and auto-scaled.\n  \t\tminNativeZoom: undefined,\n\n  \t\t// @option noWrap: Boolean = false\n  \t\t// Whether the layer is wrapped around the antimeridian. If `true`, the\n  \t\t// GridLayer will only be displayed once at low zoom levels. Has no\n  \t\t// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n  \t\t// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n  \t\t// tiles outside the CRS limits.\n  \t\tnoWrap: false,\n\n  \t\t// @option pane: String = 'tilePane'\n  \t\t// `Map pane` where the grid layer will be added.\n  \t\tpane: 'tilePane',\n\n  \t\t// @option className: String = ''\n  \t\t// A custom class name to assign to the tile layer. Empty by default.\n  \t\tclassName: '',\n\n  \t\t// @option keepBuffer: Number = 2\n  \t\t// When panning the map, keep this many rows and columns of tiles before unloading them.\n  \t\tkeepBuffer: 2\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._initContainer();\n\n  \t\tthis._levels = {};\n  \t\tthis._tiles = {};\n\n  \t\tthis._resetView(); // implicit _update() call\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\tmap._addZoomLimit(this);\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tthis._removeAllTiles();\n  \t\tremove(this._container);\n  \t\tmap._removeZoomLimit(this);\n  \t\tthis._container = null;\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t// @method bringToFront: this\n  \t// Brings the tile layer to the top of all tile layers.\n  \tbringToFront: function () {\n  \t\tif (this._map) {\n  \t\t\ttoFront(this._container);\n  \t\t\tthis._setAutoZIndex(Math.max);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack: this\n  \t// Brings the tile layer to the bottom of all tile layers.\n  \tbringToBack: function () {\n  \t\tif (this._map) {\n  \t\t\ttoBack(this._container);\n  \t\t\tthis._setAutoZIndex(Math.min);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getContainer: HTMLElement\n  \t// Returns the HTML element that contains the tiles for this layer.\n  \tgetContainer: function () {\n  \t\treturn this._container;\n  \t},\n\n  \t// @method setOpacity(opacity: Number): this\n  \t// Changes the [opacity](#gridlayer-opacity) of the grid layer.\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n  \t\tthis._updateOpacity();\n  \t\treturn this;\n  \t},\n\n  \t// @method setZIndex(zIndex: Number): this\n  \t// Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n  \tsetZIndex: function (zIndex) {\n  \t\tthis.options.zIndex = zIndex;\n  \t\tthis._updateZIndex();\n\n  \t\treturn this;\n  \t},\n\n  \t// @method isLoading: Boolean\n  \t// Returns `true` if any tile in the grid layer has not finished loading.\n  \tisLoading: function () {\n  \t\treturn this._loading;\n  \t},\n\n  \t// @method redraw: this\n  \t// Causes the layer to clear all the tiles and request them again.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\tvar tileZoom = this._clampZoom(this._map.getZoom());\n  \t\t\tif (tileZoom !== this._tileZoom) {\n  \t\t\t\tthis._tileZoom = tileZoom;\n  \t\t\t\tthis._updateLevels();\n  \t\t\t}\n  \t\t\tthis._update();\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewprereset: this._invalidateAll,\n  \t\t\tviewreset: this._resetView,\n  \t\t\tzoom: this._resetView,\n  \t\t\tmoveend: this._onMoveEnd\n  \t\t};\n\n  \t\tif (!this.options.updateWhenIdle) {\n  \t\t\t// update tiles on move, but not more often than once per given interval\n  \t\t\tif (!this._onMove) {\n  \t\t\t\tthis._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n  \t\t\t}\n\n  \t\t\tevents.move = this._onMove;\n  \t\t}\n\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._animateZoom;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t// @section Extension methods\n  \t// Layers extending `GridLayer` shall reimplement the following method.\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\n  \t// Called only internally, must be overridden by classes extending `GridLayer`.\n  \t// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  \t// is specified, it must be called when the tile has finished loading and drawing.\n  \tcreateTile: function () {\n  \t\treturn document.createElement('div');\n  \t},\n\n  \t// @section\n  \t// @method getTileSize: Point\n  \t// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n  \tgetTileSize: function () {\n  \t\tvar s = this.options.tileSize;\n  \t\treturn s instanceof Point ? s : new Point(s, s);\n  \t},\n\n  \t_updateZIndex: function () {\n  \t\tif (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n  \t\t\tthis._container.style.zIndex = this.options.zIndex;\n  \t\t}\n  \t},\n\n  \t_setAutoZIndex: function (compare) {\n  \t\t// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n  \t\tvar layers = this.getPane().children,\n  \t\t    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n  \t\tfor (var i = 0, len = layers.length, zIndex; i < len; i++) {\n\n  \t\t\tzIndex = layers[i].style.zIndex;\n\n  \t\t\tif (layers[i] !== this._container && zIndex) {\n  \t\t\t\tedgeZIndex = compare(edgeZIndex, +zIndex);\n  \t\t\t}\n  \t\t}\n\n  \t\tif (isFinite(edgeZIndex)) {\n  \t\t\tthis.options.zIndex = edgeZIndex + compare(-1, 1);\n  \t\t\tthis._updateZIndex();\n  \t\t}\n  \t},\n\n  \t_updateOpacity: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\t// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n  \t\tif (Browser.ielt9) { return; }\n\n  \t\tsetOpacity(this._container, this.options.opacity);\n\n  \t\tvar now = +new Date(),\n  \t\t    nextFrame = false,\n  \t\t    willPrune = false;\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar tile = this._tiles[key];\n  \t\t\tif (!tile.current || !tile.loaded) { continue; }\n\n  \t\t\tvar fade = Math.min(1, (now - tile.loaded) / 200);\n\n  \t\t\tsetOpacity(tile.el, fade);\n  \t\t\tif (fade < 1) {\n  \t\t\t\tnextFrame = true;\n  \t\t\t} else {\n  \t\t\t\tif (tile.active) {\n  \t\t\t\t\twillPrune = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tthis._onOpaqueTile(tile);\n  \t\t\t\t}\n  \t\t\t\ttile.active = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (willPrune && !this._noPrune) { this._pruneTiles(); }\n\n  \t\tif (nextFrame) {\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t}\n  \t},\n\n  \t_onOpaqueTile: falseFn,\n\n  \t_initContainer: function () {\n  \t\tif (this._container) { return; }\n\n  \t\tthis._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n  \t\tthis._updateZIndex();\n\n  \t\tif (this.options.opacity < 1) {\n  \t\t\tthis._updateOpacity();\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t},\n\n  \t_updateLevels: function () {\n\n  \t\tvar zoom = this._tileZoom,\n  \t\t    maxZoom = this.options.maxZoom;\n\n  \t\tif (zoom === undefined) { return undefined; }\n\n  \t\tfor (var z in this._levels) {\n  \t\t\tz = Number(z);\n  \t\t\tif (this._levels[z].el.children.length || z === zoom) {\n  \t\t\t\tthis._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n  \t\t\t\tthis._onUpdateLevel(z);\n  \t\t\t} else {\n  \t\t\t\tremove(this._levels[z].el);\n  \t\t\t\tthis._removeTilesAtZoom(z);\n  \t\t\t\tthis._onRemoveLevel(z);\n  \t\t\t\tdelete this._levels[z];\n  \t\t\t}\n  \t\t}\n\n  \t\tvar level = this._levels[zoom],\n  \t\t    map = this._map;\n\n  \t\tif (!level) {\n  \t\t\tlevel = this._levels[zoom] = {};\n\n  \t\t\tlevel.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n  \t\t\tlevel.el.style.zIndex = maxZoom;\n\n  \t\t\tlevel.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n  \t\t\tlevel.zoom = zoom;\n\n  \t\t\tthis._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n  \t\t\t// force the browser to consider the newly added element for transition\n  \t\t\tfalseFn(level.el.offsetWidth);\n\n  \t\t\tthis._onCreateLevel(level);\n  \t\t}\n\n  \t\tthis._level = level;\n\n  \t\treturn level;\n  \t},\n\n  \t_onUpdateLevel: falseFn,\n\n  \t_onRemoveLevel: falseFn,\n\n  \t_onCreateLevel: falseFn,\n\n  \t_pruneTiles: function () {\n  \t\tif (!this._map) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar key, tile;\n\n  \t\tvar zoom = this._map.getZoom();\n  \t\tif (zoom > this.options.maxZoom ||\n  \t\t\tzoom < this.options.minZoom) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\ttile.retain = tile.current;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\tif (tile.current && !tile.active) {\n  \t\t\t\tvar coords = tile.coords;\n  \t\t\t\tif (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n  \t\t\t\t\tthis._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\tif (!this._tiles[key].retain) {\n  \t\t\t\tthis._removeTile(key);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_removeTilesAtZoom: function (zoom) {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (this._tiles[key].coords.z !== zoom) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_removeAllTiles: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_invalidateAll: function () {\n  \t\tfor (var z in this._levels) {\n  \t\t\tremove(this._levels[z].el);\n  \t\t\tthis._onRemoveLevel(Number(z));\n  \t\t\tdelete this._levels[z];\n  \t\t}\n  \t\tthis._removeAllTiles();\n\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t_retainParent: function (x, y, z, minZoom) {\n  \t\tvar x2 = Math.floor(x / 2),\n  \t\t    y2 = Math.floor(y / 2),\n  \t\t    z2 = z - 1,\n  \t\t    coords2 = new Point(+x2, +y2);\n  \t\tcoords2.z = +z2;\n\n  \t\tvar key = this._tileCoordsToKey(coords2),\n  \t\t    tile = this._tiles[key];\n\n  \t\tif (tile && tile.active) {\n  \t\t\ttile.retain = true;\n  \t\t\treturn true;\n\n  \t\t} else if (tile && tile.loaded) {\n  \t\t\ttile.retain = true;\n  \t\t}\n\n  \t\tif (z2 > minZoom) {\n  \t\t\treturn this._retainParent(x2, y2, z2, minZoom);\n  \t\t}\n\n  \t\treturn false;\n  \t},\n\n  \t_retainChildren: function (x, y, z, maxZoom) {\n\n  \t\tfor (var i = 2 * x; i < 2 * x + 2; i++) {\n  \t\t\tfor (var j = 2 * y; j < 2 * y + 2; j++) {\n\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = z + 1;\n\n  \t\t\t\tvar key = this._tileCoordsToKey(coords),\n  \t\t\t\t    tile = this._tiles[key];\n\n  \t\t\t\tif (tile && tile.active) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t\tcontinue;\n\n  \t\t\t\t} else if (tile && tile.loaded) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (z + 1 < maxZoom) {\n  \t\t\t\t\tthis._retainChildren(i, j, z + 1, maxZoom);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_resetView: function (e) {\n  \t\tvar animating = e && (e.pinch || e.flyTo);\n  \t\tthis._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tthis._setView(e.center, e.zoom, true, e.noUpdate);\n  \t},\n\n  \t_clampZoom: function (zoom) {\n  \t\tvar options = this.options;\n\n  \t\tif (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n  \t\t\treturn options.minNativeZoom;\n  \t\t}\n\n  \t\tif (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n  \t\t\treturn options.maxNativeZoom;\n  \t\t}\n\n  \t\treturn zoom;\n  \t},\n\n  \t_setView: function (center, zoom, noPrune, noUpdate) {\n  \t\tvar tileZoom = Math.round(zoom);\n  \t\tif ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\n  \t\t    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\n  \t\t\ttileZoom = undefined;\n  \t\t} else {\n  \t\t\ttileZoom = this._clampZoom(tileZoom);\n  \t\t}\n\n  \t\tvar tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);\n\n  \t\tif (!noUpdate || tileZoomChanged) {\n\n  \t\t\tthis._tileZoom = tileZoom;\n\n  \t\t\tif (this._abortLoading) {\n  \t\t\t\tthis._abortLoading();\n  \t\t\t}\n\n  \t\t\tthis._updateLevels();\n  \t\t\tthis._resetGrid();\n\n  \t\t\tif (tileZoom !== undefined) {\n  \t\t\t\tthis._update(center);\n  \t\t\t}\n\n  \t\t\tif (!noPrune) {\n  \t\t\t\tthis._pruneTiles();\n  \t\t\t}\n\n  \t\t\t// Flag to prevent _updateOpacity from pruning tiles during\n  \t\t\t// a zoom anim or a pinch gesture\n  \t\t\tthis._noPrune = !!noPrune;\n  \t\t}\n\n  \t\tthis._setZoomTransforms(center, zoom);\n  \t},\n\n  \t_setZoomTransforms: function (center, zoom) {\n  \t\tfor (var i in this._levels) {\n  \t\t\tthis._setZoomTransform(this._levels[i], center, zoom);\n  \t\t}\n  \t},\n\n  \t_setZoomTransform: function (level, center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, level.zoom),\n  \t\t    translate = level.origin.multiplyBy(scale)\n  \t\t        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(level.el, translate, scale);\n  \t\t} else {\n  \t\t\tsetPosition(level.el, translate);\n  \t\t}\n  \t},\n\n  \t_resetGrid: function () {\n  \t\tvar map = this._map,\n  \t\t    crs = map.options.crs,\n  \t\t    tileSize = this._tileSize = this.getTileSize(),\n  \t\t    tileZoom = this._tileZoom;\n\n  \t\tvar bounds = this._map.getPixelWorldBounds(this._tileZoom);\n  \t\tif (bounds) {\n  \t\t\tthis._globalTileRange = this._pxBoundsToTileRange(bounds);\n  \t\t}\n\n  \t\tthis._wrapX = crs.wrapLng && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),\n  \t\t\tMath.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)\n  \t\t];\n  \t\tthis._wrapY = crs.wrapLat && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),\n  \t\t\tMath.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)\n  \t\t];\n  \t},\n\n  \t_onMoveEnd: function () {\n  \t\tif (!this._map || this._map._animatingZoom) { return; }\n\n  \t\tthis._update();\n  \t},\n\n  \t_getTiledPixelBounds: function (center) {\n  \t\tvar map = this._map,\n  \t\t    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n  \t\t    scale = map.getZoomScale(mapZoom, this._tileZoom),\n  \t\t    pixelCenter = map.project(center, this._tileZoom).floor(),\n  \t\t    halfSize = map.getSize().divideBy(scale * 2);\n\n  \t\treturn new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  \t},\n\n  \t// Private method to load tiles in the grid's active zoom level according to map bounds\n  \t_update: function (center) {\n  \t\tvar map = this._map;\n  \t\tif (!map) { return; }\n  \t\tvar zoom = this._clampZoom(map.getZoom());\n\n  \t\tif (center === undefined) { center = map.getCenter(); }\n  \t\tif (this._tileZoom === undefined) { return; }\t// if out of minzoom/maxzoom\n\n  \t\tvar pixelBounds = this._getTiledPixelBounds(center),\n  \t\t    tileRange = this._pxBoundsToTileRange(pixelBounds),\n  \t\t    tileCenter = tileRange.getCenter(),\n  \t\t    queue = [],\n  \t\t    margin = this.options.keepBuffer,\n  \t\t    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),\n  \t\t                              tileRange.getTopRight().add([margin, -margin]));\n\n  \t\t// Sanity check: panic if the tile range contains Infinity somewhere.\n  \t\tif (!(isFinite(tileRange.min.x) &&\n  \t\t      isFinite(tileRange.min.y) &&\n  \t\t      isFinite(tileRange.max.x) &&\n  \t\t      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar c = this._tiles[key].coords;\n  \t\t\tif (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n  \t\t\t\tthis._tiles[key].current = false;\n  \t\t\t}\n  \t\t}\n\n  \t\t// _update just loads more tiles. If the tile zoom level differs too much\n  \t\t// from the map's, let _setView reset levels and prune old tiles.\n  \t\tif (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }\n\n  \t\t// create a queue of coordinates to load tiles from\n  \t\tfor (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n  \t\t\tfor (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = this._tileZoom;\n\n  \t\t\t\tif (!this._isValidTile(coords)) { continue; }\n\n  \t\t\t\tvar tile = this._tiles[this._tileCoordsToKey(coords)];\n  \t\t\t\tif (tile) {\n  \t\t\t\t\ttile.current = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tqueue.push(coords);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// sort tile queue to load tiles in order of their distance to center\n  \t\tqueue.sort(function (a, b) {\n  \t\t\treturn a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n  \t\t});\n\n  \t\tif (queue.length !== 0) {\n  \t\t\t// if it's the first batch of tiles to load\n  \t\t\tif (!this._loading) {\n  \t\t\t\tthis._loading = true;\n  \t\t\t\t// @event loading: Event\n  \t\t\t\t// Fired when the grid layer starts loading tiles.\n  \t\t\t\tthis.fire('loading');\n  \t\t\t}\n\n  \t\t\t// create DOM fragment to append tiles in one batch\n  \t\t\tvar fragment = document.createDocumentFragment();\n\n  \t\t\tfor (i = 0; i < queue.length; i++) {\n  \t\t\t\tthis._addTile(queue[i], fragment);\n  \t\t\t}\n\n  \t\t\tthis._level.el.appendChild(fragment);\n  \t\t}\n  \t},\n\n  \t_isValidTile: function (coords) {\n  \t\tvar crs = this._map.options.crs;\n\n  \t\tif (!crs.infinite) {\n  \t\t\t// don't load tile if it's out of bounds and not wrapped\n  \t\t\tvar bounds = this._globalTileRange;\n  \t\t\tif ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\n  \t\t\t    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }\n  \t\t}\n\n  \t\tif (!this.options.bounds) { return true; }\n\n  \t\t// don't load tile if it doesn't intersect the bounds in options\n  \t\tvar tileBounds = this._tileCoordsToBounds(coords);\n  \t\treturn toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n  \t},\n\n  \t_keyToBounds: function (key) {\n  \t\treturn this._tileCoordsToBounds(this._keyToTileCoords(key));\n  \t},\n\n  \t_tileCoordsToNwSe: function (coords) {\n  \t\tvar map = this._map,\n  \t\t    tileSize = this.getTileSize(),\n  \t\t    nwPoint = coords.scaleBy(tileSize),\n  \t\t    sePoint = nwPoint.add(tileSize),\n  \t\t    nw = map.unproject(nwPoint, coords.z),\n  \t\t    se = map.unproject(sePoint, coords.z);\n  \t\treturn [nw, se];\n  \t},\n\n  \t// converts tile coordinates to its geographical bounds\n  \t_tileCoordsToBounds: function (coords) {\n  \t\tvar bp = this._tileCoordsToNwSe(coords),\n  \t\t    bounds = new LatLngBounds(bp[0], bp[1]);\n\n  \t\tif (!this.options.noWrap) {\n  \t\t\tbounds = this._map.wrapLatLngBounds(bounds);\n  \t\t}\n  \t\treturn bounds;\n  \t},\n  \t// converts tile coordinates to key for the tile cache\n  \t_tileCoordsToKey: function (coords) {\n  \t\treturn coords.x + ':' + coords.y + ':' + coords.z;\n  \t},\n\n  \t// converts tile cache key to coordinates\n  \t_keyToTileCoords: function (key) {\n  \t\tvar k = key.split(':'),\n  \t\t    coords = new Point(+k[0], +k[1]);\n  \t\tcoords.z = +k[2];\n  \t\treturn coords;\n  \t},\n\n  \t_removeTile: function (key) {\n  \t\tvar tile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\tremove(tile.el);\n\n  \t\tdelete this._tiles[key];\n\n  \t\t// @event tileunload: TileEvent\n  \t\t// Fired when a tile is removed (e.g. when a tile goes off the screen).\n  \t\tthis.fire('tileunload', {\n  \t\t\ttile: tile.el,\n  \t\t\tcoords: this._keyToTileCoords(key)\n  \t\t});\n  \t},\n\n  \t_initTile: function (tile) {\n  \t\taddClass(tile, 'leaflet-tile');\n\n  \t\tvar tileSize = this.getTileSize();\n  \t\ttile.style.width = tileSize.x + 'px';\n  \t\ttile.style.height = tileSize.y + 'px';\n\n  \t\ttile.onselectstart = falseFn;\n  \t\ttile.onmousemove = falseFn;\n\n  \t\t// update opacity on tiles in IE7-8 because of filter inheritance problems\n  \t\tif (Browser.ielt9 && this.options.opacity < 1) {\n  \t\t\tsetOpacity(tile, this.options.opacity);\n  \t\t}\n  \t},\n\n  \t_addTile: function (coords, container) {\n  \t\tvar tilePos = this._getTilePos(coords),\n  \t\t    key = this._tileCoordsToKey(coords);\n\n  \t\tvar tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n  \t\tthis._initTile(tile);\n\n  \t\t// if createTile is defined with a second argument (\"done\" callback),\n  \t\t// we know that tile is async and will be ready later; otherwise\n  \t\tif (this.createTile.length < 2) {\n  \t\t\t// mark tile as ready, but delay one frame for opacity animation to happen\n  \t\t\trequestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n  \t\t}\n\n  \t\tsetPosition(tile, tilePos);\n\n  \t\t// save tile in cache\n  \t\tthis._tiles[key] = {\n  \t\t\tel: tile,\n  \t\t\tcoords: coords,\n  \t\t\tcurrent: true\n  \t\t};\n\n  \t\tcontainer.appendChild(tile);\n  \t\t// @event tileloadstart: TileEvent\n  \t\t// Fired when a tile is requested and starts loading.\n  \t\tthis.fire('tileloadstart', {\n  \t\t\ttile: tile,\n  \t\t\tcoords: coords\n  \t\t});\n  \t},\n\n  \t_tileReady: function (coords, err, tile) {\n  \t\tif (err) {\n  \t\t\t// @event tileerror: TileErrorEvent\n  \t\t\t// Fired when there is an error loading a tile.\n  \t\t\tthis.fire('tileerror', {\n  \t\t\t\terror: err,\n  \t\t\t\ttile: tile,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tvar key = this._tileCoordsToKey(coords);\n\n  \t\ttile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\ttile.loaded = +new Date();\n  \t\tif (this._map._fadeAnimated) {\n  \t\t\tsetOpacity(tile.el, 0);\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t} else {\n  \t\t\ttile.active = true;\n  \t\t\tthis._pruneTiles();\n  \t\t}\n\n  \t\tif (!err) {\n  \t\t\taddClass(tile.el, 'leaflet-tile-loaded');\n\n  \t\t\t// @event tileload: TileEvent\n  \t\t\t// Fired when a tile loads.\n  \t\t\tthis.fire('tileload', {\n  \t\t\t\ttile: tile.el,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tif (this._noTilesToLoad()) {\n  \t\t\tthis._loading = false;\n  \t\t\t// @event load: Event\n  \t\t\t// Fired when the grid layer loaded all visible tiles.\n  \t\t\tthis.fire('load');\n\n  \t\t\tif (Browser.ielt9 || !this._map._fadeAnimated) {\n  \t\t\t\trequestAnimFrame(this._pruneTiles, this);\n  \t\t\t} else {\n  \t\t\t\t// Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n  \t\t\t\t// to trigger a pruning.\n  \t\t\t\tsetTimeout(bind(this._pruneTiles, this), 250);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_getTilePos: function (coords) {\n  \t\treturn coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n  \t},\n\n  \t_wrapCoords: function (coords) {\n  \t\tvar newCoords = new Point(\n  \t\t\tthis._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,\n  \t\t\tthis._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n  \t\tnewCoords.z = coords.z;\n  \t\treturn newCoords;\n  \t},\n\n  \t_pxBoundsToTileRange: function (bounds) {\n  \t\tvar tileSize = this.getTileSize();\n  \t\treturn new Bounds(\n  \t\t\tbounds.min.unscaleBy(tileSize).floor(),\n  \t\t\tbounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n  \t},\n\n  \t_noTilesToLoad: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (!this._tiles[key].loaded) { return false; }\n  \t\t}\n  \t\treturn true;\n  \t}\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n  \treturn new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\r\n\r\n\r\n  var TileLayer = GridLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer options\r\n  \toptions: {\r\n  \t\t// @option minZoom: Number = 0\r\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\r\n  \t\tminZoom: 0,\r\n\r\n  \t\t// @option maxZoom: Number = 18\r\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\r\n  \t\tmaxZoom: 18,\r\n\r\n  \t\t// @option subdomains: String|String[] = 'abc'\r\n  \t\t// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\r\n  \t\tsubdomains: 'abc',\r\n\r\n  \t\t// @option errorTileUrl: String = ''\r\n  \t\t// URL to the tile image to show in place of the tile that failed to load.\r\n  \t\terrorTileUrl: '',\r\n\r\n  \t\t// @option zoomOffset: Number = 0\r\n  \t\t// The zoom number used in tile URLs will be offset with this value.\r\n  \t\tzoomOffset: 0,\r\n\r\n  \t\t// @option tms: Boolean = false\r\n  \t\t// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\r\n  \t\ttms: false,\r\n\r\n  \t\t// @option zoomReverse: Boolean = false\r\n  \t\t// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\r\n  \t\tzoomReverse: false,\r\n\r\n  \t\t// @option detectRetina: Boolean = false\r\n  \t\t// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\r\n  \t\tdetectRetina: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option referrerPolicy: Boolean|String = false\r\n  \t\t// Whether the referrerPolicy attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\r\n  \t\t// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\r\n  \t\t// (e.g. to validate an API token).\r\n  \t\t// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\r\n  \t\treferrerPolicy: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n  \t\tif (options.detectRetina && Browser.retina && options.maxZoom > 0) {\r\n\r\n  \t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\r\n  \t\t\tif (!options.zoomReverse) {\r\n  \t\t\t\toptions.zoomOffset++;\r\n  \t\t\t\toptions.maxZoom--;\r\n  \t\t\t} else {\r\n  \t\t\t\toptions.zoomOffset--;\r\n  \t\t\t\toptions.minZoom++;\r\n  \t\t\t}\r\n\r\n  \t\t\toptions.minZoom = Math.max(0, options.minZoom);\r\n  \t\t}\r\n\r\n  \t\tif (typeof options.subdomains === 'string') {\r\n  \t\t\toptions.subdomains = options.subdomains.split('');\r\n  \t\t}\r\n\r\n  \t\tthis.on('tileunload', this._onTileRemove);\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String, noRedraw?: Boolean): this\r\n  \t// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\r\n  \t// If the URL does not change, the layer will not be redrawn unless\r\n  \t// the noRedraw parameter is set to false.\r\n  \tsetUrl: function (url, noRedraw) {\r\n  \t\tif (this._url === url && noRedraw === undefined) {\r\n  \t\t\tnoRedraw = true;\r\n  \t\t}\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\r\n  \t// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\r\n  \t// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\r\n  \t// callback is called when the tile has been loaded.\r\n  \tcreateTile: function (coords, done) {\r\n  \t\tvar tile = document.createElement('img');\r\n\r\n  \t\ton(tile, 'load', bind(this._tileOnLoad, this, done, tile));\r\n  \t\ton(tile, 'error', bind(this._tileOnError, this, done, tile));\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\ttile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\t// for this new option we follow the documented behavior\r\n  \t\t// more closely by only setting the property when string\r\n  \t\tif (typeof this.options.referrerPolicy === 'string') {\r\n  \t\t\ttile.referrerPolicy = this.options.referrerPolicy;\r\n  \t\t}\r\n\r\n  \t\t/*\r\n  \t\t Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n  \t\t https://www.w3.org/TR/WCAG20-TECHS/H67\r\n  \t\t*/\r\n  \t\ttile.alt = '';\r\n\r\n  \t\t/*\r\n  \t\t Set role=\"presentation\" to force screen readers to ignore this\r\n  \t\t https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n  \t\t*/\r\n  \t\ttile.setAttribute('role', 'presentation');\r\n\r\n  \t\ttile.src = this.getTileUrl(coords);\r\n\r\n  \t\treturn tile;\r\n  \t},\r\n\r\n  \t// @section Extension methods\r\n  \t// @uninheritable\r\n  \t// Layers extending `TileLayer` might reimplement the following method.\r\n  \t// @method getTileUrl(coords: Object): String\r\n  \t// Called only internally, returns the URL for a tile given its coordinates.\r\n  \t// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\r\n  \tgetTileUrl: function (coords) {\r\n  \t\tvar data = {\r\n  \t\t\tr: Browser.retina ? '@2x' : '',\r\n  \t\t\ts: this._getSubdomain(coords),\r\n  \t\t\tx: coords.x,\r\n  \t\t\ty: coords.y,\r\n  \t\t\tz: this._getZoomForUrl()\r\n  \t\t};\r\n  \t\tif (this._map && !this._map.options.crs.infinite) {\r\n  \t\t\tvar invertedY = this._globalTileRange.max.y - coords.y;\r\n  \t\t\tif (this.options.tms) {\r\n  \t\t\t\tdata['y'] = invertedY;\r\n  \t\t\t}\r\n  \t\t\tdata['-y'] = invertedY;\r\n  \t\t}\r\n\r\n  \t\treturn template(this._url, extend(data, this.options));\r\n  \t},\r\n\r\n  \t_tileOnLoad: function (done, tile) {\r\n  \t\t// For https://github.com/Leaflet/Leaflet/issues/3332\r\n  \t\tif (Browser.ielt9) {\r\n  \t\t\tsetTimeout(bind(done, this, null, tile), 0);\r\n  \t\t} else {\r\n  \t\t\tdone(null, tile);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_tileOnError: function (done, tile, e) {\r\n  \t\tvar errorUrl = this.options.errorTileUrl;\r\n  \t\tif (errorUrl && tile.getAttribute('src') !== errorUrl) {\r\n  \t\t\ttile.src = errorUrl;\r\n  \t\t}\r\n  \t\tdone(e, tile);\r\n  \t},\r\n\r\n  \t_onTileRemove: function (e) {\r\n  \t\te.tile.onload = null;\r\n  \t},\r\n\r\n  \t_getZoomForUrl: function () {\r\n  \t\tvar zoom = this._tileZoom,\r\n  \t\tmaxZoom = this.options.maxZoom,\r\n  \t\tzoomReverse = this.options.zoomReverse,\r\n  \t\tzoomOffset = this.options.zoomOffset;\r\n\r\n  \t\tif (zoomReverse) {\r\n  \t\t\tzoom = maxZoom - zoom;\r\n  \t\t}\r\n\r\n  \t\treturn zoom + zoomOffset;\r\n  \t},\r\n\r\n  \t_getSubdomain: function (tilePoint) {\r\n  \t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n  \t\treturn this.options.subdomains[index];\r\n  \t},\r\n\r\n  \t// stops loading all tiles in the background layer\r\n  \t_abortLoading: function () {\r\n  \t\tvar i, tile;\r\n  \t\tfor (i in this._tiles) {\r\n  \t\t\tif (this._tiles[i].coords.z !== this._tileZoom) {\r\n  \t\t\t\ttile = this._tiles[i].el;\r\n\r\n  \t\t\t\ttile.onload = falseFn;\r\n  \t\t\t\ttile.onerror = falseFn;\r\n\r\n  \t\t\t\tif (!tile.complete) {\r\n  \t\t\t\t\ttile.src = emptyImageUrl;\r\n  \t\t\t\t\tvar coords = this._tiles[i].coords;\r\n  \t\t\t\t\tremove(tile);\r\n  \t\t\t\t\tdelete this._tiles[i];\r\n  \t\t\t\t\t// @event tileabort: TileEvent\r\n  \t\t\t\t\t// Fired when a tile was loading but is now not wanted.\r\n  \t\t\t\t\tthis.fire('tileabort', {\r\n  \t\t\t\t\t\ttile: tile,\r\n  \t\t\t\t\t\tcoords: coords\r\n  \t\t\t\t\t});\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeTile: function (key) {\r\n  \t\tvar tile = this._tiles[key];\r\n  \t\tif (!tile) { return; }\r\n\r\n  \t\t// Cancels any pending http requests associated with the tile\r\n  \t\ttile.el.setAttribute('src', emptyImageUrl);\r\n\r\n  \t\treturn GridLayer.prototype._removeTile.call(this, key);\r\n  \t},\r\n\r\n  \t_tileReady: function (coords, err, tile) {\r\n  \t\tif (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\treturn GridLayer.prototype._tileReady.call(this, coords, err, tile);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\r\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\r\n\r\n  function tileLayer(url, options) {\r\n  \treturn new TileLayer(url, options);\r\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\r\n\r\n  var TileLayerWMS = TileLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer.WMS options\r\n  \t// If any custom options not documented here are used, they will be sent to the\r\n  \t// WMS server as extra parameters in each request URL. This can be useful for\r\n  \t// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\r\n  \tdefaultWmsParams: {\r\n  \t\tservice: 'WMS',\r\n  \t\trequest: 'GetMap',\r\n\r\n  \t\t// @option layers: String = ''\r\n  \t\t// **(required)** Comma-separated list of WMS layers to show.\r\n  \t\tlayers: '',\r\n\r\n  \t\t// @option styles: String = ''\r\n  \t\t// Comma-separated list of WMS styles.\r\n  \t\tstyles: '',\r\n\r\n  \t\t// @option format: String = 'image/jpeg'\r\n  \t\t// WMS image format (use `'image/png'` for layers with transparency).\r\n  \t\tformat: 'image/jpeg',\r\n\r\n  \t\t// @option transparent: Boolean = false\r\n  \t\t// If `true`, the WMS service will return images with transparency.\r\n  \t\ttransparent: false,\r\n\r\n  \t\t// @option version: String = '1.1.1'\r\n  \t\t// Version of the WMS service to use\r\n  \t\tversion: '1.1.1'\r\n  \t},\r\n\r\n  \toptions: {\r\n  \t\t// @option crs: CRS = null\r\n  \t\t// Coordinate Reference System to use for the WMS requests, defaults to\r\n  \t\t// map CRS. Don't change this if you're not sure what it means.\r\n  \t\tcrs: null,\r\n\r\n  \t\t// @option uppercase: Boolean = false\r\n  \t\t// If `true`, WMS request parameter keys will be uppercase.\r\n  \t\tuppercase: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tvar wmsParams = extend({}, this.defaultWmsParams);\r\n\r\n  \t\t// all keys that are not TileLayer options go to WMS params\r\n  \t\tfor (var i in options) {\r\n  \t\t\tif (!(i in this.options)) {\r\n  \t\t\t\twmsParams[i] = options[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\tvar realRetina = options.detectRetina && Browser.retina ? 2 : 1;\r\n  \t\tvar tileSize = this.getTileSize();\r\n  \t\twmsParams.width = tileSize.x * realRetina;\r\n  \t\twmsParams.height = tileSize.y * realRetina;\r\n\r\n  \t\tthis.wmsParams = wmsParams;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n\r\n  \t\tthis._crs = this.options.crs || map.options.crs;\r\n  \t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n  \t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n  \t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n  \t\tTileLayer.prototype.onAdd.call(this, map);\r\n  \t},\r\n\r\n  \tgetTileUrl: function (coords) {\r\n\r\n  \t\tvar tileBounds = this._tileCoordsToNwSe(coords),\r\n  \t\t    crs = this._crs,\r\n  \t\t    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\r\n  \t\t    min = bounds.min,\r\n  \t\t    max = bounds.max,\r\n  \t\t    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?\r\n  \t\t    [min.y, min.x, max.y, max.x] :\r\n  \t\t    [min.x, min.y, max.x, max.y]).join(','),\r\n  \t\t    url = TileLayer.prototype.getTileUrl.call(this, coords);\r\n  \t\treturn url +\r\n  \t\t\tgetParamString(this.wmsParams, url, this.options.uppercase) +\r\n  \t\t\t(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\r\n  \t},\r\n\r\n  \t// @method setParams(params: Object, noRedraw?: Boolean): this\r\n  \t// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\r\n  \tsetParams: function (params, noRedraw) {\r\n\r\n  \t\textend(this.wmsParams, params);\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\r\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\r\n  function tileLayerWMS(url, options) {\r\n  \treturn new TileLayerWMS(url, options);\r\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n\n  \t// @section\n  \t// @aka Renderer options\n  \toptions: {\n  \t\t// @option padding: Number = 0.1\n  \t\t// How much to extend the clip area around the map view (relative to its size)\n  \t\t// e.g. 0.1 would be 10% of map view in each direction\n  \t\tpadding: 0.1\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t\tstamp(this);\n  \t\tthis._layers = this._layers || {};\n  \t},\n\n  \tonAdd: function () {\n  \t\tif (!this._container) {\n  \t\t\tthis._initContainer(); // defined by renderer implementations\n\n  \t\t\tif (this._zoomAnimated) {\n  \t\t\t\taddClass(this._container, 'leaflet-zoom-animated');\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t\tthis._update();\n  \t\tthis.on('update', this._updatePaths, this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis.off('update', this._updatePaths, this);\n  \t\tthis._destroyContainer();\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewreset: this._reset,\n  \t\t\tzoom: this._onZoom,\n  \t\t\tmoveend: this._update,\n  \t\t\tzoomend: this._onZoomEnd\n  \t\t};\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._onAnimZoom;\n  \t\t}\n  \t\treturn events;\n  \t},\n\n  \t_onAnimZoom: function (ev) {\n  \t\tthis._updateTransform(ev.center, ev.zoom);\n  \t},\n\n  \t_onZoom: function () {\n  \t\tthis._updateTransform(this._map.getCenter(), this._map.getZoom());\n  \t},\n\n  \t_updateTransform: function (center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, this._zoom),\n  \t\t    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n  \t\t    currentCenterPoint = this._map.project(this._center, zoom),\n\n  \t\t    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)\n  \t\t\t\t  .subtract(this._map._getNewPixelOrigin(center, zoom));\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(this._container, topLeftOffset, scale);\n  \t\t} else {\n  \t\t\tsetPosition(this._container, topLeftOffset);\n  \t\t}\n  \t},\n\n  \t_reset: function () {\n  \t\tthis._update();\n  \t\tthis._updateTransform(this._center, this._zoom);\n\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._reset();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._project();\n  \t\t}\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._update();\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\t// Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n  \t\t// Subclasses are responsible of firing the 'update' event.\n  \t\tvar p = this.options.padding,\n  \t\t    size = this._map.getSize(),\n  \t\t    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n  \t\tthis._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n\n  \t\tthis._center = this._map.getCenter();\n  \t\tthis._zoom = this._map.getZoom();\n  \t}\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n\n  \t// @section\n  \t// @aka Canvas options\n  \toptions: {\n  \t\t// @option tolerance: Number = 0\n  \t\t// How much to extend the click tolerance around a path/object on the map.\n  \t\ttolerance: 0\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = Renderer.prototype.getEvents.call(this);\n  \t\tevents.viewprereset = this._onViewPreReset;\n  \t\treturn events;\n  \t},\n\n  \t_onViewPreReset: function () {\n  \t\t// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n  \t\tthis._postponeUpdatePaths = true;\n  \t},\n\n  \tonAdd: function () {\n  \t\tRenderer.prototype.onAdd.call(this);\n\n  \t\t// Redraw vectors since canvas is cleared upon removal,\n  \t\t// in case of removing the renderer itself from the map.\n  \t\tthis._draw();\n  \t},\n\n  \t_initContainer: function () {\n  \t\tvar container = this._container = document.createElement('canvas');\n\n  \t\ton(container, 'mousemove', this._onMouseMove, this);\n  \t\ton(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n  \t\ton(container, 'mouseout', this._handleMouseOut, this);\n  \t\tcontainer['_leaflet_disable_events'] = true;\n\n  \t\tthis._ctx = container.getContext('2d');\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tcancelAnimFrame(this._redrawRequest);\n  \t\tdelete this._ctx;\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tif (this._postponeUpdatePaths) { return; }\n\n  \t\tvar layer;\n  \t\tthis._redrawBounds = null;\n  \t\tfor (var id in this._layers) {\n  \t\t\tlayer = this._layers[id];\n  \t\t\tlayer._update();\n  \t\t}\n  \t\tthis._redraw();\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    container = this._container,\n  \t\t    size = b.getSize(),\n  \t\t    m = Browser.retina ? 2 : 1;\n\n  \t\tsetPosition(container, b.min);\n\n  \t\t// set canvas size (also clearing it); use double size on retina\n  \t\tcontainer.width = m * size.x;\n  \t\tcontainer.height = m * size.y;\n  \t\tcontainer.style.width = size.x + 'px';\n  \t\tcontainer.style.height = size.y + 'px';\n\n  \t\tif (Browser.retina) {\n  \t\t\tthis._ctx.scale(2, 2);\n  \t\t}\n\n  \t\t// translate so we use the same path coordinates after canvas element moves\n  \t\tthis._ctx.translate(-b.min.x, -b.min.y);\n\n  \t\t// Tell paths to redraw themselves\n  \t\tthis.fire('update');\n  \t},\n\n  \t_reset: function () {\n  \t\tRenderer.prototype._reset.call(this);\n\n  \t\tif (this._postponeUpdatePaths) {\n  \t\t\tthis._postponeUpdatePaths = false;\n  \t\t\tthis._updatePaths();\n  \t\t}\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n\n  \t\tvar order = layer._order = {\n  \t\t\tlayer: layer,\n  \t\t\tprev: this._drawLast,\n  \t\t\tnext: null\n  \t\t};\n  \t\tif (this._drawLast) { this._drawLast.next = order; }\n  \t\tthis._drawLast = order;\n  \t\tthis._drawFirst = this._drawFirst || this._drawLast;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar order = layer._order;\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\tdelete layer._order;\n\n  \t\tdelete this._layers[stamp(layer)];\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\t// Redraw the union of the layer's old pixel\n  \t\t// bounds and the new pixel bounds.\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t\t// The redraw will extend the redraw bounds\n  \t\t// with the new pixel bounds.\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateDashArray: function (layer) {\n  \t\tif (typeof layer.options.dashArray === 'string') {\n  \t\t\tvar parts = layer.options.dashArray.split(/[, ]+/),\n  \t\t\t    dashArray = [],\n  \t\t\t    dashValue,\n  \t\t\t    i;\n  \t\t\tfor (i = 0; i < parts.length; i++) {\n  \t\t\t\tdashValue = Number(parts[i]);\n  \t\t\t\t// Ignore dash array containing invalid lengths\n  \t\t\t\tif (isNaN(dashValue)) { return; }\n  \t\t\t\tdashArray.push(dashValue);\n  \t\t\t}\n  \t\t\tlayer.options._dashArray = dashArray;\n  \t\t} else {\n  \t\t\tlayer.options._dashArray = layer.options.dashArray;\n  \t\t}\n  \t},\n\n  \t_requestRedraw: function (layer) {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tthis._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n  \t},\n\n  \t_extendRedrawBounds: function (layer) {\n  \t\tif (layer._pxBounds) {\n  \t\t\tvar padding = (layer.options.weight || 0) + 1;\n  \t\t\tthis._redrawBounds = this._redrawBounds || new Bounds();\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n  \t\t}\n  \t},\n\n  \t_redraw: function () {\n  \t\tthis._redrawRequest = null;\n\n  \t\tif (this._redrawBounds) {\n  \t\t\tthis._redrawBounds.min._floor();\n  \t\t\tthis._redrawBounds.max._ceil();\n  \t\t}\n\n  \t\tthis._clear(); // clear layers in redraw bounds\n  \t\tthis._draw(); // draw layers\n\n  \t\tthis._redrawBounds = null;\n  \t},\n\n  \t_clear: function () {\n  \t\tvar bounds = this._redrawBounds;\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t} else {\n  \t\t\tthis._ctx.save();\n  \t\t\tthis._ctx.setTransform(1, 0, 0, 1, 0, 0);\n  \t\t\tthis._ctx.clearRect(0, 0, this._container.width, this._container.height);\n  \t\t\tthis._ctx.restore();\n  \t\t}\n  \t},\n\n  \t_draw: function () {\n  \t\tvar layer, bounds = this._redrawBounds;\n  \t\tthis._ctx.save();\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.beginPath();\n  \t\t\tthis._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t\tthis._ctx.clip();\n  \t\t}\n\n  \t\tthis._drawing = true;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {\n  \t\t\t\tlayer._updatePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._drawing = false;\n\n  \t\tthis._ctx.restore();  // Restore state before clipping.\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tif (!this._drawing) { return; }\n\n  \t\tvar i, j, len2, p,\n  \t\t    parts = layer._parts,\n  \t\t    len = parts.length,\n  \t\t    ctx = this._ctx;\n\n  \t\tif (!len) { return; }\n\n  \t\tctx.beginPath();\n\n  \t\tfor (i = 0; i < len; i++) {\n  \t\t\tfor (j = 0, len2 = parts[i].length; j < len2; j++) {\n  \t\t\t\tp = parts[i][j];\n  \t\t\t\tctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n  \t\t\t}\n  \t\t\tif (closed) {\n  \t\t\t\tctx.closePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n\n  \t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n  \t},\n\n  \t_updateCircle: function (layer) {\n\n  \t\tif (!this._drawing || layer._empty()) { return; }\n\n  \t\tvar p = layer._point,\n  \t\t    ctx = this._ctx,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.save();\n  \t\t\tctx.scale(1, s);\n  \t\t}\n\n  \t\tctx.beginPath();\n  \t\tctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.restore();\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n  \t},\n\n  \t_fillStroke: function (ctx, layer) {\n  \t\tvar options = layer.options;\n\n  \t\tif (options.fill) {\n  \t\t\tctx.globalAlpha = options.fillOpacity;\n  \t\t\tctx.fillStyle = options.fillColor || options.color;\n  \t\t\tctx.fill(options.fillRule || 'evenodd');\n  \t\t}\n\n  \t\tif (options.stroke && options.weight !== 0) {\n  \t\t\tif (ctx.setLineDash) {\n  \t\t\t\tctx.setLineDash(layer.options && layer.options._dashArray || []);\n  \t\t\t}\n  \t\t\tctx.globalAlpha = options.opacity;\n  \t\t\tctx.lineWidth = options.weight;\n  \t\t\tctx.strokeStyle = options.color;\n  \t\t\tctx.lineCap = options.lineCap;\n  \t\t\tctx.lineJoin = options.lineJoin;\n  \t\t\tctx.stroke();\n  \t\t}\n  \t},\n\n  \t// Canvas obviously doesn't have mouse events for individual drawn objects,\n  \t// so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n  \t_onClick: function (e) {\n  \t\tvar point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tif (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n  \t\t\t\t\tclickedLayer = layer;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tthis._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }\n\n  \t\tvar point = this._map.mouseEventToLayerPoint(e);\n  \t\tthis._handleMouseHover(e, point);\n  \t},\n\n\n  \t_handleMouseOut: function (e) {\n  \t\tvar layer = this._hoveredLayer;\n  \t\tif (layer) {\n  \t\t\t// if we're leaving the layer, fire mouseout\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\n  \t\t\tthis._fireEvent([layer], e, 'mouseout');\n  \t\t\tthis._hoveredLayer = null;\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}\n  \t},\n\n  \t_handleMouseHover: function (e, point) {\n  \t\tif (this._mouseHoverThrottled) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar layer, candidateHoveredLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tcandidateHoveredLayer = layer;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (candidateHoveredLayer !== this._hoveredLayer) {\n  \t\t\tthis._handleMouseOut(e);\n\n  \t\t\tif (candidateHoveredLayer) {\n  \t\t\t\taddClass(this._container, 'leaflet-interactive'); // change cursor\n  \t\t\t\tthis._fireEvent([candidateHoveredLayer], e, 'mouseover');\n  \t\t\t\tthis._hoveredLayer = candidateHoveredLayer;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n\n  \t\tthis._mouseHoverThrottled = true;\n  \t\tsetTimeout(bind(function () {\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}, this), 32);\n  \t},\n\n  \t_fireEvent: function (layers, e, type) {\n  \t\tthis._map._fireDOMEvent(e, type || e.type, layers);\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\t// Already last\n  \t\t\treturn;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else if (next) {\n  \t\t\t// Update first entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\torder.prev = this._drawLast;\n  \t\tthis._drawLast.next = order;\n\n  \t\torder.next = null;\n  \t\tthis._drawLast = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\t// Already first\n  \t\t\treturn;\n  \t\t}\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else if (prev) {\n  \t\t\t// Update last entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n\n  \t\torder.prev = null;\n\n  \t\torder.next = this._drawFirst;\n  \t\tthis._drawFirst.prev = order;\n  \t\tthis._drawFirst = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t}\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n  \treturn Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = (function () {\n  \ttry {\n  \t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n  \t\treturn function (name) {\n  \t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n  \t\t};\n  \t} catch (e) {\n  \t\t// Do not return fn from catch block so `e` can be garbage collected\n  \t\t// See https://github.com/Leaflet/Leaflet/pull/7279\n  \t}\n  \treturn function (name) {\n  \t\treturn document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n  \t};\n  })();\n\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n\n  \t_initContainer: function () {\n  \t\tthis._container = create$1('div', 'leaflet-vml-container');\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom) { return; }\n  \t\tRenderer.prototype._update.call(this);\n  \t\tthis.fire('update');\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tvar container = layer._container = vmlCreate('shape');\n\n  \t\taddClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n\n  \t\tcontainer.coordsize = '1 1';\n\n  \t\tlayer._path = vmlCreate('path');\n  \t\tcontainer.appendChild(layer._path);\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tthis._container.appendChild(container);\n\n  \t\tif (layer.options.interactive) {\n  \t\t\tlayer.addInteractiveTarget(container);\n  \t\t}\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tremove(container);\n  \t\tlayer.removeInteractiveTarget(container);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar stroke = layer._stroke,\n  \t\t    fill = layer._fill,\n  \t\t    options = layer.options,\n  \t\t    container = layer._container;\n\n  \t\tcontainer.stroked = !!options.stroke;\n  \t\tcontainer.filled = !!options.fill;\n\n  \t\tif (options.stroke) {\n  \t\t\tif (!stroke) {\n  \t\t\t\tstroke = layer._stroke = vmlCreate('stroke');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(stroke);\n  \t\t\tstroke.weight = options.weight + 'px';\n  \t\t\tstroke.color = options.color;\n  \t\t\tstroke.opacity = options.opacity;\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tstroke.dashStyle = isArray(options.dashArray) ?\n  \t\t\t\t    options.dashArray.join(' ') :\n  \t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n  \t\t\t} else {\n  \t\t\t\tstroke.dashStyle = '';\n  \t\t\t}\n  \t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n  \t\t\tstroke.joinstyle = options.lineJoin;\n\n  \t\t} else if (stroke) {\n  \t\t\tcontainer.removeChild(stroke);\n  \t\t\tlayer._stroke = null;\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tif (!fill) {\n  \t\t\t\tfill = layer._fill = vmlCreate('fill');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(fill);\n  \t\t\tfill.color = options.fillColor || options.color;\n  \t\t\tfill.opacity = options.fillOpacity;\n\n  \t\t} else if (fill) {\n  \t\t\tcontainer.removeChild(fill);\n  \t\t\tlayer._fill = null;\n  \t\t}\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point.round(),\n  \t\t    r = Math.round(layer._radius),\n  \t\t    r2 = Math.round(layer._radiusY || r);\n\n  \t\tthis._setPath(layer, layer._empty() ? 'M0 0' :\n  \t\t\t'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.v = path;\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._container);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._container);\n  \t}\n  };\n\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n\n  \t_initContainer: function () {\n  \t\tthis._container = create('svg');\n\n  \t\t// makes it possible to click through svg root; we'll reset it back in individual paths\n  \t\tthis._container.setAttribute('pointer-events', 'none');\n\n  \t\tthis._rootGroup = create('g');\n  \t\tthis._container.appendChild(this._rootGroup);\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t\tdelete this._rootGroup;\n  \t\tdelete this._svgSize;\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    size = b.getSize(),\n  \t\t    container = this._container;\n\n  \t\t// set size of svg-container if changed\n  \t\tif (!this._svgSize || !this._svgSize.equals(size)) {\n  \t\t\tthis._svgSize = size;\n  \t\t\tcontainer.setAttribute('width', size.x);\n  \t\t\tcontainer.setAttribute('height', size.y);\n  \t\t}\n\n  \t\t// movement: update container viewBox so that we don't have to change coordinates of individual layers\n  \t\tsetPosition(container, b.min);\n  \t\tcontainer.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n\n  \t\tthis.fire('update');\n  \t},\n\n  \t// methods below are called by vector layers implementations\n\n  \t_initPath: function (layer) {\n  \t\tvar path = layer._path = create('path');\n\n  \t\t// @namespace Path\n  \t\t// @option className: String = null\n  \t\t// Custom class name set on an element. Only for SVG renderer.\n  \t\tif (layer.options.className) {\n  \t\t\taddClass(path, layer.options.className);\n  \t\t}\n\n  \t\tif (layer.options.interactive) {\n  \t\t\taddClass(path, 'leaflet-interactive');\n  \t\t}\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tif (!this._rootGroup) { this._initContainer(); }\n  \t\tthis._rootGroup.appendChild(layer._path);\n  \t\tlayer.addInteractiveTarget(layer._path);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tremove(layer._path);\n  \t\tlayer.removeInteractiveTarget(layer._path);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar path = layer._path,\n  \t\t    options = layer.options;\n\n  \t\tif (!path) { return; }\n\n  \t\tif (options.stroke) {\n  \t\t\tpath.setAttribute('stroke', options.color);\n  \t\t\tpath.setAttribute('stroke-opacity', options.opacity);\n  \t\t\tpath.setAttribute('stroke-width', options.weight);\n  \t\t\tpath.setAttribute('stroke-linecap', options.lineCap);\n  \t\t\tpath.setAttribute('stroke-linejoin', options.lineJoin);\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tpath.setAttribute('stroke-dasharray', options.dashArray);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dasharray');\n  \t\t\t}\n\n  \t\t\tif (options.dashOffset) {\n  \t\t\t\tpath.setAttribute('stroke-dashoffset', options.dashOffset);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dashoffset');\n  \t\t\t}\n  \t\t} else {\n  \t\t\tpath.setAttribute('stroke', 'none');\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tpath.setAttribute('fill', options.fillColor || options.color);\n  \t\t\tpath.setAttribute('fill-opacity', options.fillOpacity);\n  \t\t\tpath.setAttribute('fill-rule', options.fillRule || 'evenodd');\n  \t\t} else {\n  \t\t\tpath.setAttribute('fill', 'none');\n  \t\t}\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tthis._setPath(layer, pointsToPath(layer._parts, closed));\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n  \t\t    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n  \t\t// drawing a circle with two half-arcs\n  \t\tvar d = layer._empty() ? 'M0 0' :\n  \t\t\t'M' + (p.x - r) + ',' + p.y +\n  \t\t\tarc + (r * 2) + ',0 ' +\n  \t\t\tarc + (-r * 2) + ',0 ';\n\n  \t\tthis._setPath(layer, d);\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.setAttribute('d', path);\n  \t},\n\n  \t// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._path);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._path);\n  \t}\n  });\n\n  if (Browser.vml) {\n  \tSVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n  \treturn Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n  \t// @namespace Map; @method getRenderer(layer: Path): Renderer\n  \t// Returns the instance of `Renderer` that should be used to render the given\n  \t// `Path`. It will ensure that the `renderer` options of the map and paths\n  \t// are respected, and that the renderers do exist on the map.\n  \tgetRenderer: function (layer) {\n  \t\t// @namespace Path; @option renderer: Renderer\n  \t\t// Use this specific instance of `Renderer` for this path. Takes\n  \t\t// precedence over the map's [default renderer](#map-renderer).\n  \t\tvar renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n  \t\tif (!renderer) {\n  \t\t\trenderer = this._renderer = this._createRenderer();\n  \t\t}\n\n  \t\tif (!this.hasLayer(renderer)) {\n  \t\t\tthis.addLayer(renderer);\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_getPaneRenderer: function (name) {\n  \t\tif (name === 'overlayPane' || name === undefined) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tvar renderer = this._paneRenderers[name];\n  \t\tif (renderer === undefined) {\n  \t\t\trenderer = this._createRenderer({pane: name});\n  \t\t\tthis._paneRenderers[name] = renderer;\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_createRenderer: function (options) {\n  \t\t// @namespace Map; @option preferCanvas: Boolean = false\n  \t\t// Whether `Path`s should be rendered on a `Canvas` renderer.\n  \t\t// By default, all `Path`s are rendered in a `SVG` renderer.\n  \t\treturn (this.options.preferCanvas && canvas(options)) || svg(options);\n  \t}\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n\n  var Rectangle = Polygon.extend({\n  \tinitialize: function (latLngBounds, options) {\n  \t\tPolygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n  \t},\n\n  \t// @method setBounds(latLngBounds: LatLngBounds): this\n  \t// Redraws the rectangle with the passed bounds.\n  \tsetBounds: function (latLngBounds) {\n  \t\treturn this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n  \t},\n\n  \t_boundsToLatLngs: function (latLngBounds) {\n  \t\tlatLngBounds = toLatLngBounds(latLngBounds);\n  \t\treturn [\n  \t\t\tlatLngBounds.getSouthWest(),\n  \t\t\tlatLngBounds.getNorthWest(),\n  \t\t\tlatLngBounds.getNorthEast(),\n  \t\t\tlatLngBounds.getSouthEast()\n  \t\t];\n  \t}\n  });\n\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n  \treturn new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option boxZoom: Boolean = true\n  \t// Whether the map can be zoomed to a rectangular area specified by\n  \t// dragging the mouse while pressing the shift key.\n  \tboxZoom: true\n  });\n\n  var BoxZoom = Handler.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t\tthis._container = map._container;\n  \t\tthis._pane = map._panes.overlayPane;\n  \t\tthis._resetStateTimeout = 0;\n  \t\tmap.on('unload', this._destroy, this);\n  \t},\n\n  \taddHooks: function () {\n  \t\ton(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._moved;\n  \t},\n\n  \t_destroy: function () {\n  \t\tremove(this._pane);\n  \t\tdelete this._pane;\n  \t},\n\n  \t_resetState: function () {\n  \t\tthis._resetStateTimeout = 0;\n  \t\tthis._moved = false;\n  \t},\n\n  \t_clearDeferredResetState: function () {\n  \t\tif (this._resetStateTimeout !== 0) {\n  \t\t\tclearTimeout(this._resetStateTimeout);\n  \t\t\tthis._resetStateTimeout = 0;\n  \t\t}\n  \t},\n\n  \t_onMouseDown: function (e) {\n  \t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n  \t\t// Clear the deferred resetState if it hasn't executed yet, otherwise it\n  \t\t// will interrupt the interaction and orphan a box element in the container.\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetState();\n\n  \t\tdisableTextSelection();\n  \t\tdisableImageDrag();\n\n  \t\tthis._startPoint = this._map.mouseEventToContainerPoint(e);\n\n  \t\ton(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._moved) {\n  \t\t\tthis._moved = true;\n\n  \t\t\tthis._box = create$1('div', 'leaflet-zoom-box', this._container);\n  \t\t\taddClass(this._container, 'leaflet-crosshair');\n\n  \t\t\tthis._map.fire('boxzoomstart');\n  \t\t}\n\n  \t\tthis._point = this._map.mouseEventToContainerPoint(e);\n\n  \t\tvar bounds = new Bounds(this._point, this._startPoint),\n  \t\t    size = bounds.getSize();\n\n  \t\tsetPosition(this._box, bounds.min);\n\n  \t\tthis._box.style.width  = size.x + 'px';\n  \t\tthis._box.style.height = size.y + 'px';\n  \t},\n\n  \t_finish: function () {\n  \t\tif (this._moved) {\n  \t\t\tremove(this._box);\n  \t\t\tremoveClass(this._container, 'leaflet-crosshair');\n  \t\t}\n\n  \t\tenableTextSelection();\n  \t\tenableImageDrag();\n\n  \t\toff(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseUp: function (e) {\n  \t\tif ((e.which !== 1) && (e.button !== 1)) { return; }\n\n  \t\tthis._finish();\n\n  \t\tif (!this._moved) { return; }\n  \t\t// Postpone to next JS tick so internal click event handling\n  \t\t// still see it as \"moved\".\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n\n  \t\tvar bounds = new LatLngBounds(\n  \t\t        this._map.containerPointToLatLng(this._startPoint),\n  \t\t        this._map.containerPointToLatLng(this._point));\n\n  \t\tthis._map\n  \t\t\t.fitBounds(bounds)\n  \t\t\t.fire('boxzoomend', {boxZoomBounds: bounds});\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.keyCode === 27) {\n  \t\t\tthis._finish();\n  \t\t\tthis._clearDeferredResetState();\n  \t\t\tthis._resetState();\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n  \t// @option doubleClickZoom: Boolean|String = true\n  \t// Whether the map can be zoomed in by double clicking on it and\n  \t// zoomed out by double clicking while holding shift. If passed\n  \t// `'center'`, double-click zoom will zoom to the center of the\n  \t//  view regardless of where the mouse was.\n  \tdoubleClickZoom: true\n  });\n\n  var DoubleClickZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\tthis._map.on('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._map.off('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \t_onDoubleClick: function (e) {\n  \t\tvar map = this._map,\n  \t\t    oldZoom = map.getZoom(),\n  \t\t    delta = map.options.zoomDelta,\n  \t\t    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n  \t\tif (map.options.doubleClickZoom === 'center') {\n  \t\t\tmap.setZoom(zoom);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(e.containerPoint, zoom);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option dragging: Boolean = true\n  \t// Whether the map is draggable with mouse/touch or not.\n  \tdragging: true,\n\n  \t// @section Panning Inertia Options\n  \t// @option inertia: Boolean = *\n  \t// If enabled, panning of the map will have an inertia effect where\n  \t// the map builds momentum while dragging and continues moving in\n  \t// the same direction for some time. Feels especially nice on touch\n  \t// devices. Enabled by default.\n  \tinertia: true,\n\n  \t// @option inertiaDeceleration: Number = 3000\n  \t// The rate with which the inertial movement slows down, in pixels/second².\n  \tinertiaDeceleration: 3400, // px/s^2\n\n  \t// @option inertiaMaxSpeed: Number = Infinity\n  \t// Max speed of the inertial movement, in pixels/second.\n  \tinertiaMaxSpeed: Infinity, // px/s\n\n  \t// @option easeLinearity: Number = 0.2\n  \teaseLinearity: 0.2,\n\n  \t// TODO refactor, move to CRS\n  \t// @option worldCopyJump: Boolean = false\n  \t// With this option enabled, the map tracks when you pan to another \"copy\"\n  \t// of the world and seamlessly jumps to the original one so that all overlays\n  \t// like markers and vector layers are still visible.\n  \tworldCopyJump: false,\n\n  \t// @option maxBoundsViscosity: Number = 0.0\n  \t// If `maxBounds` is set, this option will control how solid the bounds\n  \t// are when dragging the map around. The default value of `0.0` allows the\n  \t// user to drag outside the bounds at normal speed, higher values will\n  \t// slow down map dragging outside bounds, and `1.0` makes the bounds fully\n  \t// solid, preventing the user from dragging outside the bounds.\n  \tmaxBoundsViscosity: 0.0\n  });\n\n  var Drag = Handler.extend({\n  \taddHooks: function () {\n  \t\tif (!this._draggable) {\n  \t\t\tvar map = this._map;\n\n  \t\t\tthis._draggable = new Draggable(map._mapPane, map._container);\n\n  \t\t\tthis._draggable.on({\n  \t\t\t\tdragstart: this._onDragStart,\n  \t\t\t\tdrag: this._onDrag,\n  \t\t\t\tdragend: this._onDragEnd\n  \t\t\t}, this);\n\n  \t\t\tthis._draggable.on('predrag', this._onPreDragLimit, this);\n  \t\t\tif (map.options.worldCopyJump) {\n  \t\t\t\tthis._draggable.on('predrag', this._onPreDragWrap, this);\n  \t\t\t\tmap.on('zoomend', this._onZoomEnd, this);\n\n  \t\t\t\tmap.whenReady(this._onZoomEnd, this);\n  \t\t\t}\n  \t\t}\n  \t\taddClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n  \t\tthis._draggable.enable();\n  \t\tthis._positions = [];\n  \t\tthis._times = [];\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-grab');\n  \t\tremoveClass(this._map._container, 'leaflet-touch-drag');\n  \t\tthis._draggable.disable();\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \tmoving: function () {\n  \t\treturn this._draggable && this._draggable._moving;\n  \t},\n\n  \t_onDragStart: function () {\n  \t\tvar map = this._map;\n\n  \t\tmap._stop();\n  \t\tif (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n  \t\t\tvar bounds = toLatLngBounds(this._map.options.maxBounds);\n\n  \t\t\tthis._offsetLimit = toBounds(\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)\n  \t\t\t\t\t.add(this._map.getSize()));\n\n  \t\t\tthis._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n  \t\t} else {\n  \t\t\tthis._offsetLimit = null;\n  \t\t}\n\n  \t\tmap\n  \t\t    .fire('movestart')\n  \t\t    .fire('dragstart');\n\n  \t\tif (map.options.inertia) {\n  \t\t\tthis._positions = [];\n  \t\t\tthis._times = [];\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tif (this._map.options.inertia) {\n  \t\t\tvar time = this._lastTime = +new Date(),\n  \t\t\t    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n  \t\t\tthis._positions.push(pos);\n  \t\t\tthis._times.push(time);\n\n  \t\t\tthis._prunePositions(time);\n  \t\t}\n\n  \t\tthis._map\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_prunePositions: function (time) {\n  \t\twhile (this._positions.length > 1 && time - this._times[0] > 50) {\n  \t\t\tthis._positions.shift();\n  \t\t\tthis._times.shift();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tvar pxCenter = this._map.getSize().divideBy(2),\n  \t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n  \t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n  \t\tthis._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n  \t},\n\n  \t_viscousLimit: function (value, threshold) {\n  \t\treturn value - (value - threshold) * this._viscosity;\n  \t},\n\n  \t_onPreDragLimit: function () {\n  \t\tif (!this._viscosity || !this._offsetLimit) { return; }\n\n  \t\tvar offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n  \t\tvar limit = this._offsetLimit;\n  \t\tif (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }\n  \t\tif (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }\n  \t\tif (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }\n  \t\tif (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }\n\n  \t\tthis._draggable._newPos = this._draggable._startPos.add(offset);\n  \t},\n\n  \t_onPreDragWrap: function () {\n  \t\t// TODO refactor to be able to adjust map pane position after zoom\n  \t\tvar worldWidth = this._worldWidth,\n  \t\t    halfWidth = Math.round(worldWidth / 2),\n  \t\t    dx = this._initialWorldOffset,\n  \t\t    x = this._draggable._newPos.x,\n  \t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n  \t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n  \t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n  \t\tthis._draggable._absPos = this._draggable._newPos.clone();\n  \t\tthis._draggable._newPos.x = newX;\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\tvar map = this._map,\n  \t\t    options = map.options,\n\n  \t\t    noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n\n  \t\tmap.fire('dragend', e);\n\n  \t\tif (noInertia) {\n  \t\t\tmap.fire('moveend');\n\n  \t\t} else {\n  \t\t\tthis._prunePositions(+new Date());\n\n  \t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n  \t\t\t    duration = (this._lastTime - this._times[0]) / 1000,\n  \t\t\t    ease = options.easeLinearity,\n\n  \t\t\t    speedVector = direction.multiplyBy(ease / duration),\n  \t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n  \t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n  \t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n  \t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n  \t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n  \t\t\tif (!offset.x && !offset.y) {\n  \t\t\t\tmap.fire('moveend');\n\n  \t\t\t} else {\n  \t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n  \t\t\t\trequestAnimFrame(function () {\n  \t\t\t\t\tmap.panBy(offset, {\n  \t\t\t\t\t\tduration: decelerationDuration,\n  \t\t\t\t\t\teaseLinearity: ease,\n  \t\t\t\t\t\tnoMoveStart: true,\n  \t\t\t\t\t\tanimate: true\n  \t\t\t\t\t});\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n  \t// @option keyboard: Boolean = true\n  \t// Makes the map focusable and allows users to navigate the map with keyboard\n  \t// arrows and `+`/`-` keys.\n  \tkeyboard: true,\n\n  \t// @option keyboardPanDelta: Number = 80\n  \t// Amount of pixels to pan when pressing an arrow key.\n  \tkeyboardPanDelta: 80\n  });\n\n  var Keyboard = Handler.extend({\n\n  \tkeyCodes: {\n  \t\tleft:    [37],\n  \t\tright:   [39],\n  \t\tdown:    [40],\n  \t\tup:      [38],\n  \t\tzoomIn:  [187, 107, 61, 171],\n  \t\tzoomOut: [189, 109, 54, 173]\n  \t},\n\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n\n  \t\tthis._setPanDelta(map.options.keyboardPanDelta);\n  \t\tthis._setZoomDelta(map.options.zoomDelta);\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar container = this._map._container;\n\n  \t\t// make the container focusable by tabbing\n  \t\tif (container.tabIndex <= 0) {\n  \t\t\tcontainer.tabIndex = '0';\n  \t\t}\n\n  \t\ton(container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.on({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._removeHooks();\n\n  \t\toff(this._map._container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.off({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \t_onMouseDown: function () {\n  \t\tif (this._focused) { return; }\n\n  \t\tvar body = document.body,\n  \t\t    docEl = document.documentElement,\n  \t\t    top = body.scrollTop || docEl.scrollTop,\n  \t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n  \t\tthis._map._container.focus();\n\n  \t\twindow.scrollTo(left, top);\n  \t},\n\n  \t_onFocus: function () {\n  \t\tthis._focused = true;\n  \t\tthis._map.fire('focus');\n  \t},\n\n  \t_onBlur: function () {\n  \t\tthis._focused = false;\n  \t\tthis._map.fire('blur');\n  \t},\n\n  \t_setPanDelta: function (panDelta) {\n  \t\tvar keys = this._panKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n  \t\t\tkeys[codes.left[i]] = [-1 * panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n  \t\t\tkeys[codes.right[i]] = [panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n  \t\t\tkeys[codes.down[i]] = [0, panDelta];\n  \t\t}\n  \t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n  \t\t\tkeys[codes.up[i]] = [0, -1 * panDelta];\n  \t\t}\n  \t},\n\n  \t_setZoomDelta: function (zoomDelta) {\n  \t\tvar keys = this._zoomKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomIn[i]] = zoomDelta;\n  \t\t}\n  \t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomOut[i]] = -zoomDelta;\n  \t\t}\n  \t},\n\n  \t_addHooks: function () {\n  \t\ton(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_removeHooks: function () {\n  \t\toff(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.altKey || e.ctrlKey || e.metaKey) { return; }\n\n  \t\tvar key = e.keyCode,\n  \t\t    map = this._map,\n  \t\t    offset;\n\n  \t\tif (key in this._panKeys) {\n  \t\t\tif (!map._panAnim || !map._panAnim._inProgress) {\n  \t\t\t\toffset = this._panKeys[key];\n  \t\t\t\tif (e.shiftKey) {\n  \t\t\t\t\toffset = toPoint(offset).multiplyBy(3);\n  \t\t\t\t}\n\n  \t\t\t\tmap.panBy(offset);\n\n  \t\t\t\tif (map.options.maxBounds) {\n  \t\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (key in this._zoomKeys) {\n  \t\t\tmap.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n\n  \t\t} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n  \t\t\tmap.closePopup();\n\n  \t\t} else {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tstop(e);\n  \t}\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Mouse wheel options\n  \t// @option scrollWheelZoom: Boolean|String = true\n  \t// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n  \t// it will zoom to the center of the view regardless of where the mouse was.\n  \tscrollWheelZoom: true,\n\n  \t// @option wheelDebounceTime: Number = 40\n  \t// Limits the rate at which a wheel can fire (in milliseconds). By default\n  \t// user can't zoom via wheel more often than once per 40 ms.\n  \twheelDebounceTime: 40,\n\n  \t// @option wheelPxPerZoomLevel: Number = 60\n  \t// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n  \t// mean a change of one full zoom level. Smaller values will make wheel-zooming\n  \t// faster (and vice versa).\n  \twheelPxPerZoomLevel: 60\n  });\n\n  var ScrollWheelZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'wheel', this._onWheelScroll, this);\n\n  \t\tthis._delta = 0;\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'wheel', this._onWheelScroll, this);\n  \t},\n\n  \t_onWheelScroll: function (e) {\n  \t\tvar delta = getWheelDelta(e);\n\n  \t\tvar debounce = this._map.options.wheelDebounceTime;\n\n  \t\tthis._delta += delta;\n  \t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n  \t\tif (!this._startTime) {\n  \t\t\tthis._startTime = +new Date();\n  \t\t}\n\n  \t\tvar left = Math.max(debounce - (+new Date() - this._startTime), 0);\n\n  \t\tclearTimeout(this._timer);\n  \t\tthis._timer = setTimeout(bind(this._performZoom, this), left);\n\n  \t\tstop(e);\n  \t},\n\n  \t_performZoom: function () {\n  \t\tvar map = this._map,\n  \t\t    zoom = map.getZoom(),\n  \t\t    snap = this._map.options.zoomSnap || 0;\n\n  \t\tmap._stop(); // stop panning and fly animations if any\n\n  \t\t// map the delta with a sigmoid function to -4..4 range leaning on -1..1\n  \t\tvar d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n  \t\t    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n  \t\t    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n  \t\t    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n\n  \t\tthis._delta = 0;\n  \t\tthis._startTime = null;\n\n  \t\tif (!delta) { return; }\n\n  \t\tif (map.options.scrollWheelZoom === 'center') {\n  \t\t\tmap.setZoom(zoom + delta);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option tapHold: Boolean\n  \t// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n  \ttapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n\n  \t// @option tapTolerance: Number = 15\n  \t// The max number of pixels a user can shift his finger during touch\n  \t// for it to be considered a valid tap.\n  \ttapTolerance: 15\n  });\n\n  var TapHold = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \t_onDown: function (e) {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\tif (e.touches.length !== 1) { return; }\n\n  \t\tvar first = e.touches[0];\n  \t\tthis._startPos = this._newPos = new Point(first.clientX, first.clientY);\n\n  \t\tthis._holdTimeout = setTimeout(bind(function () {\n  \t\t\tthis._cancel();\n  \t\t\tif (!this._isTapValid()) { return; }\n\n  \t\t\t// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n  \t\t\ton(document, 'touchend', preventDefault);\n  \t\t\ton(document, 'touchend touchcancel', this._cancelClickPrevent);\n  \t\t\tthis._simulateEvent('contextmenu', first);\n  \t\t}, this), tapHoldDelay);\n\n  \t\ton(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\ton(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_cancelClickPrevent: function cancelClickPrevent() {\n  \t\toff(document, 'touchend', preventDefault);\n  \t\toff(document, 'touchend touchcancel', cancelClickPrevent);\n  \t},\n\n  \t_cancel: function () {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\toff(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\toff(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_onMove: function (e) {\n  \t\tvar first = e.touches[0];\n  \t\tthis._newPos = new Point(first.clientX, first.clientY);\n  \t},\n\n  \t_isTapValid: function () {\n  \t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n  \t},\n\n  \t_simulateEvent: function (type, e) {\n  \t\tvar simulatedEvent = new MouseEvent(type, {\n  \t\t\tbubbles: true,\n  \t\t\tcancelable: true,\n  \t\t\tview: window,\n  \t\t\t// detail: 1,\n  \t\t\tscreenX: e.screenX,\n  \t\t\tscreenY: e.screenY,\n  \t\t\tclientX: e.clientX,\n  \t\t\tclientY: e.clientY,\n  \t\t\t// button: 2,\n  \t\t\t// buttons: 2\n  \t\t});\n\n  \t\tsimulatedEvent._simulated = true;\n\n  \t\te.target.dispatchEvent(simulatedEvent);\n  \t}\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option touchZoom: Boolean|String = *\n  \t// Whether the map can be zoomed by touch-dragging with two fingers. If\n  \t// passed `'center'`, it will zoom to the center of the view regardless of\n  \t// where the touch events (fingers) were. Enabled for touch-capable web\n  \t// browsers.\n  \ttouchZoom: Browser.touch,\n\n  \t// @option bounceAtZoomLimits: Boolean = true\n  \t// Set it to false if you don't want the map to zoom beyond min/max zoom\n  \t// and then bounce back when pinch-zooming.\n  \tbounceAtZoomLimits: true\n  });\n\n  var TouchZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\taddClass(this._map._container, 'leaflet-touch-zoom');\n  \t\ton(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-touch-zoom');\n  \t\toff(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \t_onTouchStart: function (e) {\n  \t\tvar map = this._map;\n  \t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n  \t\tvar p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]);\n\n  \t\tthis._centerPoint = map.getSize()._divideBy(2);\n  \t\tthis._startLatLng = map.containerPointToLatLng(this._centerPoint);\n  \t\tif (map.options.touchZoom !== 'center') {\n  \t\t\tthis._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n  \t\t}\n\n  \t\tthis._startDist = p1.distanceTo(p2);\n  \t\tthis._startZoom = map.getZoom();\n\n  \t\tthis._moved = false;\n  \t\tthis._zooming = true;\n\n  \t\tmap._stop();\n\n  \t\ton(document, 'touchmove', this._onTouchMove, this);\n  \t\ton(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchMove: function (e) {\n  \t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n  \t\tvar map = this._map,\n  \t\t    p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]),\n  \t\t    scale = p1.distanceTo(p2) / this._startDist;\n\n  \t\tthis._zoom = map.getScaleZoom(scale, this._startZoom);\n\n  \t\tif (!map.options.bounceAtZoomLimits && (\n  \t\t\t(this._zoom < map.getMinZoom() && scale < 1) ||\n  \t\t\t(this._zoom > map.getMaxZoom() && scale > 1))) {\n  \t\t\tthis._zoom = map._limitZoom(this._zoom);\n  \t\t}\n\n  \t\tif (map.options.touchZoom === 'center') {\n  \t\t\tthis._center = this._startLatLng;\n  \t\t\tif (scale === 1) { return; }\n  \t\t} else {\n  \t\t\t// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n  \t\t\tvar delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n  \t\t\tif (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n  \t\t\tthis._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n  \t\t}\n\n  \t\tif (!this._moved) {\n  \t\t\tmap._moveStart(true, false);\n  \t\t\tthis._moved = true;\n  \t\t}\n\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\tvar moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});\n  \t\tthis._animRequest = requestAnimFrame(moveFn, this, true);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchEnd: function () {\n  \t\tif (!this._moved || !this._zooming) {\n  \t\t\tthis._zooming = false;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._zooming = false;\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\toff(document, 'touchmove', this._onTouchMove, this);\n  \t\toff(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\t// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n  \t\tif (this._map.options.zoomAnimation) {\n  \t\t\tthis._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n  \t\t} else {\n  \t\t\tthis._map._resetView(this._center, this._map._limitZoom(this._zoom));\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n\n  var oldL = window.L;\n  exports.noConflict = function() {\n  \twindow.L = oldL;\n  \treturn this;\n  }\n  // Always export us to window global (see #2364)\n  window.L = exports;\n\n}));\n//# sourceMappingURL=leaflet-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3dHO0FBQzFHLENBQUMsOEJBQThCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQSxnRkFBZ0YsRUFBRSxHQUFHLEVBQUU7QUFDdkYsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUNBQXVDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7O0FBRUgscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1Qzs7QUFFQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEUsaUNBQWlDLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUNBQXVDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUNBQXVDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ04seUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNGQUFzRixnQkFBZ0I7QUFDdEc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQsNEJBQTRCLHFEQUFxRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDZDQUE2QyxhQUFhO0FBQzFELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsc0JBQXNCLElBQUk7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEcsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQTJDO0FBQ3pFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekUsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQixnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFVBQVU7QUFDekQ7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEIsb0NBQW9DOztBQUVwQyw4QkFBOEIsYUFBYTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSixzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEOztBQUVBLHVDQUF1QyxjQUFjO0FBQ3JEOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EOztBQUVBLG1EQUFtRCxVQUFVO0FBQzdELGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEIsbUNBQW1DOztBQUVuQzs7QUFFQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EOztBQUVBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLGdDQUFnQzs7QUFFaEMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EOztBQUVwRCxpREFBaUQsU0FBUzs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCLGVBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsZ0NBQWdDO0FBQ2hDLHdDQUF3QyxVQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsNkJBQTZCOztBQUU1RTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLHlCQUF5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxJQUFJLElBQUksaUNBQWlDLGtGQUFrRjtBQUNqTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRTtBQUN0RDtBQUNBO0FBQ0EsT0FBTyxFQUFFLHlIQUF5SCwyQ0FBMkMsK0NBQStDLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLHdCQUF3QixFQUFFLDhCQUE4QjtBQUNwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLGlCQUFpQixJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0MsMkNBQTJDLHVCQUF1QjtBQUNsRSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLGtCQUFrQjs7QUFFbEI7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLElBQUk7O0FBRUo7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekIseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDLDJDQUEyQyx1QkFBdUI7QUFDbEUsc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDOztBQUVsQztBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixNQUFNO0FBQ047QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFpRSwwQkFBMEI7QUFDM0Y7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzP2FmNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuOC4wLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHBzOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAyMiBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5sZWFmbGV0ID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjEuOC4wXCI7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG4gIFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuICBcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gIFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcbiAgXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuICBcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZGVzdDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG4gIHZhciBjcmVhdGUkMiA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuICBcdGZ1bmN0aW9uIEYoKSB7fVxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG4gIFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuICBcdH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuICAvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG4gIFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICBcdGlmIChmbi5iaW5kKSB7XHJcbiAgXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbiAgLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuICB2YXIgbGFzdElkID0gMDtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbiAgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcbiAgXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuICBcdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4gIC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4gIC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbiAgLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4gIC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuICAvLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcbiAgXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuICBcdFx0bG9jayA9IGZhbHNlO1xyXG4gIFx0XHRpZiAoYXJncykge1xyXG4gIFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICBcdFx0XHRhcmdzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobG9jaykge1xyXG4gIFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG4gIFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuICBcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gIFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG4gIFx0XHRcdGxvY2sgPSB0cnVlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiB3cmFwcGVyRm47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbiAgLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4gIC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gIGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuICBcdHZhciBtYXggPSByYW5nZVsxXSxcclxuICBcdCAgICBtaW4gPSByYW5nZVswXSxcclxuICBcdCAgICBkID0gbWF4IC0gbWluO1xyXG4gIFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuICBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbiAgLy8gVGhlIGRlZmF1bHQgYHByZWNpc2lvbmAgdmFsdWUgaXMgNiBkZWNpbWFsIHBsYWNlcy5cclxuICAvLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuICBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBwcmVjaXNpb24pIHtcclxuICBcdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuICBcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuICBcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuICAvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbiAgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuICBcdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuICBcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG4gIFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlJDIob2JqLm9wdGlvbnMpIDoge307XHJcbiAgXHR9XHJcbiAgXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4gIC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuICAvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbiAgLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuICAvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcbiAgXHR2YXIgcGFyYW1zID0gW107XHJcbiAgXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG4gIFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuICB9XHJcblxyXG4gIHZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4gIC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4gIC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbiAgLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbiAgLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbiAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcbiAgXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHZhbHVlO1xyXG4gIFx0fSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbiAgLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbiAgLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbiAgLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG4gIHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuICAvLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG4gIFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbiAgfVxyXG5cclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuICAvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbiAgZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcbiAgXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG4gIFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcbiAgXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gIFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuICB9XHJcblxyXG4gIHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbiAgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcbiAgXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuICAvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4gIC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuICAvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbiAgLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcbiAgXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcbiAgXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuICAvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuICBcdGlmIChpZCkge1xyXG4gIFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG4gIFx0fVxyXG4gIH1cblxuICB2YXIgVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBiaW5kOiBiaW5kLFxuICAgIGdldCBsYXN0SWQgKCkgeyByZXR1cm4gbGFzdElkOyB9LFxuICAgIHN0YW1wOiBzdGFtcCxcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgd3JhcE51bTogd3JhcE51bSxcbiAgICBmYWxzZUZuOiBmYWxzZUZuLFxuICAgIGZvcm1hdE51bTogZm9ybWF0TnVtLFxuICAgIHRyaW06IHRyaW0sXG4gICAgc3BsaXRXb3Jkczogc3BsaXRXb3JkcyxcbiAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuICAgIGdldFBhcmFtU3RyaW5nOiBnZXRQYXJhbVN0cmluZyxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG4gICAgcmVxdWVzdEZuOiByZXF1ZXN0Rm4sXG4gICAgY2FuY2VsRm46IGNhbmNlbEZuLFxuICAgIHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG4gICAgY2FuY2VsQW5pbUZyYW1lOiBjYW5jZWxBbmltRnJhbWVcbiAgfTtcblxuICAvLyBAY2xhc3MgQ2xhc3NcclxuICAvLyBAYWthIEwuQ2xhc3NcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuICAvLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbiAgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcbiAgXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIFx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuICBcdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcyk7XHJcblxyXG4gIFx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG4gIFx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcbiAgXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcbiAgXHR2YXIgcHJvdG8gPSBjcmVhdGUkMihwYXJlbnRQcm90byk7XHJcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuICBcdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuICBcdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG4gIFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcbiAgXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuICBcdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuICBcdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcbiAgXHRcdGV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcbiAgXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuICBcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuICBcdGRlbGV0ZSBwcm90by5zdGF0aWNzO1xyXG4gIFx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuICBcdC8vIG1lcmdlIG9wdGlvbnNcclxuICBcdGlmIChwcm90by5vcHRpb25zKSB7XHJcbiAgXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gY3JlYXRlJDIocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuICBcdFx0ZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG5cclxuICBcdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcbiAgXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG4gIFx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG4gIFx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiBOZXdDbGFzcztcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbiAgQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gIFx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbiAgXHRpZiAocHJvcHMub3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuICBcdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuICBDbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuICAvLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG4gIENsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuICBcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICBcdH07XHJcblxyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcbiAgXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG4gIFx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcbiAgXHRpbmNsdWRlcyA9IGlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuICBcdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG4gIFx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEV2ZW50ZWRcclxuICAgKiBAYWthIEwuRXZlbnRlZFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICAgKiB9ICk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAgICpcclxuICAgKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEV2ZW50cyA9IHtcclxuICBcdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbiAgXHQgKi9cclxuICBcdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcbiAgXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcbiAgXHQgKi9cclxuICBcdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChyZW1vdmVBbGwpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG4gIFx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcbiAgXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG4gIFx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG4gIFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuICBcdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuICBcdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG4gIFx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcbiAgXHRcdFx0XHRyZXR1cm47XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHR2YXIgbGlzdGVuZXJzLFxyXG4gIFx0XHQgICAgaSxcclxuICBcdFx0ICAgIGxlbjtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuICBcdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIHJlbW92ZSBhbGxcclxuICBcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcFxyXG4gIFx0XHRcdFx0Ly8gc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcbiAgXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gZmFsc2VGbjtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcbiAgXHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcbiAgXHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0XHRsLmZuID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcbiAgXHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHJcbiAgXHRcdFx0XHRyZXR1cm47XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGNvbnNvbGUud2FybignbGlzdGVuZXIgbm90IGZvdW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG4gIFx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuICBcdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcbiAgXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBldmVudCA9IGV4dGVuZCh7fSwgZGF0YSwge1xyXG4gIFx0XHRcdHR5cGU6IHR5cGUsXHJcbiAgXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG4gIFx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuICBcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcbiAgXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcbiAgXHRcdFx0XHR9XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG4gIFx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuICBcdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ1wic3RyaW5nXCIgdHlwZSBhcmd1bWVudCBleHBlY3RlZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG4gIFx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcbiAgXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGhhbmRsZXIgPSBiaW5kKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHR0aGlzXHJcbiAgXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG4gIFx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcbiAgXHRcdHJldHVybiB0aGlzXHJcbiAgXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG4gIFx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBleHRlbmQoe1xyXG4gIFx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG4gIFx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcbiAgXHRcdFx0fSwgZSksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuICBFdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbiAgLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuICAvLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbiAgRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuICBFdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuICBFdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4gIC8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4gIC8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuICBFdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbiAgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb2ludFxyXG4gICAqIEBha2EgTC5Qb2ludFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gICAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG4gIFx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG4gIFx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxuICB9O1xyXG5cclxuICBQb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcbiAgXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG4gIFx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54IC89IG51bTtcclxuICBcdFx0dGhpcy55IC89IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggKj0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgKj0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcbiAgXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG4gIFx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuICBcdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuICBcdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuICBcdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG4gIFx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG4gIFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG4gIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcbiAgXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuICBcdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG4gIFx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG4gIFx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuICBcdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICdQb2ludCgnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuICAvLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuICAvLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG4gIGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheSh4KSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBCb3VuZHNcclxuICAgKiBAYWthIEwuQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICAgKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICAgKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgQm91bmRzLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuICBcdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcbiAgXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuICBcdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuICBcdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcbiAgXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuICBcdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcbiAgXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG4gIFx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuICBcdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRcdG1pbiA9IG9iai5taW47XHJcbiAgXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuICBcdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuICBcdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuICBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICAgKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAgICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAgICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLmZpdEJvdW5kcyhbXHJcbiAgICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICAgKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAgICogXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcbiAgXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqO1xyXG4gIFx0XHRcdG5lMiA9IG9iajtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcbiAgXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG4gIFx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG4gIFx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcbiAgXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG4gIFx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcbiAgXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuICBcdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG4gIFx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcbiAgXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG4gIFx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG4gIFx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcbiAgXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKiBAY2xhc3MgTGF0TG5nXHJcbiAgICogQGFrYSBMLkxhdExuZ1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAgICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAgICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAgICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcbiAgXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG4gIFx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG4gIFx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubG5nID0gK2xuZztcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuICBcdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcbiAgXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dGhpcy5hbHQgPSArYWx0O1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuICBcdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gIFx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG4gIFx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuICBcdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcbiAgXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkJhc2VcclxuICAgKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICAgKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gICAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAgICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BhdGlhbF9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAgICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gICAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ1JTID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuICBcdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuICBcdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAgXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuICBcdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG4gIFx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuICBcdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcbiAgXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gIFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcbiAgXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuICBcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG4gIFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcbiAgXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG4gIFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcbiAgXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuICBcdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcbiAgXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG4gIFx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuICBcdGluZmluaXRlOiBmYWxzZSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcbiAgXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyB3cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG4gIFx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuICBcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuICBcdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcbiAgXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuICBcdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcbiAgXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuICBcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cbiAgdmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuICBcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG4gIFx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcbiAgXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuICBcdFI6IDYzNzEwMDAsXG5cbiAgXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG4gIFx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuICBcdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG4gIFx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuICBcdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICBcdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gICAqXHJcbiAgICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICAgKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAgICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbiAgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuICBcdFI6IGVhcnRoUmFkaXVzLFxyXG4gIFx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcbiAgXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuICBcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuICBcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuICBcdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG4gIFx0fSkoKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICAgKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAgICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gICAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAgICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICAgKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gICAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuICAvLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdGlmIChpc0FycmF5KGEpKSB7XHJcbiAgXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcbiAgXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG4gIFx0XHR0aGlzLl9iID0gYVsxXTtcclxuICBcdFx0dGhpcy5fYyA9IGFbMl07XHJcbiAgXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG4gIFx0XHRyZXR1cm47XHJcbiAgXHR9XHJcbiAgXHR0aGlzLl9hID0gYTtcclxuICBcdHRoaXMuX2IgPSBiO1xyXG4gIFx0dGhpcy5fYyA9IGM7XHJcbiAgXHR0aGlzLl9kID0gZDtcclxuICB9XHJcblxyXG4gIFRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcbiAgXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcbiAgXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG4gIFx0XHRyZXR1cm4gcG9pbnQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcbiAgXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG4gIFx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbiAgLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuICAvLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuICBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAgICpcclxuICAgKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICAgKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICAgKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHMzg1NyA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG4gIFx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG4gIFx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcbiAgXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuICBcdH0oKSlcclxuICB9KTtcclxuXHJcbiAgdmFyIEVQU0c5MDA5MTMgPSBleHRlbmQoe30sIEVQU0czODU3LCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4gIC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuICAvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG4gIGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG4gIFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbiAgfVxuXG4gIC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuICAvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4gIC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbiAgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcbiAgXHR2YXIgc3RyID0gJycsXG4gIFx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cbiAgXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdHAgPSBwb2ludHNbal07XG4gIFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcbiAgXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3NcbiAgXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAgICogQGFrYSBMLkJyb3dzZXJcclxuICAgKlxyXG4gICAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAgICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuICB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbiAgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG4gIHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbiAgLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbiAgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuICAvLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbiAgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbiAgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4gIC8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxuICB2YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG4gIHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxuICB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuICB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG4gIHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbiAgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbiAgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG4gIHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG4gIHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG4gIHZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4gIC8vICoqVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuKiogdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4gIC8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuICAvLyB0b3VjaCBldmVudHMuXHJcbiAgdmFyIHRvdWNoTmF0aXZlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8ICEhd2luZG93LlRvdWNoRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbiAgLy8gTm90ZTogcG9pbnRlciBldmVudHMgd2lsbCBiZSBwcmVmZXJyZWQgKGlmIGF2YWlsYWJsZSksIGFuZCBwcm9jZXNzZWQgZm9yIGFsbCBgdG91Y2gqYCBsaXN0ZW5lcnMuXHJcbiAgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuICB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG4gIHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcbiAgXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcbiAgXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuICBcdH1cclxuICBcdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbiAgdmFyIGNhbnZhcyQxID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbiAgdmFyIHN2ZyQxID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4gIHZhciBpbmxpbmVTdmcgPSAhIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcbiAgXHRyZXR1cm4gKGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuICB2YXIgdm1sID0gIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuICBcdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcbiAgXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG4gIFx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxuICB9XHJcblxyXG5cclxuICB2YXIgQnJvd3NlciA9IHtcclxuICBcdGllOiBpZSxcclxuICBcdGllbHQ5OiBpZWx0OSxcclxuICBcdGVkZ2U6IGVkZ2UsXHJcbiAgXHR3ZWJraXQ6IHdlYmtpdCxcclxuICBcdGFuZHJvaWQ6IGFuZHJvaWQsXHJcbiAgXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuICBcdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG4gIFx0b3BlcmE6IG9wZXJhLFxyXG4gIFx0Y2hyb21lOiBjaHJvbWUsXHJcbiAgXHRnZWNrbzogZ2Vja28sXHJcbiAgXHRzYWZhcmk6IHNhZmFyaSxcclxuICBcdHBoYW50b206IHBoYW50b20sXHJcbiAgXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG4gIFx0d2luOiB3aW4sXHJcbiAgXHRpZTNkOiBpZTNkLFxyXG4gIFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG4gIFx0Z2Vja28zZDogZ2Vja28zZCxcclxuICBcdGFueTNkOiBhbnkzZCxcclxuICBcdG1vYmlsZTogbW9iaWxlLFxyXG4gIFx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcbiAgXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXHJcbiAgXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuICBcdHBvaW50ZXI6IHBvaW50ZXIsXHJcbiAgXHR0b3VjaDogdG91Y2gsXHJcbiAgXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcbiAgXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcbiAgXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXHJcbiAgXHRyZXRpbmE6IHJldGluYSxcclxuICBcdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcbiAgXHRjYW52YXM6IGNhbnZhcyQxLFxyXG4gIFx0c3ZnOiBzdmckMSxcclxuICBcdHZtbDogdm1sLFxyXG4gIFx0aW5saW5lU3ZnOiBpbmxpbmVTdmdcclxuICB9O1xuXG4gIC8qXG4gICAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gICAqL1xuXG4gIHZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbiAgdmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xuICB2YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xuICB2YXIgcEV2ZW50ID0ge1xuICBcdHRvdWNoc3RhcnQgIDogUE9JTlRFUl9ET1dOLFxuICBcdHRvdWNobW92ZSAgIDogUE9JTlRFUl9NT1ZFLFxuICBcdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcbiAgXHR0b3VjaGNhbmNlbCA6IFBPSU5URVJfQ0FOQ0VMXG4gIH07XG4gIHZhciBoYW5kbGUgPSB7XG4gIFx0dG91Y2hzdGFydCAgOiBfb25Qb2ludGVyU3RhcnQsXG4gIFx0dG91Y2htb3ZlICAgOiBfaGFuZGxlUG9pbnRlcixcbiAgXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuICBcdHRvdWNoY2FuY2VsIDogX2hhbmRsZVBvaW50ZXJcbiAgfTtcbiAgdmFyIF9wb2ludGVycyA9IHt9O1xuICB2YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4gIC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbiAgLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbiAgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuICBcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgXHRcdF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKTtcbiAgXHR9XG4gIFx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuIEwuVXRpbC5mYWxzZUZuO1xuICBcdH1cbiAgXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIFx0cmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG4gIFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuICBcdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG4gIFx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcbiAgXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG4gIFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG4gIFx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG4gIFx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG4gIFx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG4gIFx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG4gIFx0ZS50b3VjaGVzID0gW107XG4gIFx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcbiAgXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG4gIFx0fVxuICBcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cbiAgXHRoYW5kbGVyKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcbiAgXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcbiAgXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9XG4gIFx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG4gIH1cblxuICAvKlxyXG4gICAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICAgKlxyXG4gICAqIE5vdGU6IGN1cnJlbnRseSBtb3N0IGJyb3dzZXJzIGZpcmUgbmF0aXZlIGRibGNsaWNrLCB3aXRoIG9ubHkgYSBmZXcgZXhjZXB0aW9uc1xyXG4gICAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBtYWtlRGJsY2xpY2soZXZlbnQpIHtcclxuICBcdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG4gIFx0dmFyIG5ld0V2ZW50ID0ge30sXHJcbiAgXHQgICAgcHJvcCwgaTtcclxuICBcdGZvciAoaSBpbiBldmVudCkge1xyXG4gIFx0XHRwcm9wID0gZXZlbnRbaV07XHJcbiAgXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuICBcdH1cclxuICBcdGV2ZW50ID0gbmV3RXZlbnQ7XHJcbiAgXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuICBcdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcbiAgXHRuZXdFdmVudC5pc1RydXN0ZWQgPSBmYWxzZTtcclxuICBcdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuICBcdHJldHVybiBuZXdFdmVudDtcclxuICB9XHJcblxyXG4gIHZhciBkZWxheSA9IDIwMDtcclxuICBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpIHtcclxuICBcdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuICBcdC8vIE9uIHNvbWUgcGxhdGZvcm1zIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSBuYXRpdmUgZGJsY2xpY2tzIGZvciB0b3VjaCBldmVudHMuXHJcbiAgXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuICBcdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcbiAgXHR2YXIgbGFzdCA9IDAsXHJcbiAgXHQgICAgZGV0YWlsO1xyXG4gIFx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG4gIFx0XHRpZiAoZS5kZXRhaWwgIT09IDEpIHtcclxuICBcdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcbiAgXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG4gIFx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG4gIFx0XHRcdGRldGFpbCsrO1xyXG4gIFx0XHRcdGlmIChkZXRhaWwgPT09IDIpIHtcclxuICBcdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZGV0YWlsID0gMTtcclxuICBcdFx0fVxyXG4gIFx0XHRsYXN0ID0gbm93O1xyXG4gIFx0fVxyXG5cclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbURibGNsaWNrKTtcclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHRkYmxjbGljazogaGFuZGxlcixcclxuICBcdFx0c2ltRGJsY2xpY2s6IHNpbURibGNsaWNrXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVycykge1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcnMuc2ltRGJsY2xpY2spO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gICAqXHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gICAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqXHJcbiAgICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gICAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICAgKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuICB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcbiAgXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4gIC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuICAvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuICBcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuICBcdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuICAvLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG4gIGZ1bmN0aW9uIGdldChpZCkge1xyXG4gIFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4gIC8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuICBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuICBcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuICBcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcbiAgXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuICBcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuICBcdH1cclxuICBcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZSQxKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuICBcdGlmIChjb250YWluZXIpIHtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICBcdHJldHVybiBlbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG4gIGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50KSB7XHJcbiAgXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuICBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG4gIFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICBcdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcbiAgXHR9XHJcbiAgXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHZhciBjbGFzc2VzID0gc3BsaXRXb3JkcyhuYW1lKTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHNldENsYXNzKGVsLCB0cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuICBcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG4gIFx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuICBcdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuICBcdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG4gIFx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4gIC8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4gIC8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuICBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG4gIFx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG4gIFx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcbiAgXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcbiAgXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG4gIFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgXHR0cnkge1xyXG4gIFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG4gIFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG4gIFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcbiAgXHRpZiAoZmlsdGVyKSB7XHJcbiAgXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG4gIFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuICAvLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbiAgLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuICAvLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuICBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG4gIFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbiAgLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuICAvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbiAgLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcbiAgXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcbiAgXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuICBcdFx0KEJyb3dzZXIuaWUzZCA/XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG4gIFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG4gIFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuICAvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4gIC8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbiAgLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG4gIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuICBcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG4gIFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuICBcdGlmIChCcm93c2VyLmFueTNkKSB7XHJcbiAgXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG4gIFx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4gIC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuICBcdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG4gIFx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcbiAgXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbiAgLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4gIC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuICAvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIF91c2VyU2VsZWN0O1xyXG4gIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvbih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdH07XHJcbiAgXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIH0gZWxzZSB7XHJcbiAgXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcbiAgXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuICBcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcbiAgXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4gIC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvbih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuICAvLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbiAgLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuICAvLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbiAgLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuICBcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fVxyXG4gIFx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG4gIFx0cmVzdG9yZU91dGxpbmUoKTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xyXG4gIFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG4gIFx0b24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuICBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuICBcdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG4gIFx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmUgPSBfb3V0bGluZVN0eWxlO1xyXG4gIFx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuICBcdG9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG4gIGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcbiAgXHRkbyB7XHJcbiAgXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuICBcdHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4gIC8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbiAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbiAgLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbiAgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG4gIFx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcbiAgXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuICBcdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcbiAgXHR9O1xyXG4gIH1cblxuICB2YXIgRG9tVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgVFJBTlNGT1JNOiBUUkFOU0ZPUk0sXG4gICAgVFJBTlNJVElPTjogVFJBTlNJVElPTixcbiAgICBUUkFOU0lUSU9OX0VORDogVFJBTlNJVElPTl9FTkQsXG4gICAgZ2V0OiBnZXQsXG4gICAgZ2V0U3R5bGU6IGdldFN0eWxlLFxuICAgIGNyZWF0ZTogY3JlYXRlJDEsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIHRvRnJvbnQ6IHRvRnJvbnQsXG4gICAgdG9CYWNrOiB0b0JhY2ssXG4gICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG4gICAgc2V0Q2xhc3M6IHNldENsYXNzLFxuICAgIGdldENsYXNzOiBnZXRDbGFzcyxcbiAgICBzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuICAgIHRlc3RQcm9wOiB0ZXN0UHJvcCxcbiAgICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcbiAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgZ2V0UG9zaXRpb246IGdldFBvc2l0aW9uLFxuICAgIGdldCBkaXNhYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBkaXNhYmxlVGV4dFNlbGVjdGlvbjsgfSxcbiAgICBnZXQgZW5hYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBlbmFibGVUZXh0U2VsZWN0aW9uOyB9LFxuICAgIGRpc2FibGVJbWFnZURyYWc6IGRpc2FibGVJbWFnZURyYWcsXG4gICAgZW5hYmxlSW1hZ2VEcmFnOiBlbmFibGVJbWFnZURyYWcsXG4gICAgcHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuICAgIHJlc3RvcmVPdXRsaW5lOiByZXN0b3JlT3V0bGluZSxcbiAgICBnZXRTaXplZFBhcmVudE5vZGU6IGdldFNpemVkUGFyZW50Tm9kZSxcbiAgICBnZXRTY2FsZTogZ2V0U2NhbGVcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbiAgLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuICAvLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4gIC8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4gIC8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuICAvLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgb2YgZ2l2ZW4gdHlwZXMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIGZyb20gZ2l2ZW4gSFRNTEVsZW1lbnRcclxuICBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gIFx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG4gIFx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblxyXG4gIFx0fSBlbHNlIGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0YmF0Y2hSZW1vdmUob2JqLCBmdW5jdGlvbiAodHlwZSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIGluZGV4T2YodHlwZXMsIHR5cGUpICE9PSAtMTtcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcbiAgXHRmb3IgKHZhciBpZCBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG4gIFx0XHR2YXIgdHlwZSA9IGlkLnNwbGl0KC9cXGQvKVswXTtcclxuICBcdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG4gIFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIG51bGwsIG51bGwsIGlkKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgdmFyIG1vdXNlU3Vic3QgPSB7XHJcbiAgXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuICBcdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcbiAgXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG4gIFx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcbiAgXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcbiAgXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9O1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQsIGlkKSB7XHJcbiAgXHRpZCA9IGlkIHx8IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpO1xyXG4gIFx0dmFyIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG4gIFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbiAgLy8gYGBganNcclxuICAvLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbiAgLy8gfSk7XHJcbiAgLy8gYGBgXHJcbiAgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcbiAgXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuICBcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICBcdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcbiAgXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RibGNsaWNrJ2AsIGAnY29udGV4dG1lbnUnYCxcclxuICAvLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4gIC8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuICAvLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4gIC8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICBcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICBcdH1cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuICBmdW5jdGlvbiBzdG9wKGUpIHtcclxuICBcdHByZXZlbnREZWZhdWx0KGUpO1xyXG4gIFx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuICAvLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcbiAgXHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG4gIFx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcbiAgXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG4gIFx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG4gIFx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG4gIFx0KTtcclxuICB9XHJcblxyXG4gIC8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcbiAgLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG4gIHZhciB3aGVlbFB4RmFjdG9yID1cclxuICBcdChCcm93c2VyLndpbiAmJiBCcm93c2VyLmNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG4gIFx0QnJvd3Nlci5nZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbiAgLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbiAgLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbiAgLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuICAvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG4gIGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG4gIFx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcbiAgXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG4gIFx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuICBcdCAgICAgICAwO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbiAgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuICBcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICBcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdHRyeSB7XHJcbiAgXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuICBcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGNhdGNoIChlcnIpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbiAgfVxuXG4gIHZhciBEb21FdmVudCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHN0b3BQcm9wYWdhdGlvbjogc3RvcFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcbiAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuICAgIGdldFdoZWVsRGVsdGE6IGdldFdoZWVsRGVsdGEsXG4gICAgaXNFeHRlcm5hbFRhcmdldDogaXNFeHRlcm5hbFRhcmdldCxcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IG9mZlxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAgICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICAgKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICAgKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKi9cblxuICB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG4gIFx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcbiAgXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG4gIFx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG4gIFx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuICBcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuICBcdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG4gIFx0XHR0aGlzLnN0b3AoKTtcblxuICBcdFx0dGhpcy5fZWwgPSBlbDtcbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuICBcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuICBcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcbiAgXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICBcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG4gIFx0XHR0aGlzLl9hbmltYXRlKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc3RvcCgpXG4gIFx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fc3RlcCh0cnVlKTtcbiAgXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBhbmltYXRpb24gbG9vcFxuICBcdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgXHRcdHRoaXMuX3N0ZXAoKTtcbiAgXHR9LFxuXG4gIFx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuICBcdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuICBcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG4gIFx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG4gIFx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuICBcdFx0aWYgKHJvdW5kKSB7XG4gIFx0XHRcdHBvcy5fcm91bmQoKTtcbiAgXHRcdH1cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuICBcdH0sXG5cbiAgXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG4gIFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuICBcdH0sXG5cbiAgXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuICBcdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG4gIFx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuICBcdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuICBcdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG4gIFx0XHRsYXllcnM6IFtdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuICBcdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG4gIFx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG4gIFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuICBcdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG4gIFx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcbiAgXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG4gIFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG4gIFx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG4gIFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG4gIFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG4gIFx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG4gIFx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG4gIFx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG4gIFx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcbiAgXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG4gIFx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcbiAgXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHR6b29tU25hcDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuICBcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuICBcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuICBcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG4gIFx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG4gIFx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuICBcdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuICBcdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG4gIFx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG4gIFx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuICBcdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuICBcdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcbiAgXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuICBcdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG4gIFx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnBhbiA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuICBcdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG4gIFx0XHRcdGlmIChtb3ZlZCkge1xyXG4gIFx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcbiAgXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG4gIFx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcbiAgXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG4gIFx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG4gIFx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG4gIFx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG4gIFx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG4gIFx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuICBcdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcbiAgXHRcdFx0cmV0dXJuIHtcclxuICBcdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG4gIFx0XHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG4gIFx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcbiAgXHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuICBcdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG4gIFx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG4gIFx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcbiAgXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG4gIFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuICBcdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG4gIFx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG4gIFx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG4gIFx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcbiAgXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG4gIFx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG4gIFx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcbiAgXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcbiAgXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcbiAgXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuICBcdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG4gIFx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcbiAgXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG4gIFx0XHQgICAgcmhvID0gMS40MixcclxuICBcdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG4gIFx0XHRmdW5jdGlvbiByKGkpIHtcclxuICBcdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG4gIFx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG4gIFx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcbiAgXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG4gIFx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuICBcdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG4gIFx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcbiAgXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcbiAgXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuICBcdFx0XHRyZXR1cm4gbG9nO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuICBcdFx0dmFyIHIwID0gcigwKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuICBcdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuICBcdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuICBcdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuICBcdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcbiAgXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcbiAgXHRcdFx0aWYgKHQgPD0gMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRcdHRoaXMuX21vdmUoXHJcbiAgXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcbiAgXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzXHJcbiAgXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcbiAgXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcbiAgXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcbiAgXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG4gIFx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG4gIFx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcbiAgXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuICBcdC8vIHBhZGRpbmcgb3B0aW9ucyB0byBmaXQgdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcy5cclxuICBcdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG4gIFx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcbiAgXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG4gIFx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG4gIFx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG4gIFx0XHQgICAgcGFkZGVkU2l6ZSA9IHBhZGRlZEJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG4gIFx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG4gIFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdFx0dmFyIGNlbnRlck9mZnNldCA9IHBpeGVsUG9pbnQuc3VidHJhY3QocGFkZGVkQm91bmRzLmdldENlbnRlcigpKTtcclxuICBcdFx0XHR2YXIgb2Zmc2V0ID0gcGFkZGVkQm91bmRzLmV4dGVuZChwaXhlbFBvaW50KS5nZXRTaXplKCkuc3VidHJhY3QocGFkZGVkU2l6ZSk7XHJcbiAgXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuICBcdFx0XHRwaXhlbENlbnRlci55ICs9IGNlbnRlck9mZnNldC55IDwgMCA/IC1vZmZzZXQueSA6IG9mZnNldC55O1xyXG4gIFx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QocGl4ZWxDZW50ZXIpLCBvcHRpb25zKTtcclxuICBcdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG4gIFx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcbiAgXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG4gIFx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcbiAgXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuICBcdC8vIHBhbiBieSBkZWZhdWx0LlxyXG4gIFx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuICBcdFx0XHRwYW46IHRydWVcclxuICBcdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuICBcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcbiAgXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuICBcdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuICBcdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuICBcdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG4gIFx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuICBcdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcbiAgXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcbiAgXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuICBcdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcbiAgXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcbiAgXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcbiAgXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcbiAgXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gIFx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBleHRlbmQoe1xyXG4gIFx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG4gIFx0XHRcdHdhdGNoOiBmYWxzZVxyXG4gIFx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcbiAgXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuICBcdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcbiAgXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG4gIFx0XHR9LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG4gIFx0XHRcdFx0Y29kZTogMCxcclxuICBcdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9uUmVzcG9uc2UgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG4gIFx0XHQgICAgb25FcnJvciA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcbiAgXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcbiAgXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuICBcdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG4gIFx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG4gIFx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuICBcdFx0XHRjb2RlOiBjLFxyXG4gIFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcbiAgXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuICBcdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG4gIFx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcbiAgXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuICBcdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuICBcdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG4gIFx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuICBcdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcbiAgXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICBcdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG4gIFx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0cnkge1xyXG4gIFx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG4gIFx0XHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuICBcdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcbiAgXHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGk7XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX3BhbmVzID0gW107XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcbiAgXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuICBcdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuICBcdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcbiAgXHRcdCAgICBwYW5lID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKG5hbWUpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHBhbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcbiAgXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuICBcdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcbiAgXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcbiAgXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcbiAgXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuICBcdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuICBcdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG4gIFx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcbiAgXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG4gIFx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG4gIFx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG4gIFx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG4gIFx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcbiAgXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuICBcdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuICBcdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG4gIFx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcbiAgXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG4gIFx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG4gIFx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG4gIFx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcbiAgXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG4gIFx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG4gIFx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcbiAgXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcbiAgXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuICBcdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcbiAgXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuICBcdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcbiAgXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuICBcdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG4gIFx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG4gIFx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuICBcdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuICBcdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG4gIFx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuICBcdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcbiAgXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG4gIFx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG4gIFx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuICBcdFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gc3RhbXAoY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcbiAgXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG4gIFx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG4gIFx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG4gIFx0XHR2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuICBcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcbiAgXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuICBcdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuICBcdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcbiAgXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcbiAgXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcbiAgXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG4gIFx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYFRvb2x0aXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuICBcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuICBcdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG4gIFx0XHR0aGlzXHJcbiAgXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG4gIFx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcbiAgXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcbiAgXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuICBcdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuICBcdFx0aWYgKGxvYWRpbmcpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSwgc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuICBcdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuICBcdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuICBcdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuICBcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG4gIFx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICBcdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzW3N0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IG9mZiA6IG9uO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuICBcdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG4gIFx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcbiAgXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuICBcdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcbiAgXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcbiAgXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcbiAgXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuICBcdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcbiAgXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG4gIFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuICBcdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuICBcdFx0ICAgIHRhcmdldCxcclxuICBcdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG4gIFx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG4gIFx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHdoaWxlIChzcmMpIHtcclxuICBcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG4gIFx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcbiAgXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG4gIFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiB0aGlzLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0YXJnZXRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0d2hpbGUgKGVsICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICBcdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuICBcdFx0XHRwcmV2ZW50T3V0bGluZShlbCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuICBcdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG4gIFx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcbiAgXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuICBcdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuICBcdFx0XHR2YXIgc3ludGggPSBleHRlbmQoe30sIGUpO1xyXG4gIFx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG4gIFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuICBcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuICBcdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuICBcdFx0XHR2YXIgZmlsdGVyZWQgPSBbXTsgLy8gcGljayBvbmx5IHRhcmdldHMgd2l0aCBsaXN0ZW5lcnNcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChjYW52YXNUYXJnZXRzW2ldKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IGZpbHRlcmVkLmNvbmNhdCh0YXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XHJcbiAgXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG4gIFx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcbiAgXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuICBcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuICBcdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG4gIFx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuICBcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcbiAgXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIGluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuICBcdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gIFx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcbiAgXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcbiAgXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBnZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcbiAgXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG4gIFx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuICBcdFx0XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG4gIFx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcbiAgXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuICBcdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuICBcdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcbiAgXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuICBcdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcbiAgXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG4gIFx0XHRcdHJldHVybiBjZW50ZXI7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcbiAgXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG4gIFx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcbiAgXHRcdCAgICApLFxyXG4gIFx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG4gIFx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuICBcdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuICBcdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gIFx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcbiAgXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcbiAgXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG4gIFx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICBcdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuICBcdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG4gIFx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuICBcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG4gIFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICBcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5fcHJveHkpO1xyXG4gIFx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuICBcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuICBcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSlcclxuICBcdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuICBcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb20sXHJcbiAgXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG4gIFx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcbiAgXHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgLy9cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2xcclxuICAgKiBAYWthIEwuQ29udHJvbFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICAgKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICAgKi9cclxuXHJcbiAgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuICBcdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuICBcdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuICBcdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICpcclxuICBcdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG4gIFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHQgKi9cclxuICBcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5yZW1vdmUoKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuICBcdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuICBcdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuICBcdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuICBcdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcbiAgXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gICAqIEB1bmluaGVyaXRhYmxlXHJcbiAgICpcclxuICAgKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAgICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICAgKi9cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgICovXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuICBcdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcbiAgXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuICBcdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcbiAgXHRcdCAgICAgICAgICAgIGNyZWF0ZSQxKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuICBcdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuICBcdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICAgKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICAgKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogdmFyIG92ZXJsYXlzID0ge1xyXG4gICAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gICAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcclxuICAgKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAgICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG4gIFx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG4gIFx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcbiAgXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcbiAgXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuICBcdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcbiAgXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcbiAgXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuICBcdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG4gIFx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcbiAgXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuICBcdFx0aWYgKG9iaikge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcbiAgXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuICBcdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuICBcdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuICBcdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcbiAgXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcbiAgXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcbiAgXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuICBcdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IGNyZWF0ZSQxKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG4gIFx0XHRpZiAoY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRvbihjb250YWluZXIsIHtcclxuICBcdFx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdFx0b24oc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdFx0XHRvZmYoc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH0sXHJcbiAgXHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG4gIFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcbiAgXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblxyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBwcmV2ZW50RGVmYXVsdCk7IC8vIHByZXZlbnQgbGluayBmdW5jdGlvblxyXG4gIFx0XHRvbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuICBcdFx0XHRsYXllcjogbGF5ZXIsXHJcbiAgXHRcdFx0bmFtZTogbmFtZSxcclxuICBcdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG4gIFx0XHRcdH0sIHRoaXMpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuICBcdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuICBcdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcbiAgXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcbiAgXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG4gIFx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcbiAgXHRcdGlmICh0eXBlKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcbiAgXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuICBcdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG4gIFx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuICBcdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG4gIFx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG4gIFx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG4gIFx0XHQgICAgaW5wdXQ7XHJcblxyXG4gIFx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuICBcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcbiAgXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG4gIFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcbiAgXHRcdGlucHV0LmxheWVySWQgPSBzdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuICBcdFx0b24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICBcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcbiAgXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcbiAgXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG4gIFx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIGxhYmVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcbiAgXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcbiAgXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG4gIFx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcbiAgXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsXHJcbiAgXHRcdCAgICBsYXllcixcclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcbiAgXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuICBcdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbiAgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICovXHJcblxyXG4gIHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuICBcdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuICBcdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nXHJcbiAgXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcbiAgXHRcdHpvb21PdXRUZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcbiAgXHRcdHZhciBsaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG4gIFx0XHQgKi9cclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGluaztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuICBcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuICAvLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0em9vbUNvbnRyb2w6IHRydWVcclxuICB9KTtcclxuXHJcbiAgTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuICBcdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuICBcdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuICBcdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG4gIFx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG4gIHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gICAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gICAqIEBpbmhlcml0cyBDb250cm9sXG4gICAqXG4gICAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcbiAgXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuICBcdFx0bWF4V2lkdGg6IDEwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cbiAgXHRcdG1ldHJpYzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuICBcdFx0aW1wZXJpYWw6IHRydWVcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cbiAgXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICBcdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG4gIFx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuICBcdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG4gIFx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG4gIFx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuICBcdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuICBcdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG4gIFx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG4gIFx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuICBcdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG4gIFx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuICBcdH0sXG5cbiAgXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcbiAgXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuICBcdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuICBcdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG4gIFx0XHQgICAgZCA+PSA1ID8gNSA6XG4gIFx0XHQgICAgZCA+PSAzID8gMyA6XG4gIFx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cbiAgXHRcdHJldHVybiBwb3cxMCAqIGQ7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciB1a3JhaW5pYW5GbGFnID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI4XCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZ3xmYWxzZSA9ICdMZWFmbGV0J1xyXG4gIFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG4gIFx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0bWFwLm9uKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkQXR0cmlidXRpb246IGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdGV2LmxheWVyLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcbiAgXHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuICBcdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG4gIFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuICBcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICBcdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG4gIHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG4gIENvbnRyb2wuWm9vbSA9IFpvb207XG4gIENvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbiAgQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG4gIGNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuICBjb250cm9sLnpvb20gPSB6b29tO1xuICBjb250cm9sLnNjYWxlID0gc2NhbGU7XG4gIGNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuICAvKlxuICBcdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG4gIFx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4gICovXG5cbiAgLy8gQGNsYXNzIEhhbmRsZXJcbiAgLy8gQGFrYSBMLkhhbmRsZXJcbiAgLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG4gIHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcbiAgXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuYWRkSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuICBcdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcbiAgXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuICBcdH1cblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG4gIFx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbiAgLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4gIC8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gIEhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gIFx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICAgKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICAgKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAgICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuICB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcbiAgXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcbiAgXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuICBcdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuICBcdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuICBcdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG4gIFx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0b24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG4gIFx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuICBcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gIFx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG4gIFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcbiAgXHRcdCAgICBzaXplZFBhcmVudCA9IGdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG4gIFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcbiAgXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuICBcdFx0dmFyIG1vdXNlZXZlbnQgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gIFx0XHRvbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuICBcdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG4gIFx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcbiAgXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcbiAgXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0YWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuICBcdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuICBcdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuICBcdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG4gIFx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuICBcdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcbiAgXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG4gIFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cclxuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuICBcdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAgICovXHJcblxyXG4gIC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4gIC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4gIC8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbiAgLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuICAvLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbiAgLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4gIC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuICAvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4gIC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHBzOi8vbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanMvKS5cclxuICBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG4gIFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICBcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbiAgfVxyXG5cclxuICAvLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuICBcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG4gIFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcbiAgXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG4gIFx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcbiAgXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG4gIFx0dmFyIGksXHJcbiAgXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcbiAgXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXdQb2ludHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcbiAgXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuICBcdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG4gIFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuICBcdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcbiAgXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuICBcdFx0XHRpbmRleCA9IGk7XHJcbiAgXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG4gIGZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG4gIFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHRcdHByZXYgPSBpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuICBcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuICB9XHJcblxyXG4gIHZhciBfbGFzdENvZGU7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4gIC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuICAvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbiAgLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4gIC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbiAgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuICBcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuICBcdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG4gIFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG4gIFx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG4gIFx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuICBcdHdoaWxlICh0cnVlKSB7XHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuICBcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuICBcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG4gIFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gb3RoZXIgY2FzZXNcclxuICBcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG4gIFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcbiAgXHRcdFx0YSA9IHA7XHJcbiAgXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGIgPSBwO1xyXG4gIFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG4gIFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG4gIFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdCAgICB4LCB5O1xyXG5cclxuICBcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWF4Lnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWluLnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG4gIFx0XHR4ID0gbWF4Lng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuICBcdFx0eCA9IG1pbi54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuICBcdHZhciBjb2RlID0gMDtcclxuXHJcbiAgXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuICBcdFx0Y29kZSB8PSAxO1xyXG4gIFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuICBcdFx0Y29kZSB8PSAyO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdGNvZGUgfD0gNDtcclxuICBcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG4gIFx0XHRjb2RlIHw9IDg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvZGU7XHJcbiAgfVxyXG5cclxuICAvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuICBmdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG4gIFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICBcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG4gIGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG4gIFx0dmFyIHggPSBwMS54LFxyXG4gIFx0ICAgIHkgPSBwMS55LFxyXG4gIFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0geSxcclxuICBcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuICBcdCAgICB0O1xyXG5cclxuICBcdGlmIChkb3QgPiAwKSB7XHJcbiAgXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG4gIFx0XHRpZiAodCA+IDEpIHtcclxuICBcdFx0XHR4ID0gcDIueDtcclxuICBcdFx0XHR5ID0gcDIueTtcclxuICBcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG4gIFx0XHRcdHggKz0gZHggKiB0O1xyXG4gIFx0XHRcdHkgKz0gZHkgKiB0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0ZHggPSBwLnggLSB4O1xyXG4gIFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuICBcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbiAgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuICBcdHJldHVybiAhaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcbiAgXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcbiAgXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG4gIH1cblxuICB2YXIgTGluZVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHNpbXBsaWZ5OiBzaW1wbGlmeSxcbiAgICBwb2ludFRvU2VnbWVudERpc3RhbmNlOiBwb2ludFRvU2VnbWVudERpc3RhbmNlLFxuICAgIGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGNsaXBTZWdtZW50OiBjbGlwU2VnbWVudCxcbiAgICBfZ2V0RWRnZUludGVyc2VjdGlvbjogX2dldEVkZ2VJbnRlcnNlY3Rpb24sXG4gICAgX2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuICAgIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGlzRmxhdDogaXNGbGF0LFxuICAgIF9mbGF0OiBfZmxhdFxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICAgKi9cclxuXHJcbiAgLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICAgKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gICAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAgICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gICAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGNsaXBwZWRQb2ludHMsXHJcbiAgXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcbiAgXHQgICAgaSwgaiwgayxcclxuICBcdCAgICBhLCBiLFxyXG4gIFx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0cG9pbnRzW2ldLl9jb2RlID0gX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuICBcdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuICBcdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG4gIFx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG4gIFx0XHRcdGEgPSBwb2ludHNbaV07XHJcbiAgXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcbiAgXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcbiAgXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuICBcdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG4gIFx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG4gIFx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxuXG4gIHZhciBQb2x5VXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY2xpcFBvbHlnb246IGNsaXBQb2x5Z29uXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAc2VjdGlvblxyXG4gICAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAgICpcclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAgICpcclxuICAgKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICAgKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gICAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAgICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIExvbkxhdCA9IHtcclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICAgKlxyXG4gICAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWVyY2F0b3IgPSB7XHJcbiAgXHRSOiA2Mzc4MTM3LFxyXG4gIFx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG4gIFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuICBcdFx0ICAgIHIgPSB0aGlzLlIsXHJcbiAgXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcbiAgXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG4gIFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuICBcdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcbiAgXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcbiAgXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcbiAgXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcbiAgXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcbiAgXHRcdFx0cGhpICs9IGRwaGk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcbiAgXHR9XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gICAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gICAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICAgKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAgICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICAgKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICAgKi9cblxuICB2YXIgaW5kZXggPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIExvbkxhdDogTG9uTGF0LFxuICAgIE1lcmNhdG9yOiBNZXJjYXRvcixcbiAgICBTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3JcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gICAqXHJcbiAgICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgKi9cclxuICB2YXIgRVBTRzMzOTUgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuICBcdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuICBcdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG4gIFx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcbiAgXHR9KCkpXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICAgKlxyXG4gICAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICAgKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gICAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICAgKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAgICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG4gIFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxuICB9KTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIENSU1xuICAgKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICAgKlxuICAgKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAgICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICAgKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAgICovXG5cbiAgdmFyIFNpbXBsZSA9IGV4dGVuZCh7fSwgQ1JTLCB7XG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcbiAgXHR9LFxuXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuICBcdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuICBcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFx0fSxcblxuICBcdGluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIENSUy5FYXJ0aCA9IEVhcnRoO1xuICBDUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbiAgQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG4gIENSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbiAgQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG4gIENSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbiAgLypcbiAgICogQGNsYXNzIExheWVyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIEBha2EgTC5MYXllclxuICAgKiBAYWthIElMYXllclxuICAgKlxuICAgKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICAgKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIucmVtb3ZlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnQgYWRkOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAgICpcbiAgICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICAgKi9cblxuXG4gIHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuICBcdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuICBcdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG4gIFx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHQvKiBAc2VjdGlvblxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICBcdCAqXG4gIFx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuICBcdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG4gIFx0ICovXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG4gIFx0Ly9cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG4gIFx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuICBcdFx0aWYgKG9iaikge1xuICBcdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuICBcdH0sXG5cbiAgXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gIFx0XHR0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tzdGFtcCh0YXJnZXRFbCldO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuICBcdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG4gIFx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gIFx0fSxcblxuICBcdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuICBcdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuICBcdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG4gIFx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuICBcdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuICBcdFx0XHR9LCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vbkFkZChtYXApO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuICBcdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG4gIFx0fVxuICB9KTtcblxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICAgKiBAdW5pbmhlcml0YWJsZVxuICAgKlxuICAgKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gICAqXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFwXG4gICAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAqXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgICovXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG4gIFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG4gIFx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG4gIFx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG4gIFx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuICBcdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcbiAgXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG4gIFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG4gIFx0fSxcblxuICBcdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcbiAgXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICBcdCAqIGBgYFxuICBcdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuICBcdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG4gIFx0ICogfSk7XG4gIFx0ICogYGBgXG4gIFx0ICovXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgXHRcdGxheWVycyA9IGxheWVycyA/IChpc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG4gIFx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuICBcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG4gIFx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuICBcdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG4gIFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG4gIFx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cbiAgXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gICAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICAgKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICAgKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gICAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gICAqIFx0LmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdHZhciBpLCBsZW47XHJcblxyXG4gIFx0XHRpZiAobGF5ZXJzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuICBcdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcbiAgXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcbiAgXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG4gIFx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gIFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgXHRcdCAgICBpLCBsYXllcjtcclxuXHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcbiAgXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcbiAgXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuICBcdC8vIGBgYGpzXHJcbiAgXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuICBcdC8vIH0pO1xyXG4gIFx0Ly8gYGBgXHJcbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcbiAgXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuICBcdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICAgKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAgICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICAgKlxyXG4gICAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAgICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAgICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gICAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gICAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICAgKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAgICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBib3VuZHM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBJY29uXHJcbiAgICogQGFrYSBMLkljb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICAgKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICAgKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICAgKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gICAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICAgKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICAgKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICAgKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICAgKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAgICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuICBcdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcbiAgXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcbiAgXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcbiAgXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0ICovXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG4gIFx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcbiAgXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcbiAgXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKCFzcmMpIHtcclxuICBcdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGltZztcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG4gIFx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuICBcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG4gIFx0XHRpZiAoYW5jaG9yKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChzaXplKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuICBcdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICBcdFx0ZWwuc3JjID0gc3JjO1xyXG4gIFx0XHRyZXR1cm4gZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAgICogQGFrYSBMLkljb24uRGVmYXVsdFxuICAgKiBAc2VjdGlvblxuICAgKlxuICAgKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICAgKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAgICogcmVsZWFzZXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gICAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICAgKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gICAqL1xuXG4gIHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuICBcdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG4gIFx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuICBcdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuICBcdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuICBcdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuICBcdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG4gIFx0fSxcblxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG4gIFx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcbiAgXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcbiAgXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuICBcdH0sXG5cbiAgXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcbiAgXHRcdHZhciBzdHJpcCA9IGZ1bmN0aW9uIChzdHIsIHJlLCBpZHgpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcbiAgXHRcdH07XG4gIFx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG4gIFx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcbiAgXHR9LFxuXG4gIFx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG4gIFx0XHR2YXIgcGF0aCA9IGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG4gIFx0XHQgICAgICAgICAgIGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuICBcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gIFx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG4gIFx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuICBcdFx0dmFyIGxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibGVhZmxldC5jc3NcIl0nKTtcbiAgXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cbiAgXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFya2VyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gICAqXG4gICAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAgKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAgICovXG5cbiAgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuICBcdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG4gIFx0XHRhZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcbiAgXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcbiAgXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG4gIFx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cbiAgXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG4gIFx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcbiAgXHRcdCk7XG5cbiAgXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG4gIFx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcbiAgXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuICBcdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG4gIFx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cbiAgXHRcdFx0c2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG4gIFx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuICBcdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG4gIFx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuICBcdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG4gIFx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG4gIFx0XHRpZiAoc2hhZG93KSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG4gIFx0XHRtYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIE1hcmtlclxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqIEBha2EgTC5NYXJrZXJcclxuICAgKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuICBcdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG4gIFx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuICBcdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG4gIFx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0dGl0bGU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcbiAgXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG4gIFx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcbiAgXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcbiAgXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcbiAgXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG4gIFx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuICBcdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcbiAgXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuICBcdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG4gIFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG4gIFx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG4gIFx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcbiAgXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcbiAgXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG4gIFx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKlxyXG4gIFx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuICBcdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcbiAgXHR9LFxyXG5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gIFx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcbiAgXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcbiAgXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG4gIFx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuICBcdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICBcdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuICBcdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcbiAgXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuICBcdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG4gIFx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuICBcdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG5cclxuICBcdFx0aWYgKGFkZEljb24pIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuICBcdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuICBcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcbiAgXHRcdFx0b2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5faWNvbik7XHJcbiAgXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG4gIFx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuICBcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0YWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHRpZiAoTWFya2VyRHJhZykge1xyXG4gIFx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG4gIFx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuICBcdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuICBcdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHRvUG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogdG9Qb2ludCgwLCAwKTtcclxuICBcdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyB0b1BvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogdG9Qb2ludCgwLCAwKTtcclxuXHJcbiAgXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcbiAgXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuICBcdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuICB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUGF0aCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdHN0cm9rZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG4gIFx0XHQvLyBTdHJva2UgY29sb3JcbiAgXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cbiAgXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG4gIFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIFx0XHR3ZWlnaHQ6IDMsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaEFycmF5OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdGZpbGw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuICBcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuICBcdFx0ZmlsbENvbG9yOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRcdC8vIEZpbGwgb3BhY2l0eS5cbiAgXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cbiAgXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cbiAgXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuICBcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuICBcdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG4gIFx0XHR0aGlzLl9yZXNldCgpO1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcbiAgXHRcdHRoaXMuX3Byb2plY3QoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcbiAgXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZU1hcmtlclxuICAgKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAgICovXG5cbiAgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuICBcdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcbiAgXHRcdHJhZGl1czogMTBcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMucmVkcmF3KCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuICBcdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuICBcdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuICBcdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG4gIFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVcbiAgICogQGFrYSBMLkNpcmNsZVxuICAgKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICAgKlxuICAgKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gIFx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuICBcdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG4gIFx0XHR9XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuICBcdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcbiAgXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuICBcdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcbiAgXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuICBcdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcbiAgXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcbiAgXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG4gIFx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuICBcdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuICBcdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG4gIFx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4gIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4gIC8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuICBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBQb2x5bGluZVxuICAgKiBAYWthIEwuUG9seWxpbmVcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdFszNC4wNCwgLTExOC4yXVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gICAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICAgKiBcdFtbNDAuNzgsIC03My45MV0sXG4gICAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAgICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcbiAgXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cbiAgXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuICBcdFx0bm9DbGlwOiBmYWxzZVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuICBcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cbiAgXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuICBcdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuICBcdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cbiAgXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcbiAgXHRcdCAgICBjbG9zZXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICBcdFx0ICAgIHAxLCBwMjtcblxuICBcdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG4gIFx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG4gIFx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cbiAgXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gIFx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcbiAgXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0aWYgKG1pblBvaW50KSB7XG4gIFx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBtaW5Qb2ludDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuICBcdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuICBcdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cbiAgXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG4gIFx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG4gIFx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgXHRcdFx0cDEgPSBwb2ludHNbaV07XG4gIFx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cbiAgXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuICBcdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuICBcdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcbiAgXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG4gIFx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG4gIFx0XHRcdFx0XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2ZcbiAgXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuICBcdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cbiAgXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuICBcdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuICBcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuICBcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHQgICAgZmxhdCA9IGlzRmxhdChsYXRsbmdzKTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX3JpbmdzID0gW107XG4gIFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG4gIFx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcbiAgXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG4gIFx0XHRdKTtcbiAgXHR9LFxuXG4gIFx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcbiAgXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcbiAgXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcbiAgXHRcdCAgICBpLCByaW5nO1xuXG4gIFx0XHRpZiAoZmxhdCkge1xuICBcdFx0XHRyaW5nID0gW107XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuICBcdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcbiAgXHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuICBcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cbiAgXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG4gIFx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG4gIFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuICBcdFx0XHRcdFx0aysrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG4gIFx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcbiAgXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcbiAgXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG4gIFx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRpZiAocG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbiAgLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4gIC8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuICBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cbiAgUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWdvblxuICAgKiBAYWthIEwuUG9seWdvblxuICAgKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAgICpcbiAgICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gICAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogXTtcbiAgICogYGBgXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAgICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogICBdLFxuICAgKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAgICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICAgKiAgIF1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWVcbiAgXHR9LFxuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG4gIFx0fSxcblxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuICBcdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuICBcdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cbiAgXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cbiAgXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xuICBcdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuICBcdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcbiAgXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcbiAgXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcbiAgXHRcdFx0YXJlYSArPSBmICogMztcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFyZWEgPT09IDApIHtcbiAgXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG4gIFx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcbiAgXHR9LFxuXG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcbiAgXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG4gIFx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG4gIFx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuICBcdFx0XHRyZXN1bHQucG9wKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuICBcdFx0aWYgKGlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuICBcdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG4gIFx0fSxcblxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuICBcdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuICBcdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cbiAgXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcbiAgXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG4gIFx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcbiAgXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0Y2xpcHBlZCA9IGNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuICBcdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuICBcdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdHAxID0gcGFydFtqXTtcbiAgXHRcdFx0XHRwMiA9IHBhcnRba107XG5cbiAgXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICBcdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG4gIFx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuICBcdH1cblxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEdlb0pTT05cclxuICAgKiBAYWthIEwuR2VvSlNPTlxyXG4gICAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICAgKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAgICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICAgKiBcdH1cclxuICAgKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gICAqIH0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG4gIFx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuICBcdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcbiAgXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4ge31cclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuICBcdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuICBcdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuICBcdFx0aWYgKGdlb2pzb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG4gIFx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuICBcdFx0dmFyIGZlYXR1cmVzID0gaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG4gIFx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuICBcdFx0aWYgKGZlYXR1cmVzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG4gIFx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG4gIFx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG4gIFx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuICBcdFx0aWYgKCFsYXllcikge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG4gIFx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcbiAgXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG4gIFx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG4gIFx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG4gIFx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuICBcdFx0bGF5ZXIub3B0aW9ucyA9IGV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG4gIFx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuICBcdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuICAvLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbiAgLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbiAgLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbiAgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG4gIFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG4gIFx0ICAgIGxheWVycyA9IFtdLFxyXG4gIFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcbiAgXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG4gIFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuICBcdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuXHJcbiAgXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuICBcdGNhc2UgJ1BvaW50JzpcclxuICBcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdNdWx0aVBvaW50JzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcbiAgXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcbiAgXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnUG9seWdvbic6XHJcbiAgXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuICBcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG4gIFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcbiAgXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRcdGlmIChsYXllcikge1xyXG4gIFx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGRlZmF1bHQ6XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuICBcdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcbiAgXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4gIC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4gIC8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuICAvLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbiAgLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG4gIFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcbiAgXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG4gIFx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbGF0bG5ncztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuICAvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuICBcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbiAgLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuICBcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuICBcdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcbiAgXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG4gIFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb29yZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG4gIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG4gIFx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcbiAgXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG4gIGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcbiAgXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdHJldHVybiBnZW9qc29uO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0cHJvcGVydGllczoge30sXHJcbiAgXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgdmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbiAgLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBDaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbiAgQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbiAgUG9seWxpbmUuaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcbiAgUG9seWdvbi5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG4gIFx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuICBcdFx0aWYgKCFob2xlcykge1xyXG4gIFx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbiAgTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuICBcdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICBcdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG4gIFx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuICBcdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcbiAgXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG4gIFx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuICBcdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG4gIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcbiAgXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcbiAgXHRcdH07XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4gIC8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbiAgLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbiAgLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gICAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gICAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAgICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuICBcdFx0YWx0OiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuICBcdFx0ekluZGV4OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuICBcdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcbiAgXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuICBcdFx0aW1nLm9uZXJyb3IgPSBiaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcbiAgXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcbiAgXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuICB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICAgKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAgICpcclxuICAgKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gICAqIEhUTUw1IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gICAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICAgKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuICBcdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuICBcdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcbiAgXHRcdGxvb3A6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuICBcdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gU2VlIFticm93c2VyIGNvbXBhdGliaWxpdHldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0KVxyXG4gIFx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIE1vYmlsZSBicm93c2VycyB3aWxsIHBsYXkgdGhlIHZpZGVvIHJpZ2h0IHdoZXJlIGl0IGlzIGluc3RlYWQgb2Ygb3BlbiBpdCB1cCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcbiAgXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG4gIFx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgndmlkZW8nKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHR2aWQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcbiAgXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gIFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuICBcdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG4gIFx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcbiAgXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG4gIFx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcbiAgXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuICBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdPdmVybGF5XG4gICAqIEBha2EgTC5TVkdPdmVybGF5XG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAgICpcbiAgICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAgICpcbiAgICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICAgKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICAgKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAgICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG4gIFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cbiAgXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0ZWwub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuICBcdH1cblxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4gIC8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuICBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICAgKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICAgKi9cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuICBcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiB1bmRlZmluZWRcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcbiAgXHRcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAuY2xvc2VQb3B1cChwb3B1cClgL2AuY2xvc2VUb29sdGlwKHRvb2x0aXApYFxyXG4gIFx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG4gIFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgb3ZlcmxheSBib3VuZCB0byBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuICBcdHRvZ2dsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLmNsb3NlKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGhpcy5fcHJlcGFyZU9wZW4oKTtcclxuXHJcbiAgXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcbiAgXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG4gIFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuICBcdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcbiAgXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuICBcdFx0XHRzb3VyY2UgPSBudWxsO1xyXG4gIFx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiBsYXllcnMpIHtcclxuICBcdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuICBcdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICghc291cmNlKSB7IHJldHVybiBmYWxzZTsgfSAvLyBVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllci5cclxuXHJcbiAgXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghbGF0bG5nKSB7XHJcbiAgXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRCb3VuZHMpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuICBcdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICBcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBjb250ZW50dXBkYXRlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuICBcdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuICBcdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuICBcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBvdmVybGF5IGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbMCwgMF07XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIGNvbnRlbnQsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcbiAgXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF0bG5nKSB7XHJcbiAgXHRcdFx0b3ZlcmxheS5zZXRMYXRMbmcobGF0bG5nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIExheWVyLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBvbGQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG4gIFx0XHRcdHNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0b3ZlcmxheS5fc291cmNlID0gdGhpcztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb3B1cFxyXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAgICogQGFrYSBMLlBvcHVwXHJcbiAgICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gICAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gICAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gICAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICAgKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdwb3B1cFBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcbiAgXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcbiAgXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcbiAgXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuICBcdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG4gIFx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG4gIFx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuICBcdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcbiAgXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG4gIFx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcbiAgXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcbiAgXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICBcdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuICBcdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuICBcdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcbiAgXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS5cclxuICBcdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVMYXllcihtYXAuX3BvcHVwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRtYXAuX3BvcHVwID0gdGhpcztcclxuXHJcbiAgXHRcdHJldHVybiBEaXZPdmVybGF5LnByb3RvdHlwZS5vcGVuT24uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG4gIFx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcbiAgXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JyxcclxuICBcdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG4gIFx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG4gIFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcbiAgXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl90aXAgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG4gIFx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2xvc2UgcG9wdXAnKTtcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuICBcdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5jbG9zZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcbiAgXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcbiAgXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG4gIFx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG4gIFx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcbiAgXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG4gIFx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuICBcdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG4gIFx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG4gIFx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcbiAgXHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuICBcdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcbiAgXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG4gIFx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG4gIFx0XHRsYXllclBvcy5fYWRkKGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcbiAgXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgZHggPSAwLFxyXG4gIFx0XHQgICAgZHkgPSAwO1xyXG5cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG4gIFx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcbiAgXHRcdGlmIChkeCB8fCBkeSkge1xyXG4gIFx0XHRcdG1hcFxyXG4gIFx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuICBcdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldLCB7YW5pbWF0ZTogZSAmJiBlLnR5cGUgPT09ICdtb3ZlZW5kJ30pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4gIHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuICBcdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICAgKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gICAqL1xyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gIFx0XHRwb3B1cCA9IGFyZ3VtZW50cy5sZW5ndGggPyBwb3B1cCA6IHRoaXMuX3BvcHVwO1xyXG4gIFx0XHRpZiAocG9wdXApIHtcclxuICBcdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cclxuXHJcbiAgLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG4gIExheWVyLmluY2x1ZGUoe1xyXG5cclxuICBcdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG4gIFx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5vbih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuICBcdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xyXG4gIFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuICBcdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG4gIFx0XHRzdG9wKGUpO1xyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuICBcdFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG4gIFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcbiAgXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAgICogQGFrYSBMLlRvb2x0aXBcbiAgICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICAgKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAgICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gICAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gICAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gICAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAgICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gICAqL1xuXG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcbiAgXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cbiAgXHRcdG9mZnNldDogWzAsIDBdLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG4gIFx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuICBcdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuICBcdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuICBcdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cbiAgXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG4gIFx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG4gIFx0XHRzdGlja3k6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuICBcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cbiAgXHRcdG9wYWNpdHk6IDAuOVxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICBcdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuICBcdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0dmFyIHN1YlgsIHN1YlksXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG4gIFx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG4gIFx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcbiAgXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gIFx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuICBcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gMDtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH1cblxuICBcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICAvLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG4gIHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICBcdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xuICB9O1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgTWFwLmluY2x1ZGUoe1xuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcbiAgXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gIFx0XHR0b29sdGlwLmNsb3NlKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBMYXllclxuICAgKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICAgKlxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICAgKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIC8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuICBMYXllci5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG4gIFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG4gIFx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG4gIFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cbiAgXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcbiAgXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gIFx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcbiAgXHRcdCAgICBldmVudHMgPSB7XG4gIFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG4gIFx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG4gIFx0XHQgICAgfTtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuICBcdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuICBcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG4gIFx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG4gIFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuICBcdFx0XHR0aGlzLl90b29sdGlwLm9wZW5Pbih0aGlzLl9tYXApO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuICBcdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gIFx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuICBcdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuICBcdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgXHR9LFxuXG4gIFx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXAgfHwgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cbiAgXHRcdHRoaXMub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcbiAgXHR9LFxuXG4gIFx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuICBcdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuICBcdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcbiAgXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgRGl2SWNvblxuICAgKiBAYWthIEwuRGl2SWNvblxuICAgKiBAaW5oZXJpdHMgSWNvblxuICAgKlxuICAgKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICAgKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAgICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAgICpcbiAgICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAgICovXG5cbiAgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG4gIFx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG4gIFx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuICBcdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cbiAgXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcbiAgXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG4gIFx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuICBcdFx0aHRtbDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG4gIFx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG4gIFx0XHRiZ1BvczogbnVsbCxcblxuICBcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcbiAgXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICBcdFx0XHRlbXB0eShkaXYpO1xuICBcdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG4gIFx0XHRcdHZhciBiZ1BvcyA9IHRvUG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG4gIFx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4JztcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG4gIFx0XHRyZXR1cm4gZGl2O1xuICBcdH0sXG5cbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG4gIH1cblxuICBJY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcblxuICAvKlxuICAgKiBAY2xhc3MgR3JpZExheWVyXG4gICAqIEBpbmhlcml0cyBMYXllclxuICAgKiBAYWthIEwuR3JpZExheWVyXG4gICAqXG4gICAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAgICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICAgKlxuICAgKlxuICAgKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gICAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICpcbiAgICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAgICogICAgICAgICB2YXIgZXJyb3I7XG4gICAqXG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAgICogICAgICAgICB9LCAxMDAwKTtcbiAgICpcbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvblxuICAgKi9cblxuXG4gIHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG4gIFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG4gIFx0XHR0aWxlU2l6ZTogMjU2LFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cbiAgXHRcdG9wYWNpdHk6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcbiAgXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG4gIFx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuICBcdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcbiAgXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG4gIFx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cbiAgXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcbiAgXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG4gIFx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cbiAgXHRcdHpJbmRleDogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuICBcdFx0Ym91bmRzOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWluWm9vbTogMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG4gIFx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG4gIFx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuICBcdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3RpbmdcbiAgXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG4gIFx0XHRub1dyYXA6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcbiAgXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cbiAgXHRcdGtlZXBCdWZmZXI6IDJcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuICBcdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG4gIFx0fSxcblxuICBcdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICBcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuICBcdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG4gIFx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICBcdFx0fTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcbiAgXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG4gIFx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG4gIFx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuICBcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcbiAgXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG4gIFx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG4gIFx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICBcdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuICBcdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cbiAgXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcbiAgXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG4gIFx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cbiAgXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuICBcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuICBcdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG4gIFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG4gIFx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG4gIFx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcbiAgXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG4gIFx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cbiAgXHRcdGlmIChuZXh0RnJhbWUpIHtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbk9wYXF1ZVRpbGU6IGZhbHNlRm4sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG4gIFx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG4gIFx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0eiA9IE51bWJlcih6KTtcbiAgXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuICBcdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuICBcdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG4gIFx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcbiAgXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdGlmICghbGV2ZWwpIHtcbiAgXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuICBcdFx0XHRsZXZlbC5lbCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG4gIFx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuICBcdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG4gIFx0XHRcdGZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG4gIFx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG4gIFx0XHRyZXR1cm4gbGV2ZWw7XG4gIFx0fSxcblxuICBcdF9vblVwZGF0ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uUmVtb3ZlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfb25DcmVhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXksIHRpbGU7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcbiAgXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG4gIFx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcbiAgXHRcdFx0XHRjb250aW51ZTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcbiAgXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuICBcdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG4gIFx0XHQgICAgejIgPSB6IC0gMSxcbiAgXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcbiAgXHRcdGNvb3JkczIueiA9ICt6MjtcblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcbiAgXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICBcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHoyID4gbWluWm9vbSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuICBcdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcbiAgXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRcdFx0Y29udGludWU7XG5cbiAgXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcbiAgXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG4gIFx0fSxcblxuICBcdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHpvb207XG4gIFx0fSxcblxuICBcdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuICBcdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcbiAgXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuICBcdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG4gIFx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG4gIFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cbiAgXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG4gIFx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIW5vUHJ1bmUpIHtcbiAgXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuICBcdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcbiAgXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuICBcdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuICBcdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG4gIFx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcbiAgXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuICBcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuICBcdFx0XTtcbiAgXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcbiAgXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG4gIFx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG4gIFx0fSxcblxuICBcdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuICBcdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIFx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG4gIFx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuICBcdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuICBcdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuICBcdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG4gIFx0XHQgICAgcXVldWUgPSBbXSxcbiAgXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcbiAgXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuICBcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cbiAgXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuICBcdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3JkcztcbiAgXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcbiAgXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG4gIFx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuICBcdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG4gIFx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG4gIFx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cbiAgXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuICBcdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuICBcdFx0XHRcdGlmICh0aWxlKSB7XG4gIFx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuICBcdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuICBcdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcbiAgXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG4gIFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcbiAgXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcbiAgXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcbiAgXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuICBcdH0sXG5cbiAgXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuICBcdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG4gIFx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcbiAgXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuICBcdFx0cmV0dXJuIFtudywgc2VdO1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG4gIFx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG4gIFx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gYm91bmRzO1xuICBcdH0sXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG4gIFx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcbiAgXHR9LFxuXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcbiAgXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuICBcdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuICBcdFx0Y29vcmRzLnogPSAra1syXTtcbiAgXHRcdHJldHVybiBjb29yZHM7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHJlbW92ZSh0aWxlLmVsKTtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG4gIFx0XHRhZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4JztcbiAgXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cbiAgXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gIFx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcblxuICBcdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuICBcdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG4gIFx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cbiAgXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG4gIFx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuICBcdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcbiAgXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2VcbiAgXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuICBcdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuICBcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcbiAgXHRcdH1cblxuICBcdFx0c2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cbiAgXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICBcdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcbiAgXHRcdFx0ZWw6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzLFxuICBcdFx0XHRjdXJyZW50OiB0cnVlXG4gIFx0XHR9O1xuXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG4gIFx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICBcdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuICBcdFx0XHR0aWxlOiB0aWxlLFxuICBcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcbiAgXHRcdFx0XHRlcnJvcjogZXJyLFxuICBcdFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG4gIFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFlcnIpIHtcbiAgXHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cbiAgXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcbiAgXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuICBcdFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gIFx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuICBcdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgXHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG4gIFx0fSxcblxuICBcdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuICBcdFx0XHR0aGlzLl93cmFwWCA/IHdyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuICBcdFx0XHR0aGlzLl93cmFwWSA/IHdyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcbiAgXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG4gIFx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuICBcdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuICBcdH0sXG5cbiAgXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbiAgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllclxyXG4gICAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1pblpvb206IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWF4Wm9vbTogMTgsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcbiAgXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gIFx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG4gIFx0XHR0bXM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuICBcdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuICBcdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuXHJcbiAgXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcbiAgXHRcdC8vIChlLmcuIHRvIHZhbGlkYXRlIGFuIEFQSSB0b2tlbikuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtIVE1MSW1hZ2VFbGVtZW50LnJlZmVycmVyUG9saWN5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudC9yZWZlcnJlclBvbGljeSkgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuICBcdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcbiAgXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuICBcdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuICBcdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuICBcdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG4gIFx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG4gIFx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuICBcdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuICBcdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuICBcdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuICBcdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcbiAgXHRcdG9uKHRpbGUsICdsb2FkJywgYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcbiAgXHRcdG9uKHRpbGUsICdlcnJvcicsIGJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZm9yIHRoaXMgbmV3IG9wdGlvbiB3ZSBmb2xsb3cgdGhlIGRvY3VtZW50ZWQgYmVoYXZpb3JcclxuICBcdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuICBcdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0dGlsZS5yZWZlcnJlclBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0LypcclxuICBcdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuICBcdFx0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcbiAgXHRcdCovXHJcbiAgXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgU2V0IHJvbGU9XCJwcmVzZW50YXRpb25cIiB0byBmb3JjZSBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhpc1xyXG4gIFx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcbiAgXHRcdCovXHJcbiAgXHRcdHRpbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cclxuICBcdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aWxlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQHVuaW5oZXJpdGFibGVcclxuICBcdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG4gIFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcbiAgXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcbiAgXHRcdFx0eDogY29vcmRzLngsXHJcbiAgXHRcdFx0eTogY29vcmRzLnksXHJcbiAgXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcbiAgXHRcdH07XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG4gIFx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG4gIFx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG4gIFx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG4gIFx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRkb25lKGUsIHRpbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuICBcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG4gIFx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuICBcdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuICBcdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuICBcdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcbiAgXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpLCB0aWxlO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcbiAgXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG4gIFx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuICBcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG4gIFx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG4gIFx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcbiAgXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gQGV2ZW50IHRpbGVhYm9ydDogVGlsZUV2ZW50XHJcbiAgXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuICBcdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcbiAgXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcclxuICBcdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcbiAgXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gICAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gICAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gICAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gICAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICAgKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuICBcdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuICBcdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcbiAgXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cHM6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuICBcdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuICBcdFx0c2VydmljZTogJ1dNUycsXHJcbiAgXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuICBcdFx0bGF5ZXJzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG4gIFx0XHRzdHlsZXM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG4gIFx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuICBcdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG4gIFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuICBcdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcbiAgXHRcdHZlcnNpb246ICcxLjEuMSdcclxuICBcdH0sXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG4gIFx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG4gIFx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuICBcdFx0Y3JzOiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG4gIFx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG4gIFx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuICBcdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcclxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG4gIFx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuICBcdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuICBcdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuICBcdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG4gIFx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuICBcdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcbiAgXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuICBcdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuICBcdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcbiAgXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcbiAgXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuICBcdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuICBcdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiB1cmwgK1xyXG4gIFx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuICBcdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuICBcdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcbiAgXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbiAgdGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuICAvKlxuICAgKiBAY2xhc3MgUmVuZGVyZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5SZW5kZXJlclxuICAgKlxuICAgKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICAgKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICAgKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAgICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICAgKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gICAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcbiAgXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuICBcdFx0cGFkZGluZzogMC4xXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0c3RhbXAodGhpcyk7XG4gIFx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cbiAgXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcbiAgXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gIFx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuICBcdH0sXG5cbiAgXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG4gIFx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuICBcdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKGN1cnJlbnRDZW50ZXJQb2ludClcbiAgXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG4gIFx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICBcdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcbiAgXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcbiAgXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gIFx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDYW52YXNcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5DYW52YXNcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vY2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gICAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG4gIFx0XHR0b2xlcmFuY2U6IDBcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuICBcdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuICBcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuICBcdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuICBcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cbiAgXHRcdHRoaXMuX2RyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuICBcdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fY3R4O1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBsYXllcjtcbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICBcdFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG4gIFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG4gIFx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuICBcdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG4gIFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cbiAgXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuICBcdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuICBcdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG4gIFx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcbiAgXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxuICBcdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcbiAgXHRcdFx0bmV4dDogbnVsbFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcbiAgXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcbiAgXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuICBcdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcbiAgXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuICBcdFx0XHQgICAgZGFzaFZhbHVlLFxuICBcdFx0XHQgICAgaTtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcbiAgXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuICBcdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuICBcdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcbiAgXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG4gIFx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcbiAgXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG4gIFx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cbiAgXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuICBcdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuICBcdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuICBcdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmIChjbG9zZWQpIHtcbiAgXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuICBcdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHguc2F2ZSgpO1xuICBcdFx0XHRjdHguc2NhbGUoMSwgcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcbiAgXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuICBcdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcbiAgXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICBcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuICBcdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG4gIFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuICBcdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuICBcdFx0XHRjdHguc3Ryb2tlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuICBcdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG4gIFx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG4gIFx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG4gIFx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcbiAgXHR9LFxuXG5cbiAgXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG4gIFx0XHRpZiAobGF5ZXIpIHtcbiAgXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG4gIFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICBcdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG4gIFx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3JcbiAgXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcbiAgXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG4gIFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcbiAgXHRcdHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH0sIHRoaXMpLCAzMik7XG4gIFx0fSxcblxuICBcdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcbiAgXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuICBcdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICAgKi9cblxuXG4gIHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdHRyeSB7XG4gIFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gIFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcbiAgXHR9XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0fTtcbiAgfSkoKTtcblxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICpcbiAgICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICovXG5cbiAgLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbiAgdmFyIHZtbE1peGluID0ge1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuICBcdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG4gIFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHRyZW1vdmUoY29udGFpbmVyKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcbiAgXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuICBcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuICBcdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0aWYgKCFzdHJva2UpIHtcbiAgXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4JztcbiAgXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuICBcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICBcdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGlmICghZmlsbCkge1xuICBcdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcbiAgXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuU1ZHXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL3N2ZyksIFNWRyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAgICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAgICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICAgKiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG4gIFx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICBcdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG4gIFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG4gIFx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgXHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cbiAgXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcbiAgXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cbiAgXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG4gIFx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcbiAgXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcbiAgXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcbiAgXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuICBcdH0sXG5cbiAgXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9CYWNrKGxheWVyLl9wYXRoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIGlmIChCcm93c2VyLnZtbCkge1xuICBcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbiAgfVxuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHXG4gIC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG4gIFx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcbiAgXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG4gIFx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuICBcdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuICBcdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuICBcdFx0aWYgKCFyZW5kZXJlcikge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG4gIFx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG4gIFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAgICovXG5cbiAgLypcbiAgICogQGNsYXNzIFJlY3RhbmdsZVxuICAgKiBAYWthIEwuUmVjdGFuZ2xlXG4gICAqIEBpbmhlcml0cyBQb2x5Z29uXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICAgKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICAgKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKi9cblxuXG4gIHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuICBcdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG4gIFx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG4gIFx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcbiAgXHR9LFxuXG4gIFx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuICBcdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcbiAgXHRcdHJldHVybiBbXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuICBcdFx0XTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFNWRy5jcmVhdGUgPSBjcmVhdGU7XG4gIFNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbiAgR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG4gIEdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3JkcztcbiAgR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG4gIEdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG4gIEdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG4gIFx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG4gIFx0Ym94Wm9vbTogdHJ1ZVxuICB9KTtcblxuICB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmUodGhpcy5fcGFuZSk7XG4gIFx0XHRkZWxldGUgdGhpcy5fcGFuZTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG4gIFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuICBcdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0b24oZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cbiAgXHRcdFx0dGhpcy5fYm94ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuICBcdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cbiAgXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuICBcdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gIFx0fSxcblxuICBcdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fYm94KTtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcbiAgXHRcdH1cblxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdG9mZihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9maW5pc2goKTtcblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cbiAgXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuICBcdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuICBcdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gIFx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuICBcdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuICAvLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcbiAgXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcbiAgXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAgXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcbiAgXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy9cbiAgLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4gIC8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbiAgLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIGBgYGpzXG4gIC8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuICAvLyBgYGBcbiAgLy9cbiAgLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuICAvLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cbiAgXHRkcmFnZ2luZzogdHJ1ZSxcblxuICBcdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuICBcdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcbiAgXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuICBcdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcbiAgXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gIFx0aW5lcnRpYTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuICBcdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cbiAgXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuICBcdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG4gIFx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG4gIFx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cbiAgXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuICBcdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuICBcdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG4gIFx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuICBcdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG4gIFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuICBcdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG4gIFx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcbiAgXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG4gIFx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcbiAgXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cbiAgXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxuICB9KTtcblxuICB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHRcdH0sIHRoaXMpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcbiAgXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcbiAgXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcbiAgXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG4gIFx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcbiAgXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcbiAgXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG4gIFx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0bWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcbiAgXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuICBcdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuICBcdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cbiAgXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG4gIFx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcbiAgXHR9LFxuXG4gIFx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcbiAgXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cbiAgXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuICBcdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuICBcdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cbiAgXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcbiAgXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcbiAgXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcbiAgXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcbiAgXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG4gIFx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gIFx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG4gIFx0XHRpZiAobm9JbmVydGlhKSB7XG4gIFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuICBcdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuICBcdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuICBcdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuICBcdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuICBcdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuICBcdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG4gIFx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG4gIFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG4gIFx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcbiAgXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG4gIFx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cbiAgLypcbiAgICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG4gIFx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG4gIFx0a2V5Ym9hcmQ6IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG4gIFx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG4gIFx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbiAgfSk7XG5cbiAgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG4gIFx0a2V5Q29kZXM6IHtcbiAgXHRcdGxlZnQ6ICAgIFszN10sXG4gIFx0XHRyaWdodDogICBbMzldLFxuICBcdFx0ZG93bjogICAgWzQwXSxcbiAgXHRcdHVwOiAgICAgIFszOF0sXG4gIFx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuICBcdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cbiAgXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuICBcdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cbiAgXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuICBcdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG4gIFx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcbiAgXHRcdH1cblxuICBcdFx0b24oY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub24oe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9mZih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gIFx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIFx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuICBcdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuICBcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuICBcdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG4gIFx0fSxcblxuICBcdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuICBcdH0sXG5cbiAgXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvZmZzZXQ7XG5cbiAgXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuICBcdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuICBcdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG4gIFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuICBcdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHN0b3AoZSk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbiAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcbiAgXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcbiAgXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuICBcdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuICBcdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcbiAgXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG4gIFx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuICBcdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuICBcdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG4gIH0pO1xuXG4gIHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuXG4gIFx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuICBcdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG4gIFx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG4gIFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIFx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH0sXG5cbiAgXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG4gIFx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcbiAgXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcbiAgXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG4gIFx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG4gIFx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSA9IDA7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuICAvLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcblxuICAvKlxuICAgKiBMLk1hcC5UYXBIb2xkIGlzIHVzZWQgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCBvbiBsb25nIGhvbGQsXG4gICAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAgICovXG5cbiAgdmFyIHRhcEhvbGREZWxheSA9IDYwMDtcblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHRhcEhvbGQ6IEJvb2xlYW5cbiAgXHQvLyBFbmFibGVzIHNpbXVsYXRpb24gb2YgYGNvbnRleHRtZW51YCBldmVudCwgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIG1vYmlsZSBTYWZhcmkuXG4gIFx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuICBcdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuICBcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG4gIFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG4gIFx0dGFwVG9sZXJhbmNlOiAxNVxuICB9KTtcblxuICB2YXIgVGFwSG9sZCA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcbiAgXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICBcdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLl9jYW5jZWwoKTtcbiAgXHRcdFx0aWYgKCF0aGlzLl9pc1RhcFZhbGlkKCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fY2FuY2VsQ2xpY2tQcmV2ZW50KTtcbiAgXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG4gIFx0XHR9LCB0aGlzKSwgdGFwSG9sZERlbGF5KTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9jYW5jZWxDbGlja1ByZXZlbnQ6IGZ1bmN0aW9uIGNhbmNlbENsaWNrUHJldmVudCgpIHtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBjYW5jZWxDbGlja1ByZXZlbnQpO1xuICBcdH0sXG5cbiAgXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcbiAgXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcbiAgXHR9LFxuXG4gIFx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuICBcdH0sXG5cbiAgXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIHtcbiAgXHRcdFx0YnViYmxlczogdHJ1ZSxcbiAgXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcbiAgXHRcdFx0dmlldzogd2luZG93LFxuICBcdFx0XHQvLyBkZXRhaWw6IDEsXG4gIFx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgXHRcdFx0c2NyZWVuWTogZS5zY3JlZW5ZLFxuICBcdFx0XHRjbGllbnRYOiBlLmNsaWVudFgsXG4gIFx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcbiAgXHRcdFx0Ly8gYnV0dG9uOiAyLFxuICBcdFx0XHQvLyBidXR0b25zOiAyXG4gIFx0XHR9KTtcblxuICBcdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cbiAgXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbiAgLy8gTG9uZyB0YXAgaGFuZGxlciB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50ICh1c2VmdWwgaW4gbW9iaWxlIFNhZmFyaSkuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXBIb2xkJywgVGFwSG9sZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuICBcdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG4gIFx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcbiAgXHQvLyBicm93c2Vycy5cbiAgXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cbiAgXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cbiAgXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG4gIFx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG4gIFx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcbiAgXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG4gIFx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuICBcdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuICBcdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuICBcdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcbiAgXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG4gIFx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cbiAgXHRcdHZhciBtb3ZlRm4gPSBiaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG4gIFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbiAgLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuICBNYXAuQm94Wm9vbSA9IEJveFpvb207XG4gIE1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG4gIE1hcC5EcmFnID0gRHJhZztcbiAgTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gIE1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG4gIE1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbiAgTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuICBleHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcbiAgZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbiAgZXhwb3J0cy5DUlMgPSBDUlM7XG4gIGV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuICBleHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiAgZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbiAgZXhwb3J0cy5EaXZJY29uID0gRGl2SWNvbjtcbiAgZXhwb3J0cy5EaXZPdmVybGF5ID0gRGl2T3ZlcmxheTtcbiAgZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuICBleHBvcnRzLkRvbVV0aWwgPSBEb21VdGlsO1xuICBleHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbiAgZXhwb3J0cy5FdmVudGVkID0gRXZlbnRlZDtcbiAgZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG4gIGV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuICBleHBvcnRzLkhhbmRsZXIgPSBIYW5kbGVyO1xuICBleHBvcnRzLkljb24gPSBJY29uO1xuICBleHBvcnRzLkltYWdlT3ZlcmxheSA9IEltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5MYXRMbmcgPSBMYXRMbmc7XG4gIGV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLkxheWVyID0gTGF5ZXI7XG4gIGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG4gIGV4cG9ydHMuTGluZVV0aWwgPSBMaW5lVXRpbDtcbiAgZXhwb3J0cy5NYXAgPSBNYXA7XG4gIGV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuICBleHBvcnRzLk1peGluID0gTWl4aW47XG4gIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gIGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiAgZXhwb3J0cy5Qb2x5VXRpbCA9IFBvbHlVdGlsO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG4gIGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbiAgZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG4gIGV4cG9ydHMuUHJvamVjdGlvbiA9IGluZGV4O1xuICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICBleHBvcnRzLlNWRyA9IFNWRztcbiAgZXhwb3J0cy5TVkdPdmVybGF5ID0gU1ZHT3ZlcmxheTtcbiAgZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG4gIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG4gIGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy5VdGlsID0gVXRpbDtcbiAgZXhwb3J0cy5WaWRlb092ZXJsYXkgPSBWaWRlb092ZXJsYXk7XG4gIGV4cG9ydHMuYmluZCA9IGJpbmQ7XG4gIGV4cG9ydHMuYm91bmRzID0gdG9Cb3VuZHM7XG4gIGV4cG9ydHMuY2FudmFzID0gY2FudmFzO1xuICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcbiAgZXhwb3J0cy5jaXJjbGVNYXJrZXIgPSBjaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuY29udHJvbCA9IGNvbnRyb2w7XG4gIGV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5nZW9KU09OID0gZ2VvSlNPTjtcbiAgZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbiAgZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG4gIGV4cG9ydHMuaWNvbiA9IGljb247XG4gIGV4cG9ydHMuaW1hZ2VPdmVybGF5ID0gaW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLmxhdExuZyA9IHRvTGF0TG5nO1xuICBleHBvcnRzLmxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuICBleHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcbiAgZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG4gIGV4cG9ydHMucG9pbnQgPSB0b1BvaW50O1xuICBleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuICBleHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG4gIGV4cG9ydHMucG9wdXAgPSBwb3B1cDtcbiAgZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIGV4cG9ydHMuc3RhbXAgPSBzdGFtcDtcbiAgZXhwb3J0cy5zdmcgPSBzdmc7XG4gIGV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG4gIGV4cG9ydHMudGlsZUxheWVyID0gdGlsZUxheWVyO1xuICBleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuICBleHBvcnRzLnRyYW5zZm9ybWF0aW9uID0gdG9UcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG5cbiAgdmFyIG9sZEwgPSB3aW5kb3cuTDtcbiAgZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIFx0d2luZG93LkwgPSBvbGRMO1xuICBcdHJldHVybiB0aGlzO1xuICB9XG4gIC8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxuICB3aW5kb3cuTCA9IGV4cG9ydHM7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/leaflet-src.js\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_leaflet_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./leaflet.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/leaflet/dist/leaflet.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_leaflet_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_leaflet_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0U7QUFDL0UsWUFBZ0s7O0FBRWhLOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSw2RkFBRyxDQUFDLGtKQUFPOzs7O0FBSXhCLGlFQUFlLHlKQUFjLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzYwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzFdIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4vbGVhZmxldC5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/leaflet.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFFQUFxRSxxQkFBcUIsY0FBYzs7QUFFeEc7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz9kYmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./resources/js/components/Modules/Map.vue":
/*!*************************************************!*\
  !*** ./resources/js/components/Modules/Map.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Map_vue_vue_type_template_id_3f331799__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Map.vue?vue&type=template&id=3f331799 */ \"./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799\");\n/* harmony import */ var _Map_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map.vue?vue&type=script&lang=js */ \"./resources/js/components/Modules/Map.vue?vue&type=script&lang=js\");\n/* harmony import */ var D_OpenServer_domains_e_ijara_e_ijara_front_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\nconst __exports__ = /*#__PURE__*/(0,D_OpenServer_domains_e_ijara_e_ijara_front_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_Map_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_Map_vue_vue_type_template_id_3f331799__WEBPACK_IMPORTED_MODULE_0__.render],['__file',\"resources/js/components/Modules/Map.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Nb2R1bGVzL01hcC52dWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUNWO0FBQ0w7O0FBRWpELENBQThIO0FBQzlILGlDQUFpQyxtSUFBZSxDQUFDLHdFQUFNLGFBQWEsMEVBQU07QUFDMUU7QUFDQSxJQUFJLEtBQVUsRUFBRSxFQVlmOzs7QUFHRCxpRUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL01vZHVsZXMvTWFwLnZ1ZT8zZDU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL01hcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9M2YzMzE3OTlcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9NYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL01hcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCJEOlxcXFxPcGVuU2VydmVyXFxcXGRvbWFpbnNcXFxcZS1pamFyYVxcXFxlLWlqYXJhLWZyb250XFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtbG9hZGVyXFxcXGRpc3RcXFxcZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fZmlsZScsXCJyZXNvdXJjZXMvanMvY29tcG9uZW50cy9Nb2R1bGVzL01hcC52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiM2YzMzE3OTlcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCczZjMzMTc5OScsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJzNmMzMxNzk5JywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9NYXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTNmMzMxNzk5XCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzNmMzMxNzk5JywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Modules/Map.vue\n");

/***/ }),

/***/ "./resources/js/components/Modules/Map.vue?vue&type=script&lang=js":
/*!*************************************************************************!*\
  !*** ./resources/js/components/Modules/Map.vue?vue&type=script&lang=js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Map_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Map_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Map.vue?vue&type=script&lang=js */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=script&lang=js\");\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Nb2R1bGVzL01hcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Nb2R1bGVzL01hcC52dWU/MDdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9NYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vTWFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Modules/Map.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799":
/*!*******************************************************************************!*\
  !*** ./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799 ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Map_vue_vue_type_template_id_3f331799__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Map_vue_vue_type_template_id_3f331799__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Map.vue?vue&type=template&id=3f331799 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Modules/Map.vue?vue&type=template&id=3f331799");


/***/ })

}]);